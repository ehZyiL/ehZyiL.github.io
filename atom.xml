<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ehZyiL的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-29T14:36:45.337Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ehZyiL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统原理 第二章总结2.1-2.4(picture)</title>
    <link href="http://example.com/2021/09/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%80%BB%E7%BB%932.1-2.4(picture)/"/>
    <id>http://example.com/2021/09/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%80%BB%E7%BB%932.1-2.4(picture)/</id>
    <published>2021-09-29T14:31:37.000Z</published>
    <updated>2021-09-29T14:36:45.337Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8608.wmv_20210907_211328.093.png" alt="操作系统原理08.wmv_20210907_211328.093"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8608.wmv_20210907_212001.066.png" alt="操作系统原理08.wmv_20210907_212001.066"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8608.wmv_20210907_212003.307.png" alt="操作系统原理08.wmv_20210907_212003.307"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8608.wmv_20210907_212222.029.png" alt="操作系统原理08.wmv_20210907_212222.029"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8608.wmv_20210907_212350.317.png" alt="操作系统原理08.wmv_20210907_212350.317"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8608.wmv_20210907_212519.880.png" alt="操作系统原理08.wmv_20210907_212519.880"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8608.wmv_20210907_213604.291.png" alt="操作系统原理08.wmv_20210907_213604.291"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8608.wmv_20210907_213747.292.png" alt="操作系统原理08.wmv_20210907_213747.292"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8608.wmv_20210907_214328.166.png" alt="操作系统原理08.wmv_20210907_214328.166"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8608.wmv_20210907_214627.219.png" alt="操作系统原理08.wmv_20210907_214627.219"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8608.wmv_20210907_214949.148.png" alt="操作系统原理08.wmv_20210907_214949.148"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8608.wmv_20210907_215225.394.png" alt="操作系统原理08.wmv_20210907_215225.394"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8608.wmv_20210907_215409.956.png" alt="操作系统原理08.wmv_20210907_215409.956"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8609.wmv_20210908_130404.473.png" alt="操作系统原理09.wmv_20210908_130404.473"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8609.wmv_20210908_131238.988.png" alt="操作系统原理09.wmv_20210908_131238.988"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8609.wmv_20210908_131344.816.png" alt="操作系统原理09.wmv_20210908_131344.816"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8609.wmv_20210908_131722.211.png" alt="操作系统原理09.wmv_20210908_131722.211"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8609.wmv_20210908_131733.599.png" alt="操作系统原理09.wmv_20210908_131733.599"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8609.wmv_20210908_131856.526.png" alt="操作系统原理09.wmv_20210908_131856.526"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8609.wmv_20210908_131928.941.png" alt="操作系统原理09.wmv_20210908_131928.941"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8609.wmv_20210908_132207.264.png" alt="操作系统原理09.wmv_20210908_132207.264"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8609.wmv_20210908_132257.673.png" alt="操作系统原理09.wmv_20210908_132257.673"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8609.wmv_20210908_132700.230.png" alt="操作系统原理09.wmv_20210908_132700.230"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_200530.882.png" alt="操作系统原理10.wmv_20210908_200530.882"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_200534.440.png" alt="操作系统原理10.wmv_20210908_200534.440"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_232345.618.png" alt="操作系统原理10.wmv_20210908_232345.618"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_232436.725.png" alt="操作系统原理10.wmv_20210908_232436.725"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_232720.598.png" alt="操作系统原理10.wmv_20210908_232720.598"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_232725.424.png" alt="操作系统原理10.wmv_20210908_232725.424"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_232727.953.png" alt="操作系统原理10.wmv_20210908_232727.953"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_233036.676.png" alt="操作系统原理10.wmv_20210908_233036.676"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_233152.590.png" alt="操作系统原理10.wmv_20210908_233152.590"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_233245.621.png" alt="操作系统原理10.wmv_20210908_233245.621"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_233431.381.png" alt="操作系统原理10.wmv_20210908_233431.381"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_233533.470.png" alt="操作系统原理10.wmv_20210908_233533.470"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_233902.476.png" alt="操作系统原理10.wmv_20210908_233902.476"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8610.wmv_20210908_234048.578.png" alt="操作系统原理10.wmv_20210908_234048.578"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_090732.156.png" alt="操作系统原理11.wmv_20210909_090732.156"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_090942.866.png" alt="操作系统原理11.wmv_20210909_090942.866"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_090958.080.png" alt="操作系统原理11.wmv_20210909_090958.080"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_091127.935.png" alt="操作系统原理11.wmv_20210909_091127.935"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_091319.453.png" alt="操作系统原理11.wmv_20210909_091319.453"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_091723.885.png" alt="操作系统原理11.wmv_20210909_091723.885"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_091726.763.png" alt="操作系统原理11.wmv_20210909_091726.763"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_091822.114.png" alt="操作系统原理11.wmv_20210909_091822.114"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_091823.623.png" alt="操作系统原理11.wmv_20210909_091823.623"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_092225.708.png" alt="操作系统原理11.wmv_20210909_092225.708"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_092844.071.png" alt="操作系统原理11.wmv_20210909_092844.071"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_092908.351.png" alt="操作系统原理11.wmv_20210909_092908.351"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_093216.798.png" alt="操作系统原理11.wmv_20210909_093216.798"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_093300.899.png" alt="操作系统原理11.wmv_20210909_093300.899"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_093418.378.png" alt="操作系统原理11.wmv_20210909_093418.378"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_093549.099.png" alt="操作系统原理11.wmv_20210909_093549.099"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_093551.196.png" alt="操作系统原理11.wmv_20210909_093551.196"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_093639.380.png" alt="操作系统原理11.wmv_20210909_093639.380"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8611.wmv_20210909_093744.092.png" alt="操作系统原理11.wmv_20210909_093744.092"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_093946.441.png" alt="操作系统原理12.wmv_20210909_093946.441"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_093953.998.png" alt="操作系统原理12.wmv_20210909_093953.998"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_094212.481.png" alt="操作系统原理12.wmv_20210909_094212.481"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_094304.726.png" alt="操作系统原理12.wmv_20210909_094304.726"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_094351.713.png" alt="操作系统原理12.wmv_20210909_094351.713"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_094420.618.png" alt="操作系统原理12.wmv_20210909_094420.618"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_094740.994.png" alt="操作系统原理12.wmv_20210909_094740.994"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_094835.842.png" alt="操作系统原理12.wmv_20210909_094835.842"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_095007.453.png" alt="操作系统原理12.wmv_20210909_095007.453"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_095025.106.png" alt="操作系统原理12.wmv_20210909_095025.106"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_095027.954.png" alt="操作系统原理12.wmv_20210909_095027.954"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_095138.788.png" alt="操作系统原理12.wmv_20210909_095138.788"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_095507.883.png" alt="操作系统原理12.wmv_20210909_095507.883"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_095659.402.png" alt="操作系统原理12.wmv_20210909_095659.402"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_095713.818.png" alt="操作系统原理12.wmv_20210909_095713.818"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_095858.987.png" alt="操作系统原理12.wmv_20210909_095858.987"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_100006.036.png" alt="操作系统原理12.wmv_20210909_100006.036"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_100100.663.png" alt="操作系统原理12.wmv_20210909_100100.663"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_100144.266.png" alt="操作系统原理12.wmv_20210909_100144.266"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_100321.465.png" alt="操作系统原理12.wmv_20210909_100321.465"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_100536.334.png" alt="操作系统原理12.wmv_20210909_100536.334"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_100615.926.png" alt="操作系统原理12.wmv_20210909_100615.926"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_100738.252.png" alt="操作系统原理12.wmv_20210909_100738.252"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_100803.116.png" alt="操作系统原理12.wmv_20210909_100803.116"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_100841.015.png" alt="操作系统原理12.wmv_20210909_100841.015"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_101008.348.png" alt="操作系统原理12.wmv_20210909_101008.348"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8612.wmv_20210909_101013.341.png" alt="操作系统原理12.wmv_20210909_101013.341"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_213245.667.png" alt="操作系统原理13.wmv_20210913_213245.667"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_213428.176.png" alt="操作系统原理13.wmv_20210913_213428.176"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_213603.137.png" alt="操作系统原理13.wmv_20210913_213603.137"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_213607.041.png" alt="操作系统原理13.wmv_20210913_213607.041"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_213619.246.png" alt="操作系统原理13.wmv_20210913_213619.246"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_213622.346.png" alt="操作系统原理13.wmv_20210913_213622.346"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_213633.989.png" alt="操作系统原理13.wmv_20210913_213633.989"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_213636.403.png" alt="操作系统原理13.wmv_20210913_213636.403"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_213723.814.png" alt="操作系统原理13.wmv_20210913_213723.814"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_213852.728.png" alt="操作系统原理13.wmv_20210913_213852.728"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_214050.596.png" alt="操作系统原理13.wmv_20210913_214050.596"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_214231.589.png" alt="操作系统原理13.wmv_20210913_214231.589"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_214341.025.png" alt="操作系统原理13.wmv_20210913_214341.025"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_214435.053.png" alt="操作系统原理13.wmv_20210913_214435.053"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_214708.378.png" alt="操作系统原理13.wmv_20210913_214708.378"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_215024.353.png" alt="操作系统原理13.wmv_20210913_215024.353"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_215148.023.png" alt="操作系统原理13.wmv_20210913_215148.023"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_215252.765.png" alt="操作系统原理13.wmv_20210913_215252.765"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8613.wmv_20210913_215652.444.png" alt="操作系统原理13.wmv_20210913_215652.444"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_215940.324.png" alt="操作系统原理14.wmv_20210913_215940.324"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_215952.038.png" alt="操作系统原理14.wmv_20210913_215952.038"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_220322.022.png" alt="操作系统原理14.wmv_20210913_220322.022"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_220531.662.png" alt="操作系统原理14.wmv_20210913_220531.662"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_220722.125.png" alt="操作系统原理14.wmv_20210913_220722.125"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_220753.284.png" alt="操作系统原理14.wmv_20210913_220753.284"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_221037.988.png" alt="操作系统原理14.wmv_20210913_221037.988"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_221208.245.png" alt="操作系统原理14.wmv_20210913_221208.245"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_221210.723.png" alt="操作系统原理14.wmv_20210913_221210.723"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_221433.472.png" alt="操作系统原理14.wmv_20210913_221433.472"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_221438.813.png" alt="操作系统原理14.wmv_20210913_221438.813"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_221634.577.png" alt="操作系统原理14.wmv_20210913_221634.577"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_221719.676.png" alt="操作系统原理14.wmv_20210913_221719.676"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_221901.751.png" alt="操作系统原理14.wmv_20210913_221901.751"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_221904.214.png" alt="操作系统原理14.wmv_20210913_221904.214"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_221916.882.png" alt="操作系统原理14.wmv_20210913_221916.882"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8614.wmv_20210913_222019.528.png" alt="操作系统原理14.wmv_20210913_222019.528"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210914_224212.998.png" alt="操作系统原理15.wmv_20210914_224212.998"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210914_231323.612.png" alt="操作系统原理15.wmv_20210914_231323.612"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210914_231907.447.png" alt="操作系统原理15.wmv_20210914_231907.447"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_111737.158.png" alt="操作系统原理15.wmv_20210915_111737.158"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_111828.224.png" alt="操作系统原理15.wmv_20210915_111828.224"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_111901.838.png" alt="操作系统原理15.wmv_20210915_111901.838"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_112030.716.png" alt="操作系统原理15.wmv_20210915_112030.716"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_112133.703.png" alt="操作系统原理15.wmv_20210915_112133.703"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_112208.087.png" alt="操作系统原理15.wmv_20210915_112208.087"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_112329.073.png" alt="操作系统原理15.wmv_20210915_112329.073"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_112439.260.png" alt="操作系统原理15.wmv_20210915_112439.260"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_112520.983.png" alt="操作系统原理15.wmv_20210915_112520.983"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_112846.365.png" alt="操作系统原理15.wmv_20210915_112846.365"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_112951.973.png" alt="操作系统原理15.wmv_20210915_112951.973"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_113017.491.png" alt="操作系统原理15.wmv_20210915_113017.491"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_113020.742.png" alt="操作系统原理15.wmv_20210915_113020.742"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_113105.269.png" alt="操作系统原理15.wmv_20210915_113105.269"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8615.wmv_20210915_113211.132.png" alt="操作系统原理15.wmv_20210915_113211.132"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8616.wmv_20210915_113945.312.png" alt="操作系统原理16.wmv_20210915_113945.312"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8616.wmv_20210915_114055.707.png" alt="操作系统原理16.wmv_20210915_114055.707"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8616.wmv_20210915_114208.940.png" alt="操作系统原理16.wmv_20210915_114208.940"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8616.wmv_20210915_114309.874.png" alt="操作系统原理16.wmv_20210915_114309.874"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8616.wmv_20210915_114430.110.png" alt="操作系统原理16.wmv_20210915_114430.110"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8616.wmv_20210915_114541.583.png" alt="操作系统原理16.wmv_20210915_114541.583"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8616.wmv_20210915_114632.730.png" alt="操作系统原理16.wmv_20210915_114632.730"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0(2.1-2.4)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%8616.wmv_20210915_114640.222.png" alt="操作系统原理16.wmv_20210915_114640.222"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7</summary>
      
    
    
    
    <category term="操作系统原理" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="操作系统原理" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    <category term="总结" scheme="http://example.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>操作系统原理 第一章(picture)</title>
    <link href="http://example.com/2021/09/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0(picture)/"/>
    <id>http://example.com/2021/09/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0(picture)/</id>
    <published>2021-09-29T14:31:33.000Z</published>
    <updated>2021-09-29T14:34:04.921Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(169).png" alt="屏幕截图(169)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(170).png" alt="屏幕截图(170)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(171).png" alt="屏幕截图(171)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(172).png" alt="屏幕截图(172)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(173).png" alt="屏幕截图(173)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(174).png" alt="屏幕截图(174)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(175).png" alt="屏幕截图(175)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(176).png" alt="屏幕截图(176)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(177).png" alt="屏幕截图(177)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(178).png" alt="屏幕截图(178)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(179).png" alt="屏幕截图(179)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(180).png" alt="屏幕截图(180)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(181).png" alt="屏幕截图(181)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(182).png" alt="屏幕截图(182)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(183).png" alt="屏幕截图(183)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(184).png" alt="屏幕截图(184)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(185).png" alt="屏幕截图(185)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(186).png" alt="屏幕截图(186)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(187).png" alt="屏幕截图(187)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(188).png" alt="屏幕截图(188)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(189).png" alt="屏幕截图(189)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(190).png" alt="屏幕截图(190)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(191).png" alt="屏幕截图(191)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(192).png" alt="屏幕截图(192)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(193).png" alt="屏幕截图(193)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(194).png" alt="屏幕截图(194)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(195).png" alt="屏幕截图(195)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(196).png" alt="屏幕截图(196)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(197).png" alt="屏幕截图(197)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(198).png" alt="屏幕截图(198)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(199).png" alt="屏幕截图(199)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(200).png" alt="屏幕截图(200)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(201).png" alt="屏幕截图(201)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(202).png" alt="屏幕截图(202)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(203).png" alt="屏幕截图(203)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(204).png" alt="屏幕截图(204)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(205).png" alt="屏幕截图(205)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(206).png" alt="屏幕截图(206)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(207).png" alt="屏幕截图(207)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(208).png" alt="屏幕截图(208)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(209).png" alt="屏幕截图(209)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(210).png" alt="屏幕截图(210)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(211).png" alt="屏幕截图(211)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(212).png" alt="屏幕截图(212)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(213).png" alt="屏幕截图(213)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(214).png" alt="屏幕截图(214)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(215).png" alt="屏幕截图(215)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(216).png" alt="屏幕截图(216)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(217).png" alt="屏幕截图(217)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(218).png" alt="屏幕截图(218)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(219).png" alt="屏幕截图(219)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(220).png" alt="屏幕截图(220)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(221).png" alt="屏幕截图(221)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(222).png" alt="屏幕截图(222)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(223).png" alt="屏幕截图(223)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(224).png" alt="屏幕截图(224)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(225).png" alt="屏幕截图(225)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(226).png" alt="屏幕截图(226)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(227).png" alt="屏幕截图(227)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(228).png" alt="屏幕截图(228)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(229).png" alt="屏幕截图(229)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(230).png" alt="屏幕截图(230)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(231).png" alt="屏幕截图(231)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(232).png" alt="屏幕截图(232)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(233).png" alt="屏幕截图(233)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(234).png" alt="屏幕截图(234)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(235).png" alt="屏幕截图(235)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(236).png" alt="屏幕截图(236)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(237).png" alt="屏幕截图(237)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(238).png" alt="屏幕截图(238)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(239).png" alt="屏幕截图(239)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(240).png" alt="屏幕截图(240)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(241).png" alt="屏幕截图(241)"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(242).png" alt="屏幕截图(242)"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7</summary>
      
    
    
    
    <category term="操作系统原理" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="操作系统原理" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    <category term="总结" scheme="http://example.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>操作系统原理 第二章总结2.1-2.4</title>
    <link href="http://example.com/2021/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%80%BB%E7%BB%932.1-2.4/"/>
    <id>http://example.com/2021/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%80%BB%E7%BB%932.1-2.4/</id>
    <published>2021-09-26T14:04:17.462Z</published>
    <updated>2021-09-26T14:28:01.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二章-进程管理-2-1-2-4"><a href="#第二章-进程管理-2-1-2-4" class="headerlink" title="第二章 进程管理 2.1-2.4"></a>第二章 进程管理 2.1-2.4</h2><h3 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h3><ol><li>基础:进程描述及控制</li><li>策略:进程调度</li><li>实现:互斥与同步</li><li>避免:死锁与饥饿</li><li>饥饿:指长时间等待，没有得到回答</li><li>解决:几个经典问题</li><li>关于:进程通信</li></ol><h3 id="2-1进程的引入"><a href="#2-1进程的引入" class="headerlink" title="2.1进程的引入"></a>2.1进程的引入</h3><h4 id="程序顺序执行"><a href="#程序顺序执行" class="headerlink" title="程序顺序执行"></a>程序顺序执行</h4><ul><li>程序:源代码程序、目标程序和可执行程序<br>号</li><li>程序执行:编辑、编译、链接、执行</li><li>程序的结构:顺序结构、分支结构和循环结构</li><li>程序顺序执行的特征:顺序性、封闭性、可再现性</li></ul><h4 id="程序并发执行"><a href="#程序并发执行" class="headerlink" title="程序并发执行"></a>程序并发执行</h4><ul><li><p>多道程序设计技术:多个程序并发执行</p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210911112709441.png" alt="image-20210911112709441"></p></li><li><p>程序并发执行时的特征:间断性、非封闭性、不可再现性</p></li></ul><h5 id="程序并发执行引发的问题"><a href="#程序并发执行引发的问题" class="headerlink" title="程序并发执行引发的问题"></a>程序并发执行引发的问题</h5><ul><li>协调各程序的执行顺序<pre><code>例如,当输入的数据还未全部输入内存时，计算必须等待</code></pre>多个执行程序共享系统资源，程序之间可能会相互影响，甚至影响输出结果</li><li>选择哪些、多少个程序进入内存执行?</li><li>内存中的执行程序谁先执行,谁后执行?</li><li>内存如何有效分配?</li></ul><h4 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h4><ul><li>定义:可并发执行的程序,在一个数据集合上的运行过程。</li><li>申请/拥有资源 调度(线程)</li><li>程序:静态概念,是指令和数据的集合,可长期存储</li><li>进程与程序对应关系:<pre><code>一个程序可以对应一个进程或多个进程一个进程可以对应一个程序，或者一段程序</code></pre></li></ul><h4 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h4><ul><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性</li></ul><h4 id="引入进程带来的问题"><a href="#引入进程带来的问题" class="headerlink" title="引入进程带来的问题"></a>引入进程带来的问题</h4><ul><li>增加了空间开销:为进程建立数据结构</li><li>额外的时间开销:管理和协调、跟踪、填写和更新有关数据结构、切换进程、保护现场</li><li>更难控制:<pre><code>-协调多个进程竞争和共享资源如何预防</code></pre>   -解决多个进程因为竞争资源而出现故障</li><li>处理机的竞争尤为突出</li></ul><h4 id="进程的结构"><a href="#进程的结构" class="headerlink" title="进程的结构"></a>进程的结构</h4><ul><li>组成:(进程映像):程序、数据集合、进程控制块PCB (Process Control Block)</li><li>PCB是进程存在的唯一标志。创建进程时,创建PCB;进程结束时，系统将撤消其PCB</li></ul><h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><ul><li>进程标识信息:进程的内部和外部标识符</li><li>处理机状态信息:通用寄存器值、指令计数器值、程序状态字PSW值、用户栈指针值</li><li>进程调度信息:进程状态、进程优先权、进程调度的其它信息</li><li>其它信息:程序及数据地址、进程同步和通讯机制、资源清单、链接指针</li></ul><h5 id="PCB的组织方式之一-单一队列"><a href="#PCB的组织方式之一-单一队列" class="headerlink" title="PCB的组织方式之一 单一队列"></a>PCB的组织方式之一 单一队列</h5><ul><li>所有进程的PCB通过链表组织成为一个单一队列。适用于进程数目不多的系统。如，Windows操作系统。</li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/mage-20210911170654392.png" alt="image-20210911170654392"></p><h5 id="PCB的组织方式之二-表格结构"><a href="#PCB的组织方式之二-表格结构" class="headerlink" title="PCB的组织方式之二 表格结构"></a>PCB的组织方式之二 表格结构</h5><ul><li>PCB按进程状态不同,组织成不同的表格:就绪进程表、执行进程表（多机系统中)及阻塞进程表</li><li>系统分别记载各PCB表的起始地址</li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210911113206845.png" alt="image-20210911113206845"></p><h5 id="PCB的组织方式之三-多级队列"><a href="#PCB的组织方式之三-多级队列" class="headerlink" title="PCB的组织方式之三 多级队列"></a>PCB的组织方式之三 多级队列</h5><ul><li>PCB按进程状态不同用链接指针组成不同队列:就绪进程队列、阻塞进程队列(可按阻塞原因不同,分别组织)</li><li>系统分别记载各PCB链表的起始地址</li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210911113249776.png" alt="image-20210911113249776"></p><h3 id="2-2进程的状态"><a href="#2-2进程的状态" class="headerlink" title="2.2进程的状态"></a>2.2进程的状态</h3><h4 id="进程执行轨迹"><a href="#进程执行轨迹" class="headerlink" title="进程执行轨迹"></a>进程执行轨迹</h4><ul><li><p>进程的轨迹:进程执行的指令序列,用以观察处理机的执行过程。</p></li><li><p>例，假设内存中有3个进程A、B、C，他们的程序代码已全部装入内存。若A、B两进程需要执行12条指令，C进程需要执行4条指令，且C进程执行到第4条指令处必须等待</p></li><li><p>假设分派程序分派处理机需要依<br>指令序列:s+0,s+1,,s+5</p></li><li><p>进程A的执行轨迹为a+0,a+1,a+2,a+3,</p></li><li><p>进程B的执行轨迹为b+0,b+1,b+2,b+3,</p></li><li><p>进程C的执行轨迹为c+0,c+ 1,c+2,c+3,当它执行到c+3指令时遇到了IO指令，需要释放处理机，进行输入/输出操作</p></li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210911113433068.png" alt="image-20210911113433068"></p><h4 id="两状态进程模型"><a href="#两状态进程模型" class="headerlink" title="两状态进程模型"></a>两状态进程模型</h4><ul><li><p>两状态:执行、未执行</p></li><li><p>进程获得处理机,进入执行状态;当时间片结束或其它某种原因,进程释放处理机，暂停执行,处于未执行状态。</p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210911113621308.png" alt="image-20210911113621308"></p></li></ul><h4 id="两状态进程模型-队列形式"><a href="#两状态进程模型-队列形式" class="headerlink" title="两状态进程模型:队列形式"></a>两状态进程模型:队列形式</h4><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210911113645644.png" alt="image-20210911113645644"></p><p><strong>注:</strong></p><ul><li>并非所有进程只要“未执行”就处于就绪( ready),有的需要阻塞（ blocked )等待IO完成</li><li>“未执行”又可分为就绪和阻塞</li></ul><h4 id="进程的五状态"><a href="#进程的五状态" class="headerlink" title="进程的五状态"></a>进程的五状态</h4><ul><li>执行状态（Running)</li><li>就绪状态（Ready)</li><li>阻塞状态（Blocked)</li><li>新状态（New)</li><li>终止状态（Terminated）</li></ul><ol><li>新状态:进程已经创建。但未被0S接纳为可执行进程</li><li>就绪状态:准备执行</li><li>执行状态:占用处理机(单处理机环境中,某一时刻仅一个进程占用处理机)</li><li>阻塞状态:等待某事件发生才能执行,如等待I/0完成等</li><li>终止状态:因停止或取消,被OS从执行状态释放</li></ol><p>&lt;/img src=”/img/操作系统原理/第二章/image-20210911113813732.png” alt=”image-20210911113813732” style=”zoom: 67%;” /&gt;</p><ol><li>空→新状态     新创建的进程首先处于新状态。</li><li>新状态→就绪状态      当系统允许增加就绪进程时，操作系统接纳新建状态进程，将它变为就绪状态，插入就绪队列中。</li><li>就绪状态→执行状态    当处理机空闲时，将从就绪队列中选择一个进程执行，该选择过程称为进程调度，或将处理机分派给一个进程，该进程状态从就绪转变为执行。</li><li>执行状态→终止状态   执行状态的进程执行完毕，或出现诸如访问地址越界、非法指令等错误，而被异常结束，则进程从执行状态转换为终止状态。</li><li>执行状态→就绪状态    分时系统中，时间片用完，或优先级高的进程到来，将中断较低优先级进程的执行。进程从执行状态转变为就绪状态，等待下一次调度。</li><li>执行状态→阻塞状态   执行进程需要等待某事件发生。通常，会因为进程需要的系统调用不能立即完成，如读文件、共享虚拟内存、等待I/0操作、等待另一进程与之通信等事件而阻塞。</li><li>阻塞状态→就绪状态   当阻塞进程等待的事件发生，就转换为就绪状态。进入就绪队列排队,等待被调度执行。</li></ol><p><strong>注:</strong></p><ul><li><p>某些系统允许父进程在任何情况下终止其子进程。</p></li><li><p>如果一个父进程被终止，其子孙进程都必须终止。<br> 新状态→终止</p><pre><code>      就绪状态→终止      阻塞状态→终止</code></pre></li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210911114402709.png" alt="image-20210911114402709"></p><h4 id="问题-多个进程竞争内存资源"><a href="#问题-多个进程竞争内存资源" class="headerlink" title="问题:多个进程竞争内存资源"></a>问题:多个进程竞争内存资源</h4><ul><li>内存资源紧张</li><li>无就绪进程,处理机空闲:I/0的速度比处理机的速度慢得多，可能出现全部进程阻塞等待I/0</li></ul><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ul><li>采用交换技术:换出一部分进程到外存,以腾出内存空间</li><li>采用虚拟存储技术:每个进程只能装入一部分程序和数据(存储管理部分)</li></ul><h4 id="对换技术-交换技术-Swapping"><a href="#对换技术-交换技术-Swapping" class="headerlink" title="对换技术,交换技术(Swapping )"></a>对换技术,交换技术(Swapping )</h4><p>将内存中暂时不能运行的进程，或暂时不用的<strong>数据和程序</strong>，<strong>换出</strong>到外存，以腾出足够的内存空间，把已具备运行条件的进程，或进程所需要的数据和程序，<strong>换入</strong>内存。</p><p>PCB不能换出去。(因为PCB是系统唯一感知进程的标志)</p><h4 id="进程的挂起状态"><a href="#进程的挂起状态" class="headerlink" title="进程的挂起状态"></a>进程的挂起状态</h4><ul><li>进程被交换到外存，状态变为挂起状态</li></ul><h4 id="进程挂起的原因"><a href="#进程挂起的原因" class="headerlink" title="进程挂起的原因"></a>进程挂起的原因</h4><ul><li>进程全部阻塞，处理机空闲。</li><li>系统负荷过重，内存空间紧张。</li><li>操作系统的需要。操作系统可能需要挂起后台进程或一些服务进程（如打印进程)，或者某些可能导致系统故障的进程。</li><li>终端用户的请求。</li><li>父进程的需求。</li></ul><h4 id="被挂起进程的特征"><a href="#被挂起进程的特征" class="headerlink" title="被挂起进程的特征"></a>被挂起进程的特征</h4><ul><li>不能立即执行</li><li>可能是等待某事件发生,若是，则阻塞条件独立于挂起条件，即使阻塞事件发生，该进程也不能执行。阻塞和挂起没有联系。</li><li>使之挂起的进程为:自身、其父进程、0S</li><li>只有挂起它的进程才能使之由挂起状态转换<br>为其他状态</li></ul><h4 id="挂起与阻塞"><a href="#挂起与阻塞" class="headerlink" title="挂起与阻塞"></a>挂起与阻塞</h4><p><strong>问题</strong></p><ol><li>是否只能挂起阻塞进程?</li><li>如何激活一个挂起进程?</li></ol><ul><li>区分两个概念;<br> 进程是否等待事件，阻塞与否<br> 进程是否被换出内存，挂起与否 </li><li>4种状态组合:<br><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210911120141197.png" alt="image-20210911120141197"></li></ul><p><strong>注:</strong><br>处理机可调度执行的进程有两种:</p><ul><li><strong>新创建的进程</strong></li><li><strong>或换入一个以前挂起的进程</strong><br>通常为避免增加系统负载，系统会<strong>换入一个以前挂起的进程</strong>执行。</li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210911114656533.png" alt="image-20210911114656533"></p><h4 id="具有挂起状态的进程状态转换"><a href="#具有挂起状态的进程状态转换" class="headerlink" title="具有挂起状态的进程状态转换"></a>具有挂起状态的进程状态转换</h4><ul><li><strong>阻塞→阻塞/挂起</strong> :OS通常将阻塞进程换出，以腾出内存空间</li><li><strong>阻塞/挂起→就绪/挂起</strong>:当<strong>阻塞/挂起</strong>进程等待的事件发生时，可以将其转换为<strong>就绪/挂起</strong></li><li><strong>就绪/挂起→就绪</strong>:OS需要调入一个进程执行</li><li><strong>就绪→就绪/挂起</strong>:一般，OS挂起阻塞进程。但有时也会挂起就绪进程，释放足够的内存空间</li><li><strong>新→就绪/挂起（新→就绪）</strong>:新进程创建后，可以插入到就绪队列或就绪，挂起队列。若无足够的内存分配给新进程，则需要<strong>新→就绪/挂起</strong></li><li><strong>阻塞/挂起→阻塞</strong>:当阻塞/挂起队列中有一个进程的阻塞事件可能会很快发生，则可将一个阻塞/挂起进程换入内存，变为阻塞</li><li><strong>执行→就绪/挂起</strong>:当执行进程的时闻片用完<br>时，会转换为<strong>就绪</strong>。或一个高优先级的阻塞/挂起进程正好变为非阻塞状态，0S可以将执行进程转换为<strong>就绪/挂起</strong>状态</li><li><strong>所有状态→终止</strong>:通常,<strong>执行→终止</strong>。,但某些OS中,父进程可以终止其子进程，使在何状态的进程都可转换为退出状态</li></ul><h3 id="2-3进程的控制"><a href="#2-3进程的控制" class="headerlink" title="2.3进程的控制"></a>2.3进程的控制</h3><h4 id="两种执行模式"><a href="#两种执行模式" class="headerlink" title="两种执行模式"></a>两种执行模式</h4><ul><li>系统模式(又称为系统态）、控制模式或内核模式:<pre><code>-具有较高的特权     -运行系统特定的指令,包括读/写控制寄存器的指令、基本I/0指令以及与存储器管理有关的指令，及一些特定的内存区     -内核模式下的处理机及其指令、寄存器和内存都受到完全控制和保护</code></pre></li><li>用户模式(或用户态)<pre><code>-具有较低的特权–用户程序一般运行在用户模式</code></pre></li></ul><h4 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h4><ul><li><p>用户模式→系统模式:用户程序执行到一条系统调用，进入操作系统内核执行</p></li><li><p>系统模式→用户模式:执行完系统调用的功能，返回到用户程序</p></li><li><p>特殊情况:程序执行到结束语句时，切换到系统模式，不再返回到用户程序</p></li></ul><h4 id="操作系统内核（Kernel"><a href="#操作系统内核（Kernel" class="headerlink" title="操作系统内核（Kernel)"></a>操作系统内核（Kernel)</h4><ul><li>操作系统的核心，是基于硬件的第一层软件扩充，提供操作系统最基本的功能，是操作系统工作的基础。</li><li>现代操作系统设计中，为减少系统本身的开销，往往将一些与硬件紧密相关的（如中断处理程序、设备驱动程序等)、基本的、公共的、运行频率较高的模块（如时钟管理、进程调度等)以及关键性数据结构独立开来，使之常驻内存，并对它们进行特殊保护。通常把这一部分称为操作系统的内核。</li><li>用户通过系统调用访问操作系统的功能，这些功能最终都通过操作系统内核实现。</li><li>一般地，操作系统内核的功能可以概括地划分为资源管理功能和支撑功能。<pre><code>–资源管理:进程管理、存储管理和I/0设备管理–支撑功能:中断处理、统计、监测、时钟管理、原语操作等。</code></pre></li></ul><h5 id="资源管理功能"><a href="#资源管理功能" class="headerlink" title="资源管理功能"></a>资源管理功能</h5><ul><li>进程管理:进程创建和终止、调度、状态转换、同步和通信、管理PCB</li><li>存储管理:为进程分配地址空间、对换、段/页管理</li><li>I/0设备管理:缓存管理、为进程分配I/0通道和设备</li></ul><h5 id="支撑功能"><a href="#支撑功能" class="headerlink" title="支撑功能"></a>支撑功能</h5><ul><li>中断处理</li><li>时钟管理</li><li>原语( Primitive ) :原子操作</li><li>统计</li><li>监测</li></ul><h6 id="进程控制原语"><a href="#进程控制原语" class="headerlink" title="进程控制原语"></a>进程控制原语</h6><ul><li>进程切换</li><li>创建与终止</li><li>阻塞与唤醒</li><li>挂起与激活</li></ul><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><ul><li>提交新的批处理作业</li><li>交互式用户注册</li><li>操作系统提供服务</li><li>父进程创建子进程</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>为进程分配一个唯一标识号D主进程表中增加一个新的表项</li><li>为进程分配空间:用户地址空间、用户栈空<br>间、PCB空间。若共享已有空间，则应建立相应的链接</li><li>初始化PCB:进程标识、处理机状态信息、进程状态</li><li>建立链接:若调度队列是链表,则将新进程插入到就绪或就绪/挂起链表</li><li>建立或扩展其他数据结构</li></ul><h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><h5 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h5><ul><li>批处理作业执行到“结束”语句</li><li>交互式用户“注销”</li><li>停止进程（应用程序）的执行</li><li>遇到错误或故障</li></ul><h5 id="具体原因"><a href="#具体原因" class="headerlink" title="具体原因"></a>具体原因</h5><ul><li>正常结束</li><li>超时终止,执行时间超过预计时间</li><li>内存不足,无法为进程分配所需的内存空间</li><li>越界访问</li><li>企图使用未允许用的数据，或操作方式错计算错，如除零,或企图存储硬件允许的最大数</li><li>超时等待某事件发生</li><li>I/0失败,如找不到文件或多次重试仍无法读写文件，或无效操作</li><li>无效指令,企图执行不存在的指令</li><li>特权指令,企图执行特权指令</li><li>数据类型不符，或未初始化</li><li>操作员或OS干预，如发生死锁的时候</li><li>父进程终止</li><li>父讲程清求</li></ul><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><ul><li>根据被终止进程的标识符ID，找到其PCB，读出该进程的状态;</li><li>若该进程为执行状态，则终止其执行，调度新进程执行;</li><li>若该进程有子孙进程，则立即终止其所有子孙进程将该进程的全部资源,或归还给其父进程，或归还给系统</li><li>将被终止进程(的PCB)从所在的队列中移出，等待其它程序来搜集信息</li></ul><h4 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h4><ul><li>阻塞原因:请求系统服务:启动某种操作，<br>如IO;新数据尚未到达;暂时无新工作可做等</li><li>当出现阻塞事件,进程调用阻塞原语将自己阻塞。并将其状态变为“阻塞状态”,并进入相应事件的阻塞队列;</li><li>当阻塞进程期待的事件发生,有关进程调用<br>唤醒原语，将等待该事件的进程唤醒。并将其状态变为“就绪状态”，插入就绪队列。</li><li>一般,进程可以自己阻塞自己;而唤醒操作则由操作系统，或其它相关进程来完成,进程无法自己唤醒自己。</li></ul><h4 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h4><ul><li>当出现挂起事件，系统利用挂起原语将指定进程或一个阻塞进程挂起。进程从内存换出到外存，其状态转换:就绪→就绪/挂起或阻塞→阻塞/挂起</li><li>当激活事件发生,系统利用激活原语将指定进程激活。将相应进程从外存换入到内存，可能的状态转换:就绪/挂起→就绪，或阻塞/挂起→阻塞</li></ul><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><ul><li>时钟中断<pre><code>-进程执行完一个时间片</code></pre></li><li>I/0中断<br>内存访问出错<pre><code>-虚拟存储中，需要的指令或数据不在内存</code></pre></li><li>陷阱<pre><code>-执行遇到错误-可能使进程转换到终止状态</code></pre></li></ul><h4 id="进程A切换到进程B的步骤"><a href="#进程A切换到进程B的步骤" class="headerlink" title="进程A切换到进程B的步骤"></a>进程A切换到进程B的步骤</h4><ul><li>首先,保护进程A的现场将进程A的当前运行信息，如程序执行到的当前位置，程序状态字，所有的寄存器值等保存到进程A的PCB中。</li><li>然后，恢复进程B的现场从进程B的PCB中获取其执行信息，将这些信息写入相应的寄存器中，程序计数器指向进程B将执行的下一条指令。进程B可能第一次开始执行，也可能是被中断过的进程,恢复执行。不论是哪一种情况，进程B的执行信息都能在其PCB中找到。</li></ul><h4 id="进程切换vs模式切换"><a href="#进程切换vs模式切换" class="headerlink" title="进程切换vs模式切换"></a>进程切换vs模式切换</h4><ul><li>进程切换,作用于进程之间的一种操作。当分派程序收回当前进程的CPU并准备把它分派给某个就绪进程时，该操作将被引用。</li><li>模式切换,是进程内部所引用的一种操作。当用户程序转入系统调用，或相反时，该操作将被引用。</li><li>进程切换一定引发模式切换，反之则不然。</li></ul><h3 id="2-4-进程调度"><a href="#2-4-进程调度" class="headerlink" title="2.4 进程调度"></a>2.4 进程调度</h3><h4 id="什么是调度"><a href="#什么是调度" class="headerlink" title="什么是调度?"></a>什么是调度?</h4><p>调度是指，在一个队列中，按照某种方法（算法），选择一个合适的个体的过程。<br>调度的关键是需要某种方法或算法，好的调度算法有利于选择到合适的个体。如何判断、设计一个好的调度算法呢?</p><h4 id="调度目标"><a href="#调度目标" class="headerlink" title="调度目标"></a>调度目标</h4><ul><li>公平性，防止进程长期不能获得调度而饥饿;</li><li>处理机利用率,尽量提高处理机的利用率;</li><li>提高系统吞吐量;</li><li>尽量减少进程的响应时间</li></ul><h4 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h4><ul><li>满足用户的要求:响应时间、周转时间、截止时间</li><li>满足系统的需求:系统吞吐量、处理机利用率、各类资源的平衡使用、公平性及优先级</li></ul><h5 id="面向用户的原则-响应时间"><a href="#面向用户的原则-响应时间" class="headerlink" title="面向用户的原则:响应时间"></a>面向用户的原则:响应时间</h5><ul><li>是指,从用户通过键盘提交一个请求开始，直到系统首次产生响应为止的时间。</li><li>输入的请求传送到处理机的时间＋处理机对请求信息进行处理的时间+将响应结果发送到输出终端的时间</li><li>调度算法则应考虑尽可能使绝大多数用户的请求能在响应时间内完成。</li><li>常用于评价分时系统的性能。</li></ul><h5 id="面向用户的原则-周转时间"><a href="#面向用户的原则-周转时间" class="headerlink" title="面向用户的原则:周转时间"></a>面向用户的原则:周转时间</h5><ul><li><p>指从作业提交给系统开始，到作业完成为止的这段时间间隔<br>作业在外存排队等待调度的时间+进程在就绪队列中等待调度的时间+进程被处理机执行的时间<br>+等待I/0操作完成的时间</p></li><li><p>常用于评价批处理系统的性能</p></li><li><p>影响周转时间的调度:</p><pre><code>作业从外存调度到内存（作业调度)进入内存还需在就绪队列中排队，等待进程调度。甚至，可能会挂起进程，在外存等待被激活（中程调度)</code></pre></li></ul><h5 id="面向用户的原则-截止时间"><a href="#面向用户的原则-截止时间" class="headerlink" title="面向用户的原则:截止时间"></a>面向用户的原则:截止时间</h5><ul><li>指实时系统中，某任务必须开始执行的最迟时间(开始截止时间)，或必须完成的最迟时间（完成截止时间)。</li><li>常用于评价实时系统的性能。</li></ul><h5 id="面向系统的原则-系统吞吐量"><a href="#面向系统的原则-系统吞吐量" class="headerlink" title="面向系统的原则:系统吞吐量"></a>面向系统的原则:系统吞吐量</h5><ul><li>指单位时间内系统所完成的作业数</li><li>常用于评价批处理系统的性能。</li></ul><h5 id="面向系统的原则-处理机利用率"><a href="#面向系统的原则-处理机利用率" class="headerlink" title="面向系统的原则:处理机利用率"></a>面向系统的原则:处理机利用率</h5><ul><li>大、中型多用户系统，由于处理机价格昂贵，处理机利用率是衡量系统性能的一个重要指标</li><li>单用户微机或某些实时系统，则并非很重要。</li></ul><h5 id="面向系统的原则-各类资源的平衡使用"><a href="#面向系统的原则-各类资源的平衡使用" class="headerlink" title="面向系统的原则:各类资源的平衡使用"></a>面向系统的原则:各类资源的平衡使用</h5><ul><li>多道程序系统的目标之一就是为了提高系统资源的利用率，因此，调度算法有责任使系统中的各种资源都尽量处于忙碌状态。</li><li>该原则同时适用于长程调度和中程调度,因为它们可以决定哪些筰业(进程）可以进入内存，可以考虑系统资源的均衡使用。（不适合进程调度因为它已经得到了相应的资源只差处理机了，因此不考虑资源的使用)</li></ul><h5 id="面向系统的原则-公平性"><a href="#面向系统的原则-公平性" class="headerlink" title="面向系统的原则:公平性"></a>面向系统的原则:公平性</h5><ul><li>调度算法应该对所有进程公平，不偏袒任何进程。</li></ul><h5 id="面向系统的原则-优先权"><a href="#面向系统的原则-优先权" class="headerlink" title="面向系统的原则:优先权"></a>面向系统的原则:优先权</h5><ul><li>优先权高的进程应优先调度</li><li>可以根据进程的优先权不同，组织不同的就绪队列。进程调度时首先选择高优先权队列中的进程，直到该队列空，再调度较低优先权队列中的进程，如图2.13所示</li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210913231544429.png" alt="image-20210913231544429"></p><ul><li> 几乎所有操作系统的调度算法都可考虑优先权原则。</li><li> 当然,仅考虑优先权，可能会出现饥饿，对低优先权的进程不公平。</li><li> 可以将进程排队的等待时间等因素纳入优先权的计算，随着进程等待时间的增长，其优先权也不断提高,进程也会在不久的将来得到调度。</li></ul><h4 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h4><p>根据执行进程的处理机是由进程自己释放，还是被强行剥夺，可以将进程调度方式分为<strong>非剥夺方式</strong>和剥夺方式两种。</p><h5 id="进程调度方式-非剥夺方式"><a href="#进程调度方式-非剥夺方式" class="headerlink" title="进程调度方式:非剥夺方式"></a>进程调度方式:非剥夺方式</h5><ul><li>执行进程只有在执行完毕，或因申请I/O阻塞自己时，才中断其执行，释放处理机，调度新的进程执行</li><li>这种方式不利于“即时性”要求较高的分时和实时系统，主要用于批处理系统。</li></ul><h5 id="进程调度方式-剥夺方式"><a href="#进程调度方式-剥夺方式" class="headerlink" title="进程调度方式:剥夺方式"></a>进程调度方式:剥夺方式</h5><ul><li>操作系统可以在新进程到来时，或某个具有较高优先权的被阻塞进程插入就绪队列时，或在基于时间片调度的系统中，时间片用完而中断当前进程的执行，调度新的进程执行。</li><li>这种方式会产生较多的中断，主要用于实时性要求较高的实时系统及性能要求较高的批处理系统和分时系统。</li></ul><h4 id="调度的类型"><a href="#调度的类型" class="headerlink" title="调度的类型"></a>调度的类型</h4><ul><li>批处理调度、分时调度、实时调度和多处理机调度</li><li>长程调度(作业调度要创建新进程)、中程调度（(挂起，激活不用创建新进程）、短程调度（进程调度)<br>I/0调度</li></ul><h5 id="长程调度-Long-term-scheduling）"><a href="#长程调度-Long-term-scheduling）" class="headerlink" title="长程调度(Long-term scheduling）"></a>长程调度(Long-term scheduling）</h5><ul><li>又称高级调度,或作业调度，它为被调度作业或用户程序创建进程，分配必要的系统资源，并将新创建的进程插入就绪队列，等待短程调度。</li><li>某些采用交换技术的系统将新创建的进程插入到就绪/挂起队列，等待中程调度。</li><li>在批处理系统中，作业进入系统后，先驻留在磁盘上，组织成批处理队列，称为后备队列。长程调度从该队列中选择一个或多个作业，为之创建进程。如图:</li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210913231827192.png" alt="image-20210913231827192"></p><h6 id="长程调度需要考虑两个问题"><a href="#长程调度需要考虑两个问题" class="headerlink" title="长程调度需要考虑两个问题"></a>长程调度需要考虑两个问题</h6><ol><li>选择多少个作业进入内存，为之创建进程?<br>取决于多道程序的度，即允许同时在内存中运行的进程数。</li><li>选择哪些作业?<br>取决于长程调度算法</li></ol><h5 id="短程调度-Short-term-scheduling"><a href="#短程调度-Short-term-scheduling" class="headerlink" title="短程调度(Short-term scheduling)"></a>短程调度(Short-term scheduling)</h5><ul><li>也称进程调度，或低级调度，决定就绪队列中的哪个进程将获得处理机。</li><li>短程调度运行频率最高。</li><li>现代操作系统几乎都具有短程调度功能。</li></ul><h5 id="中程调度-Medium-term-scheduling）"><a href="#中程调度-Medium-term-scheduling）" class="headerlink" title="中程调度(Medium-term scheduling）"></a>中程调度(Medium-term scheduling）</h5><ul><li>又称为中级调度。它是对换功能的一部分。</li><li>当内存空间非常紧张时，或处理机找不到一不司执行的就绪进程时，需要选择一个进程（阻塞或就绪状态)换出到外存，释放出内存空间给别的进程使用;当内存空间较充裕时，从外存选择一个挂起状态的进程调度到内存（换入），见图。</li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210913231925800.png" alt="image-20210913231925800"></p><ul><li>目的:为了提高内存的利用率和系统吞吐量。</li><li>只有支持进程挂起的操作系统才具有中程调度功能。</li></ul><h4 id="进程调度算法-先来先服务（FCFS"><a href="#进程调度算法-先来先服务（FCFS" class="headerlink" title="进程调度算法-先来先服务（FCFS)"></a>进程调度算法-先来先服务（FCFS)</h4><ul><li>该方法按照进程到达的先后顺序排队,每次调度队首的进程。</li><li>FCFS算法属于非剥夺调度方式，实现简单，看似公平。</li><li>但，对于那些后进入队列而运行时间较短的进程，或I/0型的进程而言，可能需要长时间等待。</li></ul><p><strong>分析前面列举的幼儿园一组小孩进食的例子:</strong></p><ul><li>如果采用FCFS方法,让全部小孩排成一个先进先出的队列，老师从队首开始逐个给小孩喂食，只有当前一个小孩吃饱了，才喂食下一个小孩。那么，排在队列后面的的小孩将长时间不能被喂食而饥饿。</li><li>特别地，如果排在队列前面的某些小孩需要喂食的时间较长，而排在队列后面的某些小孩只需进食很少的饭量，却需要等待很长的时间。故，该方法对这样的小孩不公平。</li></ul><p><strong>假设</strong><br>就绪队列中从队首开始依次排列有四个进程P1，P2，P3和P4（假设它们同时到达就绪队列），它们的预计执行时间分别为16，12，4和3个单位时间。若采用FCFS方法调度，试计算P1，P2，P3和P4的周转时间分别为多少?平均周转时间是多少?</p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210913232037792.png" alt="image-20210913232037792"></p><ul><li>对短进程不公平。</li><li>由于长进程可能排在队列前面,必将增加队列后部进程的等待时间，从而将增加平均周转时间。</li><li>不利于I/0型进程，未有效利用系统资源。</li><li>一般地,FCFS与其他调度算法混合使用。例如，系统可以按照不同的优宪级维护多个就绪队列，每个队列内部按照FCFS算法调度。 </li><li>FCFS算法同时适合于长程、中程和短程调度三种调度类型。</li></ul><h4 id="短进程优先"><a href="#短进程优先" class="headerlink" title="短进程优先"></a>短进程优先</h4><pre><code>当需要调度进程(或作业）时，通过计算判断就绪进程队列中哪一个进程的预期执行时间最短，或后备作业队列中哪一个或几个作业的预期执行时间最短，就调度谁。</code></pre><p><strong>属于非剥夺调度算法。</strong>当某进程获得处理机，直到其执行完成，或需要等待某事件而阻塞时，才自动释放处理机。系统又调度新的进程（或作业)。<br>若采用短进程优先算法调度上例的4个进程，按照进程预期执行时间排序（升序)为P4，P3，P2，P1，试分别计算4个进程的周转时间和他们的平均周转时间。</p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210913232156039.png" alt="image-20210913232156039"></p><ul><li>与FCFS算法比较,短进程优先调度算法改善了系统的性能，降低了系统的平均等待时间，提高了系统的吞吐量。但是，该算法也存在一些问题:</li></ul><p>1)很难准确预测进程的执行时间;<br>⑵可能导致长进程饥饿，这对长进程不公平;3)采用非剥夺调度方式，未考虑进程的紧迫程度，不适合于分时系统和事务处理系统。</p><h4 id="时间片轮转调度法"><a href="#时间片轮转调度法" class="headerlink" title="时间片轮转调度法"></a>时间片轮转调度法</h4><p>例如<br>在一个分时联机系统中，同时有n个人通过各自的终端共享一台主机（服务器）。终端完成输入/输出操作，主机负责处理从终端发来的请求，为之建立进程、协调各进程的运行、调度各个进程等，并尽量满足每个终端用户对响应时间的要求。</p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210911115401323.png" alt="image-20210911115401323"></p><ul><li>在分时联机系统中,n个进程循环地获得时间片而执行。从系统中来看它们是交替执行的，但就每个终端用户而言，都感觉到自己独占了一台主机,不受其他用户的影响。这是通过进程并发执行实现的。</li><li>如果用户数太多，主机处理的进程将会急剧增加，进程排队等待的时间也会很长，进程的响应时间也可能增长，用户将明显感觉到主机的速度变慢而不满意。</li><li>另外，时间片的大小也会影响进程的响应时间。</li></ul><h5 id="时间片的设置"><a href="#时间片的设置" class="headerlink" title="时间片的设置"></a><strong>时间片的设置</strong></h5><ul><li>进程切换将会增加系统的额外开销。</li><li>时间片设定得太短，进程切换会非常频繁，从而降低处理机的效率;时间片设定得太长，将无法满足交互式用户对响应时间的要求。进程切换将会增加系统的额外开销时间片设定得太短，进程切换会非常频繁，从而降低处理机的效率；时间片设定得太长，将无法满足交互式用户对响应时间的要求</li><li>因此,时间片大小的确定应综合考虑系统的最大用户数、响应时间、系统效率等多种因素。</li></ul><p>采用基于时间片轮转调度算法调度上例的4个进程，并分别按照两种时间片犬小轮转调度(1个单位时间和4个单位时间)，分析该算法的性能。<br>首先按照进程到达的先后顺序组织就绪队列，即P1,P2,P3,P4。从队首开始调度，首先调度P1，执行一个时间片，强行中断P1，P1回到就绪队列队尾排队;切换到P2，执行一个时间片，强行中断P2，P2回到就绪队列队尾排队(排在P1之后）…</p><ul><li><p>为了简单，图中忽略了进程切换时的系统开销，而实际操作系统中，这类额外开销是客观存在的。</p></li><li><p>可见,采用基于时间片轮转调度法,进程的周转时间和平均周转时间并不比采用FCFS和短进程优先调度算法小。</p></li><li><p>加上进程切换所需的系统开销时间，该算法的平均周转时间还会增长。</p></li><li><p>常用于分时系统及事务处理系统,合理的时间片大小将带来满意的响应时间。</p></li><li><p>通常,合理的时间片指，能让80%左右的进程在一个时间片内完成。<br>对于短的、计算型的进程较有利。不适合于批处理系统的进程调度不利于I/0型的进程。改进的方法之一，可以将I/O阻塞事件完成的进程单独组织一个就绪队列，该队列进程的时间片可以设置的小一些，且优先调度。</p></li></ul><h4 id="基于优先级的调度算法"><a href="#基于优先级的调度算法" class="headerlink" title="基于优先级的调度算法"></a>基于优先级的调度算法</h4><ul><li>基于时间片轮转调度法循环式地为每个被调度的进程分配一个时间片，对每个进程都是公平的。</li><li>然而，实际应用中，进程的性质可能是不同的。例如，一个与用户进行交互的前台进程急迫地需要对用户的输入作出响应，而一个后台打印进程的迫切性也许就不那么重要。</li><li>因此，可以为每个进程定义一个优先级,优先级越高的进程将优先获得处理机的调度。</li></ul><h4 id="如何设定进程的优先级呢"><a href="#如何设定进程的优先级呢" class="headerlink" title="如何设定进程的优先级呢?"></a>如何设定进程的优先级呢?</h4><ul><li>进程完成功能的重要性(用户与系统)</li><li>进程完成功能的急迫性(前台比后台急迫)</li><li>为均衡系统资源的使用,指定进程（作业）优先级</li><li>进程对资源的占用程度例如，可以为短进程(或作业）赋予较高的优先级。</li></ul><h5 id="静态与动态优先级"><a href="#静态与动态优先级" class="headerlink" title="静态与动态优先级"></a>静态与动态优先级</h5><ul><li>静态优先级:一旦确定,则进程运行期间优先级一直不改变。</li><li>动态优先级:系统首先赋予进程一个初始优先级，该优先级将随着进程的运行而改变。</li></ul><h5 id="动态优先级"><a href="#动态优先级" class="headerlink" title="动态优先级"></a>动态优先级</h5><ul><li>典型的动态优先级变化方式为:<pre><code>—优先级随着进程运行的剩余时间的减少而上升，使将要执行结束的进程尽快完成;—或随着进程排队等待时间的增长而上升，使等待时间越长的进程优先得到调度，不至于长时间饥饿。</code></pre></li><li>具体实现方法,可以在每个时钟中断时,或需要进程切换时，重新计算就绪队列中各进程的优先级，并优先调度高优先级的进程。</li><li>采用动态优先级的两种调度算法:剩余时间取短者优先和响应比高者优先。</li></ul><h5 id="剩余时间最短者优先"><a href="#剩余时间最短者优先" class="headerlink" title="剩余时间最短者优先"></a>剩余时间最短者优先</h5><ul><li><p>为了使将要结束的进程尽早结束，释放系统资源，让别的进程执行。可以在每个时钟中断时，根据就绪队列中各进的剩余执行时间动态调整其优先级，剩余时间最短的进程优先级最高。</p></li><li><p>显然，该算法是剥夺型的短进程优先调度算法，调度程序总是选择剩余执行时间最短的进程调度执行。</p></li><li><p>与短进程优先调度算法一样,,该调度算法很难准确估讦进程的剩余执行时间。</p></li><li><p>由于长进程在未执行时，或刚开始执行的一段时间内，其剩余执行时间都不会最短，所以该算法对长进程不公平。</p></li><li><p>但是,它不象FCFS算法偏袒长进程,也不象轮转调度算法会产生很多中断而增加系统负担。</p></li><li><p>由于短进程提前完成,故采用剩余时间最短者优先的调度算法获得的平均周转时间比采用短进程优先算法短。</p></li></ul><h5 id="响应比高者优先"><a href="#响应比高者优先" class="headerlink" title="响应比高者优先"></a>响应比高者优先</h5><pre><code>将进程的等待时间和进程的预期执行时间纳入优先级的计算，进程（预期执行时间)越长优先级越低，而随着进程的等待时间增长优先级上升，即进程的优先级与等待时间成正比，与进程执行时间成反比。令w表示等待时间，s表示预期执行时间，则响应比:</code></pre><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210911115554925.png" alt="image-20210911115554925"></p><ul><li>调度方法:若当前执行进程执行完毕，或需要阻塞等待某事件而释放处理机，调度程序选择就绪队列中响应比最大的进程执行。</li><li>若等待时间相同，短进程因为s较小，R较大而优先调度。</li><li>若进程的预期执行时间相同，则等待时间长的进程优先调度，相当于FCFS随着等待时间的增加,长进程的响应比不断增大，在某个时刻，也必然被调度。</li></ul><p>同短进程优先和剩余时间最短者优先调度算法一样，很难准确估计进程的预期执行时间。<br>每次调度之前都需要计算响应比，增加了系统开销。</p><h4 id="反馈调度法"><a href="#反馈调度法" class="headerlink" title="反馈调度法"></a>反馈调度法</h4><ul><li>前面介绍的几种调度算法都存在各自不同的问题，尤其是短进程优先、剩余时间最短者优先以及响应比高者优先调度算法都需要估计进程的预期执行时间，如果估计不准确，将影响调度结果和系统性能。</li><li>如果根据进程执行历史，而非未来，进行调度，将解决这个问题。</li><li>反馈调度法就是一种根据进程执行历史调整调度方式的调度方法，它结合了优先级和时间片轮转调度思想。</li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210915224047007.png" alt="image-20210915224047007"></p><ul><li>该方法有利于交互型短进程或短批处理作业，因为它们一般只需要一个或很少的几个时间片即可完成，</li><li>但可能使长进程的周转时间急剧增加。</li><li>如果不断地有新进程到来，还可能出现长进程长期饥饿现象。</li><li>为此,可以为各队列设置不同的时间片,优先级愈低时间片愈长。</li></ul><h4 id="进程调度算法小结"><a href="#进程调度算法小结" class="headerlink" title="进程调度算法小结"></a>进程调度算法小结</h4><ul><li>如何选择进程调度算法与系统设计的目标有关。交互式多任务系统，主要考虑联机用户对响应时间的要求，一般采用基于时间片轮转调度算法，同时，根据进程的性质设置不同的优先级;</li><li>批处理系统往往以作业的平均周转时间来衡量调度性能，常选用基于优先级的短进程(或作业)优先调度算法。</li></ul><h4 id="实时系统-Real-Time-System"><a href="#实时系统-Real-Time-System" class="headerlink" title="实时系统(Real-Time System)"></a>实时系统(Real-Time System)</h4><ul><li>指，能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行的计算机系统</li><li>分为实时控制系统和实时信息处理系统</li></ul><h5 id="实时系统-实时控制系统"><a href="#实时系统-实时控制系统" class="headerlink" title="实时系统-实时控制系统"></a>实时系统-实时控制系统</h5><ul><li><p>指要求进行实时控制的系统。</p></li><li><p>主要用于生产过程的控制，实时采集现场数据，并对所采集的数据进行及时处理，进而自动地控制相应的执行机构，使某些(个)参数(如温度、压力、方位等)能按预定的规律变化，以保证产品的质量和提高产量。</p></li><li><p>也可用于武器的控制，如火炮的自动控制系统，飞机的自动驾驶系统，以及导弹的制导系统等。</p></li></ul><h5 id="实时系统-实时信息处理系统"><a href="#实时系统-实时信息处理系统" class="headerlink" title="实时系统-实时信息处理系统"></a>实时系统-实时信息处理系统</h5><ul><li><p>指能对信息进行实时处理的系统。</p></li><li><p>该系统由一台或多台主机通过通信线路连接成百上千个远程终端，计算机接收从远程终端发来的服务请求，根据用户提出的问题，对信息进行检索和处理，并在很短的时间内为用户做出正确的回答。</p></li><li><p>典型的实时信息处理系统有:飞机订票系统、情报检索系统等。</p></li></ul><h5 id="实时任务-real-time-task"><a href="#实时任务-real-time-task" class="headerlink" title="实时任务(real-time task)"></a>实时任务(real-time task)</h5><ul><li>指，具有及时性要求的、常常被重复执行的特定进程，在实时系统中习惯称为任务。</li></ul><ul><li><p>按任务执行时是否呈现周期性来分类:</p><pre><code>(1)周期性实时任务，要求按指定的周期循环执行，以便周期性地控制某个外部事件。(2)非周期性实时任务，任务的执行无明显的周期性，但都必须联系着一个截止时间(deadline)</code></pre></li><li><p>截止时间包括:开始截止时间(任务在某时间以前,必须开始执行)和完成截止时间（任务在某时间以前必须完成)</p></li></ul><ul><li>根据对截止时间的要求将实时任务划分为:<pre><code>(1)硬实时任务，系统必须满足任务对截止时间的要求，否则可能出现难以预测的结果。(2）软实时任务它也联系着一个截止时间，但并不严格,若错过了任务的截止时间，对系统产生的影响不会太大。</code></pre></li></ul><h5 id="实时调度的目标"><a href="#实时调度的目标" class="headerlink" title="实时调度的目标"></a>实时调度的目标</h5><ul><li>主要考虑如何使硬实时任务在其规定的截止时间内完成，同时，尽可能使软实时任务也能在规定的截止时间内完成。</li><li>而公平性和最短平均响应时间等要求已不再重要。</li><li>但是，大多数现代实时操作系统无法直接处理任务的截止时间，它们只能尽量提高响应速度，以尽快地调度任务。</li></ul><h5 id="实时调度算法"><a href="#实时调度算法" class="headerlink" title="实时调度算法"></a>实时调度算法</h5><p>实时性要求不太高的实时系统可用的调度算法:</p><ul><li>基于时间片轮转调度算法。</li><li>基于优先级的调度算法</li><li>最早截止时间优先调度算法，即优先调度截止时间最近的实时任务。</li></ul><h6 id="速度单调调度算法-Rate-Monotonic-Scheduling，RMS"><a href="#速度单调调度算法-Rate-Monotonic-Scheduling，RMS" class="headerlink" title="速度单调调度算法(Rate Monotonic Scheduling，RMS)"></a>速度单调调度算法(Rate Monotonic Scheduling，RMS)</h6><ul><li>根据任务的周期大小赋予优先级，最短周期的任务具有最高优先级。其中，<br>-任务周期( period)，指一个任务到达至下一任务到达之间的时间范围。<br>-任务速度（rate），即周期（以秒计）的倒数,以赫兹为单位。</li><li>任务周期的结束，表示任务的硬截止时间。任务的执行时间不应超过任务周期。</li><li>在RMS调度算法中，如果以任务速度为参数，则优先级函数是一个单调递增的函数，故称为速度单调算法。</li><li>该调度算法广泛用于工业实时系统的周期性任务调度。</li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20210915224911628.png" alt="image-20210915224911628"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第二章-进程管理-2-1-2-4&quot;&gt;&lt;a href=&quot;#第二章-进程管理-2-1-2-4&quot; class=&quot;headerlink&quot; title=&quot;第二章 进程管理 2.1-2.4&quot;&gt;&lt;/a&gt;第二章 进程管理 2.1-2.4&lt;/h2&gt;&lt;h3 id=&quot;本章要点&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="操作系统原理" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="操作系统原理" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    <category term="总结" scheme="http://example.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>操作系统原理 第一章总结</title>
    <link href="http://example.com/2021/09/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://example.com/2021/09/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2021-09-07T09:56:04.000Z</published>
    <updated>2021-09-07T15:21:31.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h1><h2 id="第1章-操作系统概述"><a href="#第1章-操作系统概述" class="headerlink" title="第1章 操作系统概述"></a>第1章 操作系统概述</h2><h3 id="1-1计算机系统资源"><a href="#1-1计算机系统资源" class="headerlink" title="1.1计算机系统资源"></a>1.1计算机系统资源</h3><h4 id="计算机系统资源分类"><a href="#计算机系统资源分类" class="headerlink" title="计算机系统资源分类"></a>计算机系统资源分类</h4><ul><li>软件:系统软件（操作系统及实用程序)、应用软件</li><li>硬件:处理机（CPU)、内存（条)）、外部1/O设备/(显示器↓键盘〇鼠标、打印机、磁盘、磁带、扫描仪…)，以及系统总线</li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20210907174147742.png" alt="image-20210907174147742"></p><h4 id="操作系统的层次结构"><a href="#操作系统的层次结构" class="headerlink" title="操作系统的层次结构"></a>操作系统的层次结构</h4><p>（1）硬件处在最低层，不附加任何软件的物理计算机.</p><p>（2）操作系统是附加在裸机上的第一层，是对裸机的首次扩充，构成了一个比裸机更强，使用更方便的“虚拟计算机”。</p><p>（3）所有系统应用程序以及更上层的用户程序在操作系统虚拟机上运行，它们受操作系统的统一管理和控制，通过操作系统使用各种资源来完成特定的任务。</p><h3 id="1-2什么是操作系统"><a href="#1-2什么是操作系统" class="headerlink" title="1.2什么是操作系统"></a>1.2什么是操作系统</h3><h4 id="关于现代操作系统的四种基本观点"><a href="#关于现代操作系统的四种基本观点" class="headerlink" title="关于现代操作系统的四种基本观点"></a>关于现代操作系统的四种基本观点</h4><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20210907162533488.png" alt="image-20210907162533488"></p><h5 id="用户环境观点"><a href="#用户环境观点" class="headerlink" title="用户环境观点"></a>用户环境观点</h5><ul><li><p>该观点认为，操作系统是计算机用户使用计算机系统的接口，它为计算机用户提供了方便的工作环境。</p></li><li><p>计算机用户:终端用户、程序员和系统设计者</p></li><li><p>操作系统提供的接口</p></li><li><p>用户接口(User Interface,”也称为命令接口)<strong><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20210907164352692.png" alt="image-20210907164352692">脱机:没有处理机控制</strong></p><p><strong>联机:输入登入名</strong></p></li><li><p>程序接口（系统调用，也称为应用编程接口,Application Programming Interface，简称API)</p></li></ul><h5 id="虚拟机器观点"><a href="#虚拟机器观点" class="headerlink" title="虚拟机器观点"></a>虚拟机器观点</h5><ul><li>该观点认为,操作系统是建立在计算机硬件平台上的虚拟机器,它为应用软件提供了许多比计算机硬件功能更强或计算机硬件所没有的功能。</li><li>操作系统在虚拟机中充当管理员和协调员的角色,管理计算机的软硬件资源,并协调多任务、多进程的运行。</li><li>扩充:功能、计算机数量</li></ul><h5 id="资源管理观点"><a href="#资源管理观点" class="headerlink" title="资源管理观点"></a>资源管理观点</h5><ul><li><p>该观点认为,操作系统是计算机系统中各类资源的管理者,它负责分配、回收以叛控制系统中的各种软硬件资源。</p></li><li><p>跟踪资源的使用状况、满足资源请求、提高资源利用率,以及协调各程序和用户对资源的使用冲突。</p><pre><code>-监视资源-分配/回收资源-保护资源</code></pre></li></ul><h5 id="作业组织观点"><a href="#作业组织观点" class="headerlink" title="作业组织观点"></a>作业组织观点</h5><ul><li><p>该观点认为，操作系统是计算机系统工作流程的组织者，它负贵协调在系统中运行的各个应用软件的运行次序。</p></li><li><p>用于巨型机和大型服务器上,以批文件方式提交作业，请求主机逐个运行。</p></li><li><p>主机操作系统负责组织、协调各个作业的运行，报告执行结果或错误信息。</p></li><li><p>减少了人工干预,提高了系统的效率有利于有效利用造价高且性能强大的主机资源。</p></li></ul><h5 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h5><p>操作系统是计算机系统中的一个<u>系统软件</u>,<u>管理和控制</u>计算机系统中的硬件和软件资源,合理地<u>组织</u>计算机的工作流程,以便有效利用这些资源为用户提供一个功能强、使用方便的<u>工作环境</u>,从而在计算机与用户之间起到<u>接口</u>的作用。</p><h3 id="1-3操作系统的形成与发展"><a href="#1-3操作系统的形成与发展" class="headerlink" title="1.3操作系统的形成与发展"></a>1.3操作系统的形成与发展</h3><h4 id="操作系统的简历"><a href="#操作系统的简历" class="headerlink" title="操作系统的简历"></a>操作系统的简历</h4><ul><li>50年代中期，第一个简单批处理操作系统</li><li>60年代中期，多道程序批处理系统·不久，分时系统、实时系统</li><li>80年代，微机及网络操作系统</li></ul><h4 id="什么推动着操作系统的发展"><a href="#什么推动着操作系统的发展" class="headerlink" title="什么推动着操作系统的发展"></a>什么推动着操作系统的发展</h4><ul><li>计算机硬件升级和新硬件的出现</li><li>提供新的服务，方便使用</li><li>提高计算机资源利用效率</li><li>更正软件错误</li><li>计算机体系结构的发展:单处理机系统、多处理机系统、分布式系统、计算机网络</li></ul><h4 id="手工操作时期，没有操作系统"><a href="#手工操作时期，没有操作系统" class="headerlink" title="手工操作时期，没有操作系统"></a>手工操作时期，没有操作系统</h4><ul><li>早期的电子数字计算机是由成千上万个电子管组成</li><li>操作和编程完全由手工进行,且编程只能用机器语言(二进制代码)</li><li>程序员同时也是操作员在上机期间独占整台计算机及其它相关设备,效率非常低</li></ul><h4 id="单道批处理系统-早期操作系统"><a href="#单道批处理系统-早期操作系统" class="headerlink" title="单道批处理系统,早期操作系统"></a>单道批处理系统,早期操作系统</h4><ul><li><p>程序员首先将命令、程序和数据用汇编语言或FORTRAN语言写在纸上,然后用穿孔机制成卡片,最后将这些卡片交给操作员</p></li><li><p>批处理程序(又称为监督程序，或管理程序),管理应用程序的运行。</p></li><li><details green="" open="" style="box-sizing: border-box; display: block; padding: 16px; margin: 1em 0px; border-radius: 4px; background: rgb(255, 255, 255); font-size: 14px; transition: all 0.28s ease 0s; border: 1px solid rgba(61, 197, 80, 0.3);"><summary style="box-sizing: border-box; display: list-item; cursor: pointer; padding: 16px; margin: -16px -16px 0px; border-radius: 4px 4px 0px 0px; color: rgb(68, 68, 68); font-weight: bold; position: relative; line-height: normal; font-size: 0.875rem !important; background: rgb(235, 249, 237); border-bottom: 1px solid rgba(61, 197, 80, 0.3);">操作步骤:</summary><div class="content" style="box-sizing: border-box; padding: 16px; margin: 0px -16px -16px;"><ul style="box-sizing: border-box; margin-top: 0.4rem; margin-bottom: 0px; padding: 0px 0px 0px 0.8rem; list-style: none; counter-reset: li 0;">               <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">1.收集一批作业(卡),用专用IO计算机将作业逐个读到磁带上保存起来。 </li>     <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">2.批处理程序将磁带上的第一个作业读入计算机，运算结束后将结果输出到输出磁带上。 </li>     <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">3.自动读入下一个作业,并运行。 </li>     <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">4.当一批作业全部执行结束后,取下输入磁带和输出磁带,用输入磁带录入下一批作业,将输出磁带送到专用输出计算机,进行脱机打印。 </li></ul></div></details></li></ul><h5 id="单道批处理系统-评价"><a href="#单道批处理系统-评价" class="headerlink" title="单道批处理系统:评价"></a>单道批处理系统:评价</h5><ul><li>解决了作业间的自动转接问题,减少了机器时间的浪费。</li><li>不管作业大小,只要它一旦占用处理机开始执行，<br>则它必须一直占据处理机,直到运行完毕。</li><li>资源利用率低。</li><li>对短作业不公平,因为它们等待执行的时间可能远远超过它们实际执行的时间。</li><li>交互性差。作业由批处理程序控制运行,用户无法实时控制,如果运行中途出现故障,也只能停下来,重新运行。</li></ul><h4 id="多道批处理系统现代意义的操作系统"><a href="#多道批处理系统现代意义的操作系统" class="headerlink" title="多道批处理系统现代意义的操作系统"></a>多道批处理系统现代意义的操作系统</h4><p>引入:<br>单道批处理系统中,任意时刻只允许一道作业在内存中运行,资源利用率低。为了提高系统资源利用率和系统吞吐量，形成了多道批处理系统</p><h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><ul><li>多道是指,允许多个程序同时存在于主存中,按照某种原则分派处理机，逐个执行这些程序。</li><li>批处理:用户提交的作业首先存放在外存，并排成一个队列。然后，由作业调度程序按照一定的算法从该队列中一次选取一个或若干个作业装入内存执行。</li></ul><h4 id="处理机自动切换"><a href="#处理机自动切换" class="headerlink" title="处理机自动切换"></a>处理机自动切换</h4><ul><li>当某个程序占用处理机执行过程中遇到了输入/输出语句,可以启动专门负责输入/输出的系统服务程序完成输入/输出操作，而处理机切换到另一个程序执行</li></ul><h4 id="多道程序设计技术"><a href="#多道程序设计技术" class="headerlink" title="多道程序设计技术"></a>多道程序设计技术</h4><ul><li>为了提高系统吞吐量和资源利用率,允许多个程序同时驻留内存,使处理机在这些程序之间切换，在一段时间内，执行完多个程序的处理技术称为多道程序设计技术（multiprogramming ) .</li><li>现代操作系统大多都采用了多道程序设计技术。</li></ul><h5 id="多道程序设计技术引发的问题"><a href="#多道程序设计技术引发的问题" class="headerlink" title="多道程序设计技术引发的问题"></a>多道程序设计技术引发的问题</h5><ul><li>处理机的分配与回收</li><li>内存的分配与保护</li><li>I/O设备的共享与效率</li><li>文件的有效管理</li><li>作业的组织</li></ul><h4 id="分时系统与实时系统"><a href="#分时系统与实时系统" class="headerlink" title="分时系统与实时系统"></a>分时系统与实时系统</h4><ul><li>多道批处理系统:提高了资源利用率和吞吐量。但是，批处理系统交互性很差。</li><li>为了改进响应时间和性能,提供交互式操作环境,导致了分时系统的出现。</li><li>分时系统的实质是，在多道程序技术的基础之上.为多个用户配置个联机终端。</li></ul><p>![image-20210907173515930]/img/操作系统原理/第一章/image-20210907173515930.png)</p><h5 id="分时系统实例"><a href="#分时系统实例" class="headerlink" title="分时系统实例"></a>分时系统实例</h5><ul><li>第一个分时系统:MIT的兼容分时系统CTSS</li><li>它是一个单道分时系统。在该系统中,每次只能将一道程序(作业)装入并驻留内存</li><li>时间片</li><li>为了减少磁盘I/O,只将新装入的程序需要覆盖的那部分用户数据写出到磁盘。</li><li>假设有4个交互用户,其存储需求如下:    JOB1(15000),JOB2(20000), “JOB3(5000),JOB4(10000)</li><li>内存的05000区域被监控程序占用</li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20210907170215357.png" alt="image-20210907170215357"></p><h4 id="“前台”和“后台”"><a href="#“前台”和“后台”" class="headerlink" title="“前台”和“后台”"></a>“前台”和“后台”</h4><ul><li>分时系统:分时+批处理功能</li><li>内存:“前台区”和“后台区”，“前台区”存放按时间片“调入”和“调出”的作业流,“后台区”存放批处理作业。</li><li>仅当前台作业调入/调出,或前台无作业可运行时，方才运行“后台区”中的作业。</li><li>提供交互式快速的服务，同时在处理机空闲时运行后台较大的批作业。</li></ul><h4 id="多道分时系统"><a href="#多道分时系统" class="headerlink" title="多道分时系统"></a>多道分时系统</h4><ul><li>允许在内存中同时存放多道作业，并把具备运行条件的所有作业排成一个队列,让它们依次轮流地获得一个时间片来运行。</li><li>与单道分时系统相比较，由于作业数据都在内存，不需要调入、调出开销,所以多道分时系统具有较好的系统性能。</li><li>现代分时系统都属于多道分时系统。</li></ul><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><ul><li>分时系统为交互式作业提供了快速的响应服务，但还不能满足某些对响应时间要求非常严格的任务需要。</li><li>例如,炼钢/炼油控制系统、航空网络售票系统等,对任务的响应时间有更严格的要求。</li></ul><h4 id="操作系统的进一步发展"><a href="#操作系统的进一步发展" class="headerlink" title="操作系统的进一步发展"></a>操作系统的进一步发展</h4><ul><li>个人计算机操作系统:UNIX、OS/2、Windows系列、Windows NT、LINUX等</li><li>网络操作系统:网络接口控制器及一些用于驱动的低层软件,远程登录软件和远程文件访问软件。</li><li>分布式操作系统:将用户的应用程序分布在多合处理机上同时运行。合理地调度各处理机,使整个系统获得最大的并行度。</li><li>嵌入式操作系统</li></ul><h3 id="1-4操作系统的功能"><a href="#1-4操作系统的功能" class="headerlink" title="1.4操作系统的功能"></a>1.4操作系统的功能</h3><h4 id="接口功能"><a href="#接口功能" class="headerlink" title="接口功能"></a>接口功能</h4><ul><li>接口，指操作系统为用户提供的人机交互界面</li><li><strong>命令接口</strong>:以命令方式供用户通过键盘终端与计算机交互，如UNIX、DOS</li><li><strong>图形化用户接口</strong>:Windows系列操作系统则提供了形象、生动的图形化界面,用户只需拖动并点击鼠标,便可轻松操作计算机。</li><li><strong>程序接口</strong>:以系统调用的形式供用户编程时使用。几乎各种操作系统都提供了系统调用,供程序设计</li></ul><h4 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h4><ul><li>进程控制:创建和撤消进程以及控制进程的状态转换。</li><li>进程同步:协调,互斥访问临界资源,协调执行进度</li><li>进程通信:进程间的信息交换</li><li>进程调度:按一定算法从进程就绪队列中选出一个进程,把处理机分配给它,使之运行。</li></ul><h4 id="存储器管理任务"><a href="#存储器管理任务" class="headerlink" title="存储器管理任务"></a>存储器管理任务</h4><p>为多道程序的并发执行提供良好的环境;便于用户使用存储器;<br>提高存储器的利用率;<br>为尽量多的用户提供足够大的存储空间</p><h4 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h4><ul><li>内存分配:静态分配/动态分配、连续分配/非连续分配</li><li>内存保护:系统内存空间、用户内存空间</li><li>地址映射:逻辑地址—&gt;物理地址</li><li>内存扩充:虚拟存储技术</li></ul><h4 id="操作系统的主要任务"><a href="#操作系统的主要任务" class="headerlink" title="操作系统的主要任务"></a>操作系统的主要任务</h4><ul><li>管理处理机</li><li>管理存储器</li><li>管理输入/输出设备</li><li>管理数据文件</li><li>提供接口服务</li></ul><h4 id="设备管理任务"><a href="#设备管理任务" class="headerlink" title="设备管理任务"></a>设备管理任务</h4><ul><li>为用户程序分配I/O设备;</li><li>完成用户程序请求的I/O操作;</li><li>提高处理机和I/O设备的利用率;</li><li>改善人机界面</li></ul><h4 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h4><ul><li>缓冲管理</li><li>设备分配</li><li>设备处理:启动设备、中断处理虚拟设备功能</li><li>RAID技术、磁盘调度</li></ul><h4 id="文件管理任务"><a href="#文件管理任务" class="headerlink" title="文件管理任务"></a>文件管理任务</h4><ul><li>管理用户文件和系统文件</li><li>管理文件的存储空间</li><li>保证文件数据的安全</li><li>方便用户使用文件</li></ul><h4 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h4><ul><li>文件目录管理</li><li>文件的逻辑组织与访问方式</li><li>存储空间的管理:文件的物理组织、空闲磁盘空间的管理</li><li>文件共享与安全</li></ul><h3 id="1-5现代操作系统的特征及基本概念"><a href="#1-5现代操作系统的特征及基本概念" class="headerlink" title="1.5现代操作系统的特征及基本概念"></a>1.5现代操作系统的特征及基本概念</h3><h4 id="现代操作系统的特征"><a href="#现代操作系统的特征" class="headerlink" title="现代操作系统的特征"></a>现代操作系统的特征</h4><ul><li>任务<u>共行</u>性:宏观上,指系统中有多个任务同时运行;微观上,指单处理机系统中的任务<u>并发</u>,即多个任务在单个处理机上交替运行;或多处理机系统中的任务<u>并行</u>,即多个任务在多个处理机上同时运行。</li><li>资源<u>共享</u>性:宏观上,指多个任务可以同时使用系统资源;微观上,指多个任务可以交替互斥地使用系统中的某个资源。</li><li>虚拟性:指将一个物理上的实体变为若干个逻辑上的对应物。如,采用分时技术,将一台处理机虚拟为若干台处理机。还可以虚拟存储、虚拟翠备、虚拟涌道、虚拟文件、虚拟用户组以及虚拟网络等。</li><li>不确定性<br>1.程序执行结果不确定,程序不可再现。<br>2.多道程序环境下,进程以异步方式执行。</li></ul><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h5><p>指,系统中允许多道程序同时准备运行,当正在运行的那道程序因为某种原因(比如等待输入或输出数据)暂时不能继续运行时,系统将自动地启动另一道程序运行;一旦原因消除(比如数据已经到达或数据已经输出完毕），暂时停止运行的那道程序在将来某个时候还可以被系统重新启动继续运行。</p><p>问题:</p><ul><li>协调因争夺处理机或者输入/输出设备而产生的冲突,解决同步、互斥和死锁问题。</li><li>防止各道程序之间的交叉和冲突,防止作业被有意无意地破坏。</li><li>必须建立高效、可靠和方便的文件系统,有效地管理和存取系统中的软件资源和辅存空间。</li></ul><h5 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h5><ul><li>进程是指,程序的一次执行,包括可执行的程序、程序所需的数据和相关状态信息。进程是拥有资源的最小实体,在传统OS中,进程同时也是系统调度的最小单位。</li><li>线程是指,程序的一次相对独立的运行过程;在现代OS中，线程是系调度的最小单位。</li></ul><h5 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h5><ul><li>作业是指,计算机用户在一次上机过程中要求计算机系统为其所做工作的集合;作业中的每项相对独立的工作称为作业步。通常,人们用一组命令来描述作业;其中,每个命令定义一个作业步。</li><li>作业的基本类型</li></ul><ol><li>脱机作业</li><li>联机作业</li></ol><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><ul><li>在经典的多任务操作系统环境下,任务与进程是等同的,都被认为是系统的最小工作单位</li><li>任务是从系统资源分配的角度描述程序在系统中的运行</li><li>进程则从处理器利用和工作流程控制的角度描述程序的执行。</li><li>程序员习惯于称呼进程,而工程师则习惯呼任务</li></ul><h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><ul><li>系统调用是操作系统提供的最基本的一级服务,供用户程序调用。</li><li>系统调用只能在程序中作为程序语句使用,不能单独使用。</li></ul><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><ul><li>英文Interface在操作系统中具有接口和界面两种含义。<br>接口多用于描述系统硬件之间的连接关系,以及软件和程序</li><li>模块间的调用关系,如总线接口、打印机接口等。</li><li>界面多用于描述用户与系统之间的操作环境,以及人机之间的交互方式和过程,如字符界面、图形用户界面等。</li></ul><h5 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h5><ul><li>定义:为了能在有限的内存空间中运行更大、更多的进程（程序），可以将一部分磁盘空间虚拟为逻辑内存,使用户感觉到一个比物理内存空间大得多的逻辑内存空间,即实际物理内存空间与虚拟的那部分逻辑内存空间的总和,统称为虚拟内存空间。</li><li>有了虚拟存储技术，进程执行时，只需要预先在物理内存中装入进程的一部分程序代码和数据，进程即可开始执行。</li><li>当需要的程序代码和数据不在物理内存时，根据需要临时装入，而整个操作对用户透明。</li></ul><h5 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h5><ul><li>文件是若干相关数据的集合,有的操作系统将程序、数据以及各种外部设备统统称为文件。</li><li>唯一的文件名</li><li>对文件的操作包括文件的建立、修改、删除、重命名、设置访问权限等。</li><li>概括地说,文件就是命名了的字节流,它是现代操作系统对计算机系统中种类繁多的外部设备进行高度抽象的结果。</li></ul><h3 id="1-6操作系统分类"><a href="#1-6操作系统分类" class="headerlink" title="1.6操作系统分类"></a>1.6操作系统分类</h3><ul><li>按照硬件平台系统结构不同分类:<br>单机操作系统、嵌入式操作系统和多机操作系统(并行操作系统、分布式操作系统、网络操作系统、机群操作系统等)</li><li>根据操作系统在用户界面的使用环境和功能特征的不同分类:<br>批处理系统、分时系统和实时系统</li><li>现代操作系统通常兼有分时和批处理功能</li></ul><h4 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h4><pre><code>工作方式:</code></pre><ul><li>一批作业首先在外存上排成一个队列;</li><li>然后,由作业调度程序负责从该队列中选取一个或多个作业进入内存，并分别为它们建立进程,使若干进程共享包括处理机、内存空间在内的系统资源,以提高资源利用率和系统吞吐量。</li><li>主要优点:多道程序由操作系统自动调度执行大大降低了人工干预对系统性能的影响,资源利用率高，系统的吞吐量大。<br>缺点:<br>(1)交互性很差,修改和调式程序极其困难<br>(2)增加了作业的平均周转时间。作业在外存排队,等待调度进入内存。进程在内存排队,等待荻取所需的系统资源</li></ul><h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><ul><li>提供了一个多用户工作环境，一台主机连接若干台终端,每台终端供一个用户使用。</li><li>用户交互式地向系统提出联机命令请求,系统接受所有用户的命令,采用分时原则处理服务请求,再通过交互式终端显示执行结果。</li></ul><h5 id="分时操作系统-特性"><a href="#分时操作系统-特性" class="headerlink" title="分时操作系统:特性"></a>分时操作系统:特性</h5><ul><li>多路性:一台主机上同时连接多台终端</li><li>独立性:每个用户各自通过自已的终端进行输入/输出,互不干扰。用户感觉自已独占终端和主机资源</li><li>交互性</li></ul><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><ul><li>指，能及时响应外部事件的请求，在规定的时间内完成对该事件的处理,并控制所有实时任务协调一致地运行的操作系统。</li><li>设计目标:对外部请求必须及时响应,在严格规定的时间内完成某事件,要求系统具有极高的可靠性和完整性</li></ul><h5 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h5><ul><li>指，在计算机网络环境中提供网络管理、通信、安全、资源共享和各种网络应用等功能的操作系统。</li><li>目标:为了实现网络中各计算机之间的通信和网络资源共享,提高网络资源的利用率和网络的吞吐量。</li></ul><h5 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h5><ul><li>分布式系统是指多个处理机通过通信线路互连而构成的系统,系统的处理和控制功能分布在各个处理机上。</li><li>配置在分布式系统上的操作系统称为分布式操作系统,它负责分布式系统中的任务分配、资源管理等功能服务。</li></ul><h5 id="分布式系统与计算机网络"><a href="#分布式系统与计算机网络" class="headerlink" title="分布式系统与计算机网络"></a>分布式系统与计算机网络</h5><ul><li>分布式系统中的所有资源都是共享的,由分布式操作系统进行集中、统一管理。整个系统对用户透明</li><li>计算机网络中允许每台计算机配置自己的操作<br>系统,通过网络协议实现网络资源的统一管理,网络操作系统可以构架于不同的操作系统之上，范围很广。网络操作系统也不要求对网络资源进行透明访问,用户可以清楚地知道提交的任务在哪台计算机上完成的</li></ul><h5 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h5><ul><li>指,运行在嵌入式系统环境中，对整个嵌入式系统以及它所操作、控制的各种部件装置等资源进行协调、调度、指挥和控制的系统软件。</li><li>嵌入式操作系统在工业控制、军事及民用设施中有着广泛的应用前景。</li></ul><h3 id="1-7现代主流操作系统简介"><a href="#1-7现代主流操作系统简介" class="headerlink" title="1.7现代主流操作系统简介"></a>1.7现代主流操作系统简介</h3><h4 id="Windows操作系统"><a href="#Windows操作系统" class="headerlink" title="Windows操作系统"></a>Windows操作系统</h4><ul><li>Windows是一个多任务操作系统,它允许用户同时运行多个应用程序，或在一个程序中同时做几件事情。系统为每个应用程序打开一个窗口。用户可以移动窗口,或在不同的应用程序之间切换。</li><li>Windows NT及Windows 2000都属于多用户操作系统。Windows NT支持对称多处理机、多线程、多个可装卸文件系统,兼容POSIX标准</li></ul><h4 id="UNIX操作系统"><a href="#UNIX操作系统" class="headerlink" title="UNIX操作系统"></a>UNIX操作系统</h4><ul><li>UNIX是一个由C语言编写的、多用户多任务操作系统。</li><li>已应用于从嵌入式处理器到工作站、“桌面系统,乃至服务于大群用户的高性能多处理机系统</li></ul><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20210907172208223.png" alt="image-20210907172208223"></p><h4 id="Linux操作系统"><a href="#Linux操作系统" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h4><ul><li>Linux是UNIX变种,是一个源代码开放的、多用户操作系统。</li><li>Linux支持多用户、多任务、分页式虚拟存储、动态链接库、动态调整文件系统缓冲区大小等功能。</li><li>其网络功能非常强大，几乎能与当前绝大多数网络互连。</li></ul><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ul><li>操作系统是计算机系统中最重要的一个系统软件。</li><li>对操作系统的四种基本观点:用户环境的观点、虚拟机的观点、作业组织观点和资源管理观点</li><li>若干因素推动着操作系统的发展</li><li>现代操作系统的特征</li><li>操作系统的类型区</li><li>操作系统的功能</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统原理&quot;&gt;&lt;a href=&quot;#操作系统原理&quot; class=&quot;headerlink&quot; title=&quot;操作系统原理&quot;&gt;&lt;/a&gt;操作系统原理&lt;/h1&gt;&lt;h2 id=&quot;第1章-操作系统概述&quot;&gt;&lt;a href=&quot;#第1章-操作系统概述&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="操作系统原理" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="操作系统原理" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    <category term="总结" scheme="http://example.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>软件项目管理-生存期模型(讲解版)</title>
    <link href="http://example.com/2021/09/06/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B(%E8%AE%B2%E8%A7%A3%E7%89%88)/"/>
    <id>http://example.com/2021/09/06/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B(%E8%AE%B2%E8%A7%A3%E7%89%88)/</id>
    <published>2021-09-06T04:36:08.000Z</published>
    <updated>2021-09-07T10:18:47.140Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>第 3 章 软件生存期模型</strong></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>软件将要经历一个定义、开发、运行维护，直至被淘汰这样的生命周期。<br>为了使软件生命周期中的各项任务能够有序地按照规程进行，需要一定的工作模型对各项任务给予规程约束，这样的工作模型被称为软件生存期模型。</p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/image-20210905233153022.png" alt="image-20210905233153022"></p><h3 id="生存期模型选择"><a href="#生存期模型选择" class="headerlink" title="生存期模型选择"></a>生存期模型选择</h3><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/image-20210905233415481.png" alt="image-20210905233415481"></p><h3 id="软件开发模型变迁"><a href="#软件开发模型变迁" class="headerlink" title="软件开发模型变迁"></a>软件开发模型变迁</h3><p>软件开发的模式是一个在原有基础上不断更新、改进和添加的过程，最终目的是让软件开发这一过程变得更有效率、便捷。</p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/image-20210905233546638.png" alt="image-20210905233546638"></p><p><strong>20世纪60年代：软件作坊，</strong>软件规模小，以作坊式开发为主；<br><strong>70年代：软件危机，</strong>硬件飞速发展，软件规模和复杂度激增，引发软件危机；<br><strong>80年代：软件过程控制，</strong>引入成熟生产制造管理方法，以“过程为中心”分阶段来控制软件开发（瀑布模型），一定程度上缓解了软件危机；<br><strong>90年代：重型过程，</strong>软件失败的经验促使过程被不断增加约束和限制，软件开发过程日益“重型化”，开发效率降低、响应速度发慢；<br><strong>2001~今：敏捷正在流行，</strong>随着信息时代到来，需求发化更快，交付周期成为企业核心竞争力，轻量级的，更能适应发化的敏捷软件开发方法被普遍认可并迅速流行。</p><h2 id="一、生存期模型定义"><a href="#一、生存期模型定义" class="headerlink" title="一、生存期模型定义"></a>一、生存期模型定义</h2><p>软件开发的全部过程、活动和任务的结构框架，通过该模型能清晰、直观地表达软件开发全过程，明确地规定要完成的主要活动和任务，它奠定了软件项目工作的<strong>基础</strong>。</p><h4 id="软件生存期模型特征"><a href="#软件生存期模型特征" class="headerlink" title="软件生存期模型特征"></a>软件生存期模型特征</h4><ul><li><p>描述了开发的主要阶段</p></li><li><p>定义每一个阶段要完成的主要过程和活动</p></li><li><p>确定每一个阶段的输入和输出</p><h4 id="软件生存期模型意义"><a href="#软件生存期模型意义" class="headerlink" title="软件生存期模型意义"></a>软件生存期模型意义</h4><ul><li>软件开发模型是软件开发全部过程、 活动和任务的结构框架。 </li><li>软件开发模型能清晰、直观地表达 软件开发全过程，明确规定了要完 成的主要活动和任务，用来作为软 件项目开发的基础。</li></ul></li></ul><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/image-20210906000233151.png" alt="image-20210906000233151"></p><h4 id="软件生存期模型分类"><a href="#软件生存期模型分类" class="headerlink" title="软件生存期模型分类"></a>软件生存期模型分类</h4><ul><li>预测模型</li><li>迭代模型</li><li>增量模型</li><li>敏捷模型</li></ul><h4 id="三、软件生命周期模型选择问题"><a href="#三、软件生命周期模型选择问题" class="headerlink" title="三、软件生命周期模型选择问题"></a><strong>三、软件生命周期模型选择问题</strong></h4><p>下图为生存期的项目特征</p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/111.png" alt="111"></p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/222.png" alt="222"></p><p>没有一个模型可以能完美的适应每一个项目,项目应根据具体特征实现最佳平衡</p><h2 id="二、生存期模型分类介绍"><a href="#二、生存期模型分类介绍" class="headerlink" title="二、生存期模型分类介绍"></a>二、生存期模型分类介绍</h2><h3 id="1-预测型模型"><a href="#1-预测型模型" class="headerlink" title="1. 预测型模型"></a><strong>1. 预测型模型</strong></h3><p> 提前进行大量的计划工作，然后一次性执行;执行是一个连续的过程。要求项目是高确定性的、有明确的需求顺序执行。包括瀑布模型和V模型。</p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209101910893-1817368670.png" alt="1497698-20190209101910893-1817368670"></p><h4 id="1-1-瀑布模型"><a href="#1-1-瀑布模型" class="headerlink" title="1.1 瀑布模型"></a><strong>1.1 瀑布模型</strong></h4><p>瀑布模型是将软件生存周期的各项活动规定为按固定顺序而连接的若干阶段工作，形如瀑布流水，最终得到软件产品。</p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/111.png" alt="111"></p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/222.png" alt="222"></p><p>特点：</p><ol><li>软件开发的各个活动按<strong>线性</strong>方式进行</li><li>管理简单、顺序执行</li></ol><p>优：</p><ol><li>为项目提供各阶段的检查点</li><li>可在迭代模型中应用瀑布模型</li></ol><p>缺：</p><ol><li>各阶段划分比较固定，阶段之间会产生大量文档，增大工作量</li><li>由于开发模型为线性的，客户只能等到过程末期才见到效果，增大开发风险</li><li>无法适应用户需求的变化</li></ol><h4 id="1-2-V模型"><a href="#1-2-V模型" class="headerlink" title="1.2 V模型"></a><strong>1.2 V模型</strong></h4><p>V模型是瀑布模型的一个变种，强调测试与开发的一一对应关系。</p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209104118716-976753301.png" alt="1497698-20190209104118716-976753301"></p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209104232127-852031148.png" alt="1497698-20190209104232127-852031148"></p><p>适用：适合对性能、安全等要求非常严格的场景。</p><p> 补充:“螺旋模型”，是指将瀑布模型和快速原型模型结合起来，强调风险分析的一种开发模型。</p><h3 id="3-迭代模型"><a href="#3-迭代模型" class="headerlink" title="3. 迭代模型"></a><strong>3. 迭代模型</strong></h3><pre><code>迭代模型也叫原型模型，基本的思想是——在限定的时间内，用最经济的方法开发出一个可实际运行的系统模型，用户在运行使用整个原型的基础上，通过对其评价，提出改进意见，对原型进行修改，统一使用，评价过程反复进行，使原型逐步完善，直到完全满足用户的需求为止。</code></pre><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E6%B3%95%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.gif"></p><p>  <img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209112206857-1693021447.png"></p><p>  适用：需求不明确、需要包含界面的系统。</p><p>特点：</p><ol><li>实际可行</li><li>具有最终系统的基本特征</li><li>构造方便、快速、造价低</li></ol><p>优：</p><ol><li>增加用户与开发人员的交流</li><li>用户在项目开发中占主导作用</li><li>满足用户的动态需求</li><li>降低开发风险</li></ol><p> 缺：</p><ol><li>因为用户的参与，使得忽视原型对实际环境的适应性等技术问题，所以不适合大型、复杂项目开发</li><li>对于技术层面远大于其分析层面的问题不宜使用原型法</li></ol><h3 id="2-增量模型"><a href="#2-增量模型" class="headerlink" title="2. 增量模型"></a><strong>2. 增量模型</strong></h3><pre><code>增量模型是把一个项目分为多个增量来开发，从而分批次地分析、设计、编码和测试这些增量组件向客户提供各个己完成的，可能立即使用的可交付成果。相对于瀑布模型而言，采用增量模型进行开发，开发人员不需要一次性地把整个软件产品提交给用户，而是可以分批次进行提交。</code></pre><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqdXd4eA==,size_16,color_FFFFFF,t_70"></p><p>  要点：分增量优先开发核心功能，多次交付。</p><p>  <img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209114514355-1221070020.png"></p><p> 缺点 :</p><ul><li>需要软件具备开放式的体系结构。 </li><li>容易退化为边做边改方式，使软件过程的控制失去整体性(很难被模块化)。</li><li>需求难以在增量实现之前详细定义，因此增量与需求的准确映射以及所有增量的有效集成可能会比较困难。</li></ul><p>实例:某大型企业计划开发一个“综合信息管理系统”，涉及销售、供应、财务、生产、人力资源等多个部门的信息管理。该企业的想法是按部门优先级别逐个实现，边应用边开发。对此，需要一种比较合适的过程模型。请对这个过程模型作出符合应用需要的选择，并说明选择理由。</p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/image-20210906081250463.png" alt="image-20210906081250463"></p><h3 id="4-敏捷模型（Agile）"><a href="#4-敏捷模型（Agile）" class="headerlink" title="4. 敏捷模型（Agile）"></a>4. <strong>敏捷模型（Agile）</strong></h3><p>既有迭代，也有增量，便于完善工作，频繁交付。</p><ul><li>敏捷开发方法的宗旨是：沟通、简化、反馈、 激励。</li><li>强调人的作用，构建起具有合作精神的、自组 织的、有凝聚力量的团队。</li><li>敏捷开发是一种开发过程，而不是软件生命周 期模型。</li></ul><p>敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。</p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209114746381-1983984.png"></p><p>  敏捷 = 4个价值 + 12个原则 + 很多实践 </p><p>   <img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209115907462-478233457.png"></p><p>  传统模型：不考虑后期需求的变化就预测用户的需求，按照冻结的需求指定计划，根据制定的计划执行项目开发。<br>  敏捷模型：通过不断的反馈动态地修改用户需求来达到客户的目标，是一个自适应的过程。</p><p>  <img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209120850886-146337147.png"></p><p>  <img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209123534385-373587315.png"></p><h4 id="4-1-Scrum-模型"><a href="#4-1-Scrum-模型" class="headerlink" title="4.1. Scrum 模型"></a><strong>4.1. Scrum 模型</strong></h4><pre><code>1990年代初，肯.施瓦伯在其公司使用了一种方法 Advanced Development Methods（先进开发方法），这种方法后来发展为 Scrum。</code></pre><img src="/img/软件项目管理/生存期模型/image-20210905235551577.png" alt="image-20210905235551577" style="zoom: 200%;" /><h5 id="迭代开发过程"><a href="#迭代开发过程" class="headerlink" title="迭代开发过程"></a>迭代开发过程</h5><p>   <img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209131352551-1104077209.png"></p><p><a href="https://ehzyil.github.io/2021/09/05/Scrum%E8%AE%B2%E8%A7%A3/">Scrum讲解</a></p><h4 id="4-2-XP（eXtreme-Programming）"><a href="#4-2-XP（eXtreme-Programming）" class="headerlink" title="4.2 XP（eXtreme Programming）"></a><strong>4.2 XP（eXtreme Programming）</strong></h4><p>XP是由Kent Beck（1999）提出的一套针对业务需求和软件开发实践的规则.</p><p> 采用简单策略，集中精力在最主要的功能上，其它可以在迭代开发中不断改进，从而避免书写大量文档。 </p><p> XP采用整体价值驱动的观点，强调4个关键价值： </p><ul><li><p>沟通：大多数项目的失败源于沟通不畅，所以要进行一些能够推动 积极沟通的实践。</p></li><li><p>简单：开发能够满足客户需要的最简单的产品。</p></li><li><p>反馈：开发者必须要获取并且重视来自客户、系统的反馈以及相互 之间的反馈。 </p></li><li><p>勇气：准备好做出支持其他原则和实践的艰难决定。</p></li></ul><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/image-20210905214541739.png" alt="image-20210905214541739"></p><p>极限编程模型的最佳实践，是通过 整体实践 开发团队实践 开发者实践三个层面，一共13个核心的实践体现</p> <details green="" open="" style="box-sizing: border-box; display: block; padding: 16px; margin: 1em 0px; border-radius: 4px; background: rgb(255, 255, 255); font-size: 14px; transition: all 0.28s ease 0s; border: 1px solid rgba(61, 197, 80, 0.3);"><summary style="box-sizing: border-box; display: list-item; cursor: pointer; padding: 16px; margin: -16px -16px 0px; border-radius: 4px 4px 0px 0px; color: rgb(68, 68, 68); font-weight: bold; position: relative; line-height: normal; font-size: 0.875rem !important; background: rgb(235, 249, 237); border-bottom: 1px solid rgba(61, 197, 80, 0.3);">整体实践层次包括四个实践</summary><div class="content" style="box-sizing: border-box; padding: 16px; margin: 0px -16px -16px;"><ol style="box-sizing: border-box; margin-top: 0.4rem; margin-bottom: 0px; padding: 0px 0px 0px 0.8rem; list-style: none; counter-reset: li 0;">            <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">whole Team要体现团队的意识，团队当中包括客户程序员测试员分析员，还有一个上层的经理等等，每个角色是平等的. </li>      <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">Planning，并体现为并体现为两个主要计划发布计划和迭代计划. </li>      <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">项Smalleleases是小版本，如果有可能，应该每天都要发布新的版本. </li>      <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">customer Tests客户对每个需求都定了一些验收测试通过运行验收测试，开发人员和客户可以知道开发出来的软件是否符合需求. </li></ol></div></details> <details green="" open="" style="box-sizing: border-box; display: block; padding: 16px; margin: 1em 0px; border-radius: 4px; background: rgb(255, 255, 255); font-size: 14px; transition: all 0.28s ease 0s; border: 1px solid rgba(61, 197, 80, 0.3);"><summary style="box-sizing: border-box; display: list-item; cursor: pointer; padding: 16px; margin: -16px -16px 0px; border-radius: 4px 4px 0px 0px; color: rgb(68, 68, 68); font-weight: bold; position: relative; line-height: normal; font-size: 0.875rem !important; background: rgb(235, 249, 237); border-bottom: 1px solid rgba(61, 197, 80, 0.3);">开发团队实现层面包括五个实践</summary><div class="content" style="box-sizing: border-box; padding: 16px; margin: 0px -16px -16px;"><ol style="box-sizing: border-box; margin-top: 0.4rem; margin-bottom: 0px; padding: 0px 0px 0px 0.8rem; list-style: none; counter-reset: li 0;">            <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">collective ownership提倡大家共同来拥有代码，每个人都有权利和一来月同其他人的代码. </li>      <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">coding Standard程序设计标准啊，者我们的极限编程模型，要求开发小组中，每个人都要遵守统一的编程标准，每个程序员更加容易懂其他人编写的代码. </li>     <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">Sustainable Pace恒定速度，要保持每周40个小时的工作时间啊，保持同一个效率. </li>      <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">Metaphor是一个系统的隐喻，是以讲故事的形式，形象的图来描述系统需求. </li>        <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">continuous lntegration持续的集成，频繁的来整合系统，然后发布一个新的应用系统. </li>     </ol></div></details> <details green="" open="" style="box-sizing: border-box; display: block; padding: 16px; margin: 1em 0px; border-radius: 4px; background: rgb(255, 255, 255); font-size: 14px; transition: all 0.28s ease 0s; border: 1px solid rgba(61, 197, 80, 0.3);"><summary style="box-sizing: border-box; display: list-item; cursor: pointer; padding: 16px; margin: -16px -16px 0px; border-radius: 4px 4px 0px 0px; color: rgb(68, 68, 68); font-weight: bold; position: relative; line-height: normal; font-size: 0.875rem !important; background: rgb(235, 249, 237); border-bottom: 1px solid rgba(61, 197, 80, 0.3);">开发者实践层面包括四个实现</summary><div class="content" style="box-sizing: border-box; padding: 16px; margin: 0px -16px -16px;"><ol style="box-sizing: border-box; margin-top: 0.4rem; margin-bottom: 0px; padding: 0px 0px 0px 0.8rem; list-style: none; counter-reset: li 0;">                 <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">简单设计，极限编程要求，用最简单的办法来实现每个小的需求，那么这些设计只要能满足当下的需求就可以了，而且所有的这些设计都将在后续的开发中被不断的重整和优化. </li>      <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">Pair Programming结对编程，我们现编程中所有的代码都是由两个程序员在同一台机器上一起来编写，这样保证了所有的代码设计单元测试，至少被另外一个人复核了.</li>      <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">Test-Driven Development测试驱动开发极限编程将测试结合到开发过程中，每次结合代码都应该运行不变，完成所有的测试. </li>      <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">Refactoring重构就是不断地对设计进行改进，我们将这个过程叫设计的重构. </li></ol></div></details><h5 id="精益（Lean）"><a href="#精益（Lean）" class="headerlink" title="精益（Lean）"></a><strong>精益（Lean）</strong></h5><pre><code>精益模式提倡持续不断地改进，减少流程中的浪费。</code></pre><p>(分析所有流程,删除不必要的流程)</p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/image-20210905214756902.png" alt="image-20210905214756902"></p><h5 id="持续交付（Continuous-delivery）"><a href="#持续交付（Continuous-delivery）" class="headerlink" title="持续交付（Continuous delivery）"></a>持续交付（Continuous delivery）</h5><p>让软件产品的产出过程在一个短周期内完成，以保证软件可以稳定、持续的保持在随时可以释出的状况。频繁的交付周期带来了更迅速地对软件的反馈，并且在这个过程当中，需求分析,设计开发,测试运维等角色可以密切的协作。</p><p>  <img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209133628688-21792536.png"></p><p>   <img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209133905111-1134554787.png"></p><p>  描述：将个人代码向整体部分交付，以便尽早发现个人开发的问题</p><p>  <img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209134053004-1008777511.png"></p><p>  描述：集成之后代码尽快向可运行环境的交付以便尽早测试</p><p>  <img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/1497698-20190209134331760-855382356.png"></p><p>  描述：尽快向客户交付，以便尽早发现生产环境中存在的问题</p><h4 id="4-3-DevOps-Development和Operations的组合"><a href="#4-3-DevOps-Development和Operations的组合" class="headerlink" title="4.3 DevOps :Development和Operations的组合"></a><strong>4.3 DevOps</strong> :Development和Operations的组合</h4><ul><li><h5 id="全程敏捷思维"><a href="#全程敏捷思维" class="headerlink" title="全程敏捷思维"></a>全程敏捷思维</h5></li><li><h5 id="开发和运维工作紧密合作。"><a href="#开发和运维工作紧密合作。" class="headerlink" title="开发和运维工作紧密合作。"></a>开发和运维工作紧密合作。</h5></li></ul><h5 id="运维人员和开发者之间的目标差异"><a href="#运维人员和开发者之间的目标差异" class="headerlink" title="运维人员和开发者之间的目标差异"></a>运维人员和开发者之间的目标差异</h5><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/image-20210905215848401.png" alt="image-20210905215848401"></p><p>交付新功能（理想质量）  产品文化（软件开发）<br>保证”运行” 应用程序（稳定性） 服务文化 (存档,监督,支持) </p><p>开发者和运维人员之间目的上的差异就叫做<strong>混乱之墙</strong></p><p>开发团队使用构建（Build）预算，运维团队使用运营（Run）预算。不同的预算，对控制权越来越高的需求，以及企业 IT 成本的缩水，这些因素结合在一起会进一步放大两个团队各自目的的对立性。</p><h5 id="DevOps-融合一系列基本原则和实践的方法论"><a href="#DevOps-融合一系列基本原则和实践的方法论" class="headerlink" title="DevOps:融合一系列基本原则和实践的方法论"></a>DevOps:融合一系列基本原则和实践的方法论</h5><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/image-20210905215950897.png" alt="image-20210905215950897"></p><p>  主要是为了消除拥有大规模 IT 部门的大型企业中，开发团队和运维团队之间由于历史原因产生的隔阂与孤立所造成的混乱现状。</p><h5 id="DevOps-是一种方法论"><a href="#DevOps-是一种方法论" class="headerlink" title="DevOps:是一种方法论"></a>DevOps:是一种方法论</h5><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/image-20210905220423913.png" alt="image-20210905220423913"></p><p>DevOps是一组过程、方法与系统的统称，用于促进开发、技术运营和质量保障（QA）部门之间的沟通、协作与整合</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;第 3 章 软件生存期模型&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;软件将要经历一个定义</summary>
      
    
    
    
    <category term="软件项目管理" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>敏捷开发之Scrum</title>
    <link href="http://example.com/2021/09/05/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Scrum%E8%AE%B2%E8%A7%A3/"/>
    <id>http://example.com/2021/09/05/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Scrum%E8%AE%B2%E8%A7%A3/</id>
    <published>2021-09-05T10:42:56.000Z</published>
    <updated>2021-09-07T10:19:17.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="敏捷开发之-Scrum"><a href="#敏捷开发之-Scrum" class="headerlink" title="敏捷开发之 Scrum"></a>敏捷开发之 Scrum</h1><h3 id="1-什么是敏捷开发？"><a href="#1-什么是敏捷开发？" class="headerlink" title="1.什么是敏捷开发？"></a>1.<strong>什么是敏捷开发？</strong></h3><p>敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方法。</p><p>怎么理解呢？首先，我们要理解它不是一门技术，它是一种开发方法，也就是一种软件开发的流程，它会指导我们用规定的环节去一步一步完成项目的开发；而这种开发方式的主要驱动核心是人；它采用的是迭代式开发；</p><h3 id="2-为什么说是以人为核心？"><a href="#2-为什么说是以人为核心？" class="headerlink" title="2.为什么说是以人为核心？"></a>2.<strong>为什么说是以人为核心？</strong></h3><p>我们大部分人都学过瀑布开发模型，它是以文档为驱动的，为什么呢？因为在瀑布的整个开发过程中，要写大量的文档，把需求文档写出来后，开发人员都是根据文档进行开发的，一切以文档为依据；而敏捷开发它只写有必要的文档，或尽量少写文档，敏捷开发注重的是人与人之间，面对面的交流，所以它强调以人为核心。</p><h3 id="3-什么是迭代？"><a href="#3-什么是迭代？" class="headerlink" title="3.什么是迭代？"></a>3.<strong>什么是迭代？</strong></h3><p>迭代是指把一个复杂且开发周期很长的开发任务，分解为很多小周期可完成的任务，这样的一个周期就是一次迭代的过程；同时每一次迭代都可以生产或开发出一个可以交付的软件产品。</p><h3 id="4-什么是Scrum？"><a href="#4-什么是Scrum？" class="headerlink" title="4.什么是Scrum？"></a>4.<strong>什么是Scrum？</strong></h3><p>Scrum的英文意思是橄榄球运动的一个专业术语，表示“争球”的动作；把一个开发流程的名字取名为Scrum，我想你一定能想象出你的开发团队在开发一个项目时，大家像打橄榄球一样迅速、富有战斗激情、人人你争我抢地完成它，你一定会感到非常兴奋的。</p><p>而Scrum就是这样的一个开发流程，运用该流程，你就能看到你团队高效的工作。</p><p>Scrum流程如下图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5zY3J1bWNuLmNvbS9hZ2lsZS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8wNC9TY3J1bUNOX1NjcnVtX1Byb2Nlc3NfNzEwLnBuZw?x-oss-process=image/format,png" alt="img"></p><h1 id="SCRUM框架"><a href="#SCRUM框架" class="headerlink" title="SCRUM框架"></a>SCRUM框架</h1><blockquote><p>Scrum框架包括3个角色、3个工件、5个事件、5个价值：</p></blockquote><h3 id="3个角色"><a href="#3个角色" class="headerlink" title="3个角色"></a>3个角色</h3><ol><li>产品负责人（Product Owner）主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。</li><li>流程管理员（Scrum Master）主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。</li><li>开发团队（Scrum Team）主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。</li></ol><h3 id="3个工件"><a href="#3个工件" class="headerlink" title="3个工件"></a>3个工件</h3><ol><li>产品Backlog（Product Backlog）</li><li>SprintBacklog</li><li>产品增量（Increment）</li></ol><h3 id="5个事件"><a href="#5个事件" class="headerlink" title="5个事件"></a>5个事件</h3><ol><li>Sprint（Sprint本身是一个事件，包括了如下4个事件）</li><li>Sprint计划会议（Sprint Planning Meeting）</li><li>每日站会（Daily Scrum Meeting）</li><li>Sprint评审会议（Sprint Review Meeting）</li><li>Sprint回顾会议（Sprint Retrospective Meeting）</li></ol><h3 id="5个价值"><a href="#5个价值" class="headerlink" title="5个价值"></a>5个价值</h3><ol><li>承诺 – 愿意对目标做出承诺</li><li>专注– 把你的心思和能力都用到你承诺的工作上去</li><li>开放– Scrum 把项目中的一切开放给每个人看</li><li>尊重– 每个人都有他独特的背景和经验</li><li>勇气– 有勇气做出承诺，履行承诺，接受别人的尊重</li></ol><h1 id="具体实施流程"><a href="#具体实施流程" class="headerlink" title="具体实施流程"></a>具体实施流程</h1><p><strong>什么是Sprint？</strong></p><p>Sprint是短距离赛跑的意思，这里面指的是一次迭代，而一次迭代的周期是1个月时间（即4个星期）或更短的限时，也就是我们要把一次迭代的开发内容以最快的速度完成它，这个过程我们称它为Sprint。</p><p><strong>如何进行Scrum开发？</strong></p><p>Scrum流程如下图：</p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Scrum/%E6%B5%81%E7%A8%8B.png" alt="流程"></p><p>1、我们首先需要确定一个Product Backlog（按优先顺序排列的一个产品需求列表），这个是由Product Owner 负责的；</p><p>![img](/home/lyz/Downloads/Product Backlog)</p><p>上图是一个 Product Backlog 的示例。</p><p>2、Scrum Team根据Product Backlog列表，做工作量的预估和安排；</p><p>3、有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出一个Story作为本次迭代完成的目标，这个目标的时间周期是1~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog；</p><p>4、Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更小的任务（细到每个任务的工作量在2天内能完成）；</p><p>5、在Scrum Team完成计划会议上选出的Sprint Backlog过程中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须发言，并且要向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn d<img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Scrum/%E6%AF%8F%E6%97%A5%E7%9A%84%E7%AB%99%E7%AB%8B%E4%BC%9A%E8%AE%AE.png" alt="每日的站立会议">own（Sprint燃尽图)；</p><p>上图就是每日的站立会议了，参会人员可以随意姿势站立，任务看板要保证让每个人看到，当每个人发言完后，要走到任务版前更新自己的燃尽图。</p><p> <img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Scrum/%E4%BB%BB%E5%8A%A1%E7%9C%8B%E7%89%88.png" alt="任务看版"></p><p>任务看版包含 未完成、正在做、已完成 的工作状态，假设你今天把一个未完成的工作已经完成，那么你要把小卡片从未完成区域贴到已完成区域。</p><p>6、做到每日集成，也就是每天都要有一个可以成功编译、并且可以演示的版本；很多人可能还没有用过自动化的每日集成，其实TFS就有这个功能，它可以支持每次有成员进行签入操作的时候，在服务器上自动获取最新版本，然后在服务器中编译，如果通过则马上再执行单元测试代码，如果也全部通过，则将该版本发布，这时一次正式的签入操作才保存到TFS中，中间有任何失败，都会用邮件通知项目管理人员；</p><p>7、当一个Story完成，也就是Sprint Backlog被完成，也就表示一次Sprint完成，这时，我们要进行 Srpint Review Meeting（演示会议），也称为评审会议，产品负责人和客户都要参加（最好本公司老板也参加），每一个Scrum Team的成员都要向他们演示自己完成的软件产品（这个会议非常重要，一定不能取消）；</p><p>8、最后就是 Sprint Retrospective Meeting（回顾会议），也称为总结会议，以轮流发言方式进行，每个人都要发言，总结并讨论改进的地方，放入下一轮Sprint的产品需求中；</p><p>本文参考：</p><p> <a href="https://www.scrumcn.com/agile/scrum_guide.html">SCRUM官方权威指南</a></p><p> <a href="https://blog.csdn.net/inny100_100/article/details/54633757?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">敏捷项目管理流程-Scrum框架最全总结！</a></p><p> <a href="https://blog.csdn.net/iteye_4462/article/details/81936667?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">敏捷开发之Scrum扫盲篇</a></p><p><a href="https://www.bilibili.com/video/BV1gE411j71p?share_source=copy_web">微软资深大咖给您讲敏捷开发：软件开发Scrum开发过程</a></p><iframe src="//player.bilibili.com/player.html?aid=95631565&bvid=BV1gE411j71p&cid=163266188&page=1" scrolling="no" width="100%" height="500" border="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;敏捷开发之-Scrum&quot;&gt;&lt;a href=&quot;#敏捷开发之-Scrum&quot; class=&quot;headerlink&quot; title=&quot;敏捷开发之 Scrum&quot;&gt;&lt;/a&gt;敏捷开发之 Scrum&lt;/h1&gt;&lt;h3 id=&quot;1-什么是敏捷开发？&quot;&gt;&lt;a href=&quot;#1-什么是敏捷</summary>
      
    
    
    
    <category term="软件项目管理" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="软件项目管理" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    <category term="总结" scheme="http://example.com/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Scrum" scheme="http://example.com/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>Day06</title>
    <link href="http://example.com/2021/09/05/JAVA/day06%E3%80%90Map%E3%80%91/"/>
    <id>http://example.com/2021/09/05/JAVA/day06%E3%80%90Map%E3%80%91/</id>
    <published>2021-09-05T02:35:46.000Z</published>
    <updated>2021-09-05T03:04:51.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day06【Map】"><a href="#day06【Map】" class="headerlink" title="day06【Map】"></a>day06【Map】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>Map集合  ，Collection集合<ul><li> 键值对集合，用的也很多。</li><li> Collection集合（单列集合，一个元素只能一个值。）</li><li> Map集合（双列集合，一个元素有2个值，每个元素叫键值对象，元素格式必须是：key=value）</li><li> <strong>List<String> names = new ArrayList&lt;&gt;();</strong></li><li> <strong>Set<Student> names = new HashSet&lt;&gt;();</strong></li><li> <strong>Map&lt;String , String&gt; names = new HashMap&lt;&gt;()；</strong></li></ul></li><li>图书管理系统(用的代码！)<ul><li> 让我们把集合和Map集合都用起来，然后引入一些业务思维做一个综合性的案例！</li></ul></li><li>Debug调试。(非常重要的排错手段)<ul><li> bug</li></ul></li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><p><input disabled="" type="checkbox">  能够使用集合工具类</p><pre><code class="java"> Collections下的API:    1、public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements)        -- 参数一：操作的集合对象。                -- 参数二：可变参数，给集合批量加的元素值。            2、public static void shuffle(List&lt;?&gt; list)：                -- 打乱List集合的顺序            3、public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)        -- 给List集合进行默认的升序排序。默认只能由小到大。                -- 有值特性的，按照值特性排序。                -- 对于字符串按照首字母的编号排序！                -- 此方法默认不能给引用类型的对象做排序，因为人家不知道你的排序规则！            4、public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c)        -- 参数一：被排序的集合对象。                -- 参数二：比较器对象，用于程序员来定制大小排序规则。</code></pre></li><li><p><input disabled="" type="checkbox">  能够使用Comparator比较器进行排序</p><pre><code class="java">          Student s1 = new Student(&quot;张三丰&quot;,100,&#39;男&#39;);        Student s2 = new Student(&quot;张无忌&quot;,32,&#39;男&#39;);        Student s3 = new Student(&quot;赵敏&quot;,22,&#39;女&#39;);        Student s4 = new Student(&quot;殷素素&quot;,45,&#39;女&#39;);        List&lt;Student&gt; stus = new ArrayList&lt;&gt;();        Collections.addAll(stus ,  s1 , s2 , s3 , s4);        Collections.sort(stus, new Comparator&lt;Student&gt;() &#123;            @Override            public int compare(Student o1, Student o2) &#123;                // Collections集合工具类会自动提取集合中的两两对象送进来让程序员自己来比较。                // o1  s1 = new Student(&quot;张三丰&quot;,100,&#39;男&#39;);                // o2  s2 = new Student(&quot;张无忌&quot;,32,&#39;男&#39;);                // 如果认为 o1 &gt; o2 应该返回正整数                // 如果认为 o1 &lt; o2 应该返回负整数                // 如果认为 o1 = o2 应该返回0//                if(o1.getAge() &gt; o2.getAge())&#123;//                    return  1;//                &#125;else if(o1.getAge() &lt; o2.getAge())&#123;//                    return -1;//                &#125;//                return 0;                return o1.getAge() - o2.getAge();            &#125;        &#125;);</code></pre></li><li><p><input disabled="" type="checkbox">  能够使用可变参数</p><pre><code class="properties">可变参数的作用：    可变参数可以用在方法，构造器等形参中，用于接收多个数据。可变参数的格式：数据类型... 变量名称可变参数在内部本质上就是一个数组！！可变参数的优点：参数传输非常的灵活！！可变参数的注意事项：    1.一个形参列表中只能有一个可变参数。    2.可变参数必须放在形参列表的最后面。</code></pre></li><li><p><input disabled="" type="checkbox">  能够理解冒泡排序的原理</p><pre><code class="properties">冒泡排序的核心点：每次两两比较找出当前最大值冒出到当前最后面即可！！</code></pre></li><li><p><input disabled="" type="checkbox">  能够说出Map集合特点</p><pre><code class="properties">Map集合的特点：    1.Map集合的特点都是由键决定的。    2.Map集合的键是无序,不重复的，无索引的。        Map集合后面重复的键对应的元素会覆盖前面的整个元素的值！    3.Map集合的值无要求。    4.Map集合的键值对都可以为null。</code></pre></li><li><p><input disabled="" type="checkbox">  使用Map集合添加方法保存数据</p><pre><code class="java">maps.put(&quot;iphoneX&quot; , 1);</code></pre></li><li><p><input disabled="" type="checkbox">  使用”键找值”的方式遍历Map集合</p><pre><code class="java">// a.先提取Map集合全部的键到一个Set集合中去// keys = [huawei, Java, iphoneX, 娃娃]Set&lt;String&gt; keys = maps.keySet();System.out.println(keys);// b.再遍历全部键，通过键获取对应的值for(String key : keys)&#123;    // 通过键取对应值    Integer value = maps.get(key);    System.out.println(key+&quot;----&gt;&quot;+value);&#125;</code></pre></li><li><p><input disabled="" type="checkbox">  使用”键值对”的方式遍历Map集合</p><pre><code class="java">/**    maps = &#123;huawei=8, Java=1, iphoneX=1, 娃娃=8&#125;    最开始是想直接用foreach遍历Map集合    发现foreach根本不能直接遍历Map集合，Map集合的键值对元素直接来看是没有类型的。        ↓    可以把Map集合通过如下API转换成一个Set集合。        -- Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()        -- entrySet = [(huawei=8), (Java=1), (iphoneX=1), (娃娃=8)]        --   entry        -- 此时该Set集合中的键值对元素成为一个整体，有了类型，            类型叫键值对实体类型：Map.Entry&lt;String,Integer&gt;        ↓    此时就可以通过foreach遍历entrySet集合了! */ Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = maps.entrySet(); for(Map.Entry&lt;String,Integer&gt; entry : entrySet)&#123;     String key = entry.getKey();     Integer value = entry.getValue();     System.out.println(key+&quot;--&gt;&quot;+value); &#125;</code></pre></li><li><p><input disabled="" type="checkbox">  能够使用HashMap存储自定义键值对的数据</p><pre><code class="java">// 学生对象作为键的类型，值用字符串表示地址信息Map&lt;Student , String&gt; maps = new HashMap&lt;&gt;();maps.put(new Student(&quot;欧世杰&quot;,18,&#39;男&#39;) , &quot;广州&quot;);maps.put(new Student(&quot;林志玲&quot;,41,&#39;女&#39;) , &quot;日本&quot;);maps.put(new Student(&quot;林志玲&quot;,41,&#39;女&#39;) , &quot;日本&quot;);maps.put(new Student(&quot;古天乐&quot;,41,&#39;男&#39;) , &quot;香港&quot;);</code></pre></li><li><p><input disabled="" type="checkbox">  能够理解图书管理系统案例</p><pre><code class="properties">参见代码！</code></pre></li></ul><h1 id="第一章-Map集合"><a href="#第一章-Map集合" class="headerlink" title="第一章 Map集合"></a>第一章 Map集合</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p><p><img src="/img/java/imgs6/Collection%E4%B8%8EMap.bmp"></p><ul><li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul><h2 id="1-2-Map的常用子类"><a href="#1-2-Map的常用子类" class="headerlink" title="1.2  Map的常用子类"></a>1.2  Map的常用子类</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p><ul><li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li><em><em>TreeMap&lt;K,V&gt;<strong>：TreeMap集合和Map相比没有特有的功能，底层的数据结构是红黑树；可以对元素的</strong></em>键</em><strong>进行排序，排序方式有两种:<strong>自然排序</strong>和</strong>比较器排序**</li></ul><blockquote><p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p></blockquote><h2 id="1-3-Map的常用方法"><a href="#1-3-Map的常用方法" class="headerlink" title="1.3  Map的常用方法"></a>1.3  Map的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li><li><code>public boolean containKey(Object key)</code>:判断该集合中是否有此键。</li></ul><p>Map接口的方法演示</p><pre><code class="java">public class MapDemo &#123;    public static void main(String[] args) &#123;        //创建 map对象        HashMap&lt;String, String&gt;  map = new HashMap&lt;String, String&gt;();        //添加元素到集合        map.put(&quot;黄晓明&quot;, &quot;杨颖&quot;);        map.put(&quot;文章&quot;, &quot;马伊琍&quot;);        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);        System.out.println(map);        //String remove(String key)        System.out.println(map.remove(&quot;邓超&quot;));        System.out.println(map);        // 想要查看 黄晓明的媳妇 是谁        System.out.println(map.get(&quot;黄晓明&quot;));        System.out.println(map.get(&quot;邓超&quot;));        &#125;&#125;</code></pre><blockquote><p>tips:</p><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p></blockquote><h2 id="1-4-Map的遍历"><a href="#1-4-Map的遍历" class="headerlink" title="1.4   Map的遍历"></a>1.4   Map的遍历</h2><h3 id="方式1-键找值方式"><a href="#方式1-键找值方式" class="headerlink" title="方式1:键找值方式"></a>方式1:键找值方式</h3><p>通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li></ol><p>遍历图解：</p><p><img src="/img/java/imgs6/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%80.bmp"></p><ul><li></li></ul><h3 id="方式2-键值对方式"><a href="#方式2-键值对方式" class="headerlink" title="方式2:键值对方式"></a>方式2:键值对方式</h3><p>即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p><strong>Entry键值对对象:</strong></p><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p> 获取了Entry对象 , 表示获取了一对键和值，那么同样Entry中 , 分别提供了获取键和获取值的方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>操作步骤与图解：</p><ol><li>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</li><li>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</li><li>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </li></ol><p>遍历图解：</p><p><img src="../../../%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%E8%AF%BE%E6%94%B9/day01-day15%E8%AE%B2%E4%B9%89-MD/day06-Collections,Set,Map,%E6%96%97%E5%9C%B0%E4%B8%BB%E6%8E%92%E5%BA%8F/img/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%BA%8C.bmp"></p><blockquote><p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p></blockquote><h2 id="1-5-HashMap存储自定义类型"><a href="#1-5-HashMap存储自定义类型" class="headerlink" title="1.5  HashMap存储自定义类型"></a>1.5  HashMap存储自定义类型</h2><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p><blockquote><p>注意，学生姓名相同并且年龄相同视为同一名学生。</p></blockquote><p>编写学生类：</p><pre><code class="java">public class Student &#123;    private String name;    private int age;    //构造方法    //get/set    @Override    public boolean equals(Object o) &#123;        if (this == o)            return true;        if (o == null || getClass() != o.getClass())            return false;        Student student = (Student) o;        return age == student.age &amp;&amp; Objects.equals(name, student.name);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(name, age);    &#125;&#125;</code></pre><p>编写测试类：</p><pre><code class="java">public class HashMapTest &#123;    public static void main(String[] args) &#123;        //1,创建Hashmap集合对象。        Map&lt;Student,String&gt; map = new HashMap&lt;Student,String&gt;();        //2,添加元素。        map.put(new Student(&quot;lisi&quot;,28), &quot;上海&quot;);        map.put(new Student(&quot;wangwu&quot;,22), &quot;北京&quot;);        map.put(new Student(&quot;wangwu&quot;,22), &quot;南京&quot;);                //3,取出元素。键找值方式        Set&lt;Student&gt; keySet = map.keySet();        for(Student key: keySet)&#123;            String value = map.get(key);            System.out.println(key.toString()+&quot;.....&quot;+value);        &#125;    &#125;&#125;</code></pre><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li></ul><h2 id="1-6-LinkedHashMap介绍"><a href="#1-6-LinkedHashMap介绍" class="headerlink" title="1.6   LinkedHashMap介绍"></a>1.6   LinkedHashMap介绍</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p><p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p><pre><code class="java">public class LinkedHashMapDemo &#123;    public static void main(String[] args) &#123;        LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;();        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);        map.put(&quot;李晨&quot;, &quot;范冰冰&quot;);        map.put(&quot;刘德华&quot;, &quot;朱丽倩&quot;);        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();        for (Entry&lt;String, String&gt; entry : entrySet) &#123;            System.out.println(entry.getKey() + &quot;  &quot; + entry.getValue());        &#125;    &#125;&#125;</code></pre><p>结果:</p><pre><code>邓超  孙俪李晨  范冰冰刘德华  朱丽倩</code></pre><h2 id="1-7-TreeMap集合"><a href="#1-7-TreeMap集合" class="headerlink" title="1.7 TreeMap集合"></a>1.7 TreeMap集合</h2><h3 id="1-TreeMap介绍"><a href="#1-TreeMap介绍" class="headerlink" title="1.TreeMap介绍"></a>1.TreeMap介绍</h3><p>TreeMap集合和Map相比没有特有的功能，底层的数据结构是红黑树；可以对元素的<em><strong>键</strong></em>进行排序，排序方式有两种:<strong>自然排序</strong>和<strong>比较器排序</strong>；到时使用的是哪种排序，取决于我们在创建对象的时候所使用的构造方法；</p><pre><code class="java">public TreeMap()                                    使用自然排序public TreeMap(Comparator&lt;? super K&gt; comparator)     比较器排</code></pre><h3 id="2-演示"><a href="#2-演示" class="headerlink" title="2.演示"></a>2.演示</h3><p>案例演示<strong>自然排序</strong></p><pre><code class="java">public static void main(String[] args) &#123;     TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();      map.put(1,&quot;张三&quot;);      map.put(4,&quot;赵六&quot;);      map.put(3,&quot;王五&quot;);      map.put(6,&quot;酒八&quot;);      map.put(5,&quot;老七&quot;);      map.put(2,&quot;李四&quot;);      System.out.println(map);&#125;控制台的输出结果为:&#123;1=张三, 2=李四, 3=王五, 4=赵六, 5=老七, 6=酒八&#125;</code></pre><p>案例演示<strong>比较器排序</strong></p><p><strong>需求:</strong></p><ol><li>创建一个TreeMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。</li><li>要求按照学生的年龄进行升序排序，如果年龄相同，比较姓名的首字母升序， 如果年龄和姓名都是相同，认为是同一个元素；</li></ol><p> <strong>实现:</strong></p><p>为了保证age和name相同的对象是同一个,Student类必须重写hashCode和equals方法</p><pre><code class="java">public class Student &#123;    private int age;    private String name;    //省略get/set..    public Student() &#123;&#125;    public Student(int age, String name) &#123;        this.age = age;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;age=&quot; + age +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Student student = (Student) o;        return age == student.age &amp;&amp;                Objects.equals(name, student.name);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(age, name);    &#125;&#125;</code></pre><pre><code class="java">public static void main(String[] args) &#123;      TreeMap&lt;Student, String&gt; map = new TreeMap&lt;Student, String&gt;(new Comparator&lt;Student&gt;() &#123;        @Override        public int compare(Student o1, Student o2) &#123;              //先按照年龄升序              int result = o1.getAge() - o2.getAge();              if (result == 0) &#123;                //年龄相同,则按照名字的首字母升序                return o1.getName().charAt(0) - o2.getName().charAt(0);              &#125; else &#123;                //年龄不同,直接返回结果                return result;              &#125;        &#125;      &#125;);      map.put(new Student(30, &quot;jack&quot;), &quot;深圳&quot;);      map.put(new Student(10, &quot;rose&quot;), &quot;北京&quot;);      map.put(new Student(20, &quot;tom&quot;), &quot;上海&quot;);      map.put(new Student(10, &quot;marry&quot;), &quot;南京&quot;);      map.put(new Student(30, &quot;lucy&quot;), &quot;广州&quot;);      System.out.println(map);&#125;控制台的输出结果为:&#123;  Student&#123;age=10, name=&#39;marry&#39;&#125;=南京,   Student&#123;age=10, name=&#39;rose&#39;&#125;=北京,   Student&#123;age=20, name=&#39;tom&#39;&#125;=上海,   Student&#123;age=30, name=&#39;jack&#39;&#125;=深圳,   Student&#123;age=30, name=&#39;lucy&#39;&#125;=广州&#125;</code></pre><h2 id="1-8-Map集合练习"><a href="#1-8-Map集合练习" class="headerlink" title="1.8 Map集合练习"></a>1.8 Map集合练习</h2><p><strong>需求：</strong></p><p>输入一个字符串中每个字符出现次数。</p><p><strong>分析：</strong></p><ol><li>获取一个字符串对象</li><li>创建一个Map集合，键代表字符，值代表次数。</li><li>遍历字符串得到每个字符。</li><li>判断Map中是否有该键。</li><li>如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li><li>打印最终结果</li></ol><p><strong>方法介绍</strong></p><p><code>public boolean containKey(Object key)</code>:判断该集合中是否有此键。</p><p><strong>代码：</strong></p><pre><code class="java">public class MapTest &#123;public static void main(String[] args) &#123;        //友情提示        System.out.println(&quot;请录入一个字符串:&quot;);        String line = new Scanner(System.in).nextLine();        // 定义 每个字符出现次数的方法        findChar(line);    &#125;    private static void findChar(String line) &#123;        //1:创建一个集合 存储  字符 以及其出现的次数        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();        //2:遍历字符串        for (int i = 0; i &lt; line.length(); i++) &#123;            char c = line.charAt(i);            //判断 该字符 是否在键集中            if (!map.containsKey(c)) &#123;//说明这个字符没有出现过                //那就是第一次                map.put(c, 1);            &#125; else &#123;                //先获取之前的次数                Integer count = map.get(c);                //count++;                //再次存入  更新                map.put(c, ++count);            &#125;        &#125;        System.out.println(map);    &#125;&#125;</code></pre><h1 id="第二章-模拟斗地主洗牌发牌"><a href="#第二章-模拟斗地主洗牌发牌" class="headerlink" title="第二章  模拟斗地主洗牌发牌"></a>第二章  模拟斗地主洗牌发牌</h1><h2 id="2-1-案例介绍"><a href="#2-1-案例介绍" class="headerlink" title="2.1 案例介绍"></a>2.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。</p><p><img src="/img/java/imgs6/%E6%96%97%E5%9C%B0%E4%B8%BB.png"></p><p>具体规则：</p><ol><li>组装54张扑克牌</li><li>54张牌顺序打乱</li><li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li><li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li></ol><blockquote><p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p></blockquote><h2 id="2-2-案例需求分析"><a href="#2-2-案例需求分析" class="headerlink" title="2.2 案例需求分析"></a>2.2 案例需求分析</h2><p>1.准备牌：</p><p>完成数字与纸牌的映射关系：</p><p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p><p>2.洗牌：</p><p>通过数字完成洗牌发牌</p><p>3.发牌：</p><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p><p>存放的过程中要求数字大小与斗地主规则的大小对应。</p><p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p><p>4.看牌：</p><p>通过Map集合找到对应字符展示。</p><p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p><p><img src="img/%E6%96%97%E5%9C%B0%E4%B8%BB%E5%88%86%E6%9E%90.png"></p><h2 id="2-3-实现代码步骤"><a href="#2-3-实现代码步骤" class="headerlink" title="2.3  实现代码步骤"></a>2.3  实现代码步骤</h2><pre><code class="java">package com.itheima04;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;/* * 组合牌 *       定义一个Map集合用来存储牌号  和 牌  *       定义一个List集合用来存储牌号 *      花色:♥-♠-♦-♣ *      数字:2-A-K-Q-J-10-9-8-7-6-5-4-3 * 洗牌 *         Collections.shuffle(牌号集合) * 发牌 *         三个玩家三个集合 *         发牌号  * 排序 * 看牌 */public class Pooker &#123;    public static void main(String[] args) &#123;        // 定义一个Map集合用来存储牌号  和 牌         Map&lt;Integer, String&gt; pookerMap = new HashMap&lt;Integer, String&gt;();        //定义一个List集合用来存储牌号        ArrayList&lt;Integer&gt; pookerList = new ArrayList&lt;Integer&gt;();                String[] colors = &quot;♥-♠-♦-♣&quot;.split(&quot;-&quot;);        String[] nums = &quot;2-A-K-Q-J-10-9-8-7-6-5-4-3&quot;.split(&quot;-&quot;);                        int index = 2;        for(String num : nums)&#123;            for(String color : colors)&#123;                String thisPooker = color+num;//                System.out.println(thisPooker);                //将扑克牌放入Map集合                pookerMap.put(index, thisPooker);                //将牌号放入到pookerList集合中                pookerList.add(index);                index++;            &#125;        &#125;                        //将大王小王添加到集合        pookerMap.put(0, &quot;大王&quot;);        pookerMap.put(1, &quot;小王&quot;);        pookerList.add(0);        pookerList.add(1);        //        System.out.println(pookerMap);//        System.out.println(pookerList);                //洗牌        Collections.shuffle(pookerList);                //发牌        ArrayList&lt;Integer&gt; player1 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; player2 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; player3 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; diPai = new ArrayList&lt;Integer&gt;();                //遍历牌号的集合 判断索引发牌号        for(int i = 0 ;i &lt; pookerList.size() ;i++)&#123;            Integer pookerNum = pookerList.get(i);                        if(i&gt;=51)&#123;                diPai.add(pookerNum);            &#125;else if(i % 3 == 0)&#123;                player1.add(pookerNum);            &#125;else if(i % 3 == 1)&#123;                player2.add(pookerNum);            &#125;else if(i % 3 == 2)&#123;                player3.add(pookerNum);            &#125;        &#125;                //        排序                Collections.sort(player1);        Collections.sort(player2);        Collections.sort(player3);        Collections.sort(diPai);//        System.out.println(player1);//        System.out.println(player2);//        System.out.println(player3);//        System.out.println(diPai);                show(&quot;张三&quot;,player1,pookerMap);        show(&quot;李四&quot;,player2,pookerMap);        show(&quot;王五&quot;,player3,pookerMap);        show(&quot;底牌&quot;,diPai,pookerMap);            &#125;    //定义方法 看牌    public static void show(String name,ArrayList&lt;Integer&gt; player,HashMap&lt;Integer, String&gt; pookerMap )&#123;        System.out.print(name+&quot;:&quot;);        for(Integer pookerNum : player)&#123;            String thisPooker = pookerMap.get(pookerNum);            System.out.print(thisPooker+&quot; &quot;);        &#125;        System.out.println();    &#125;&#125;</code></pre><h1 id="第三章-图书管理系统"><a href="#第三章-图书管理系统" class="headerlink" title="第三章 图书管理系统"></a>第三章 图书管理系统</h1><h2 id="3-1-图书管理系统项目演示"><a href="#3-1-图书管理系统项目演示" class="headerlink" title="3.1 图书管理系统项目演示"></a>3.1 图书管理系统项目演示</h2><p><img src="/img/java/imgs6/1543580142920.png" alt="1543580142920"></p><p><img src="/img/java/imgs6/1543580255773.png" alt="1543580255773"></p><p><img src="/img/java/imgs6/1543580374974.png" alt="1543580374974"></p><p><img src="/img/java/imgs6/1543580413991.png" alt="1543580413991"></p><p><img src="/img/java/imgs6/1543580469034.png" alt="1543580469034"></p><p><img src="/img/java/imgs6/1543580482970.png" alt="1543580482970"></p><p><strong>图书管理系统分析:</strong><br>1.定义Book类<br>2.完成主界面和选择<br>3.完成查询所有图书<br>4.完成添加图书<br>5.完成删除图书<br>6.完成修改图书<br>7.使用Debug追踪调试</p><h2 id="3-2-图书管理系统之标准Book类"><a href="#3-2-图书管理系统之标准Book类" class="headerlink" title="3.2 图书管理系统之标准Book类"></a>3.2 图书管理系统之标准Book类</h2><p><img src="/img/java/imgs6/1543582871305.png" alt="1543582871305"></p><p>我们发现每一本书都有书名和价格,定义一个Book类表示书籍</p><pre><code class="java">public class Book &#123;    private String name;    private double price;    public Book() &#123;    &#125;    public Book(String name, double price) &#123;        this.name = name;        this.price = price;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public double getPrice() &#123;        return price;    &#125;    public void setPrice(double price) &#123;        this.price = price;    &#125;&#125;</code></pre><h2 id="3-3-图书管理系统之主界面和选择的实现"><a href="#3-3-图书管理系统之主界面和选择的实现" class="headerlink" title="3.3 图书管理系统之主界面和选择的实现"></a>3.3 图书管理系统之主界面和选择的实现</h2><p><img src="/img/java/imgs6/1543580142920.png" alt="1543580142920"></p><p>主界面的内容其实就是通过打印语句打印出来的.但是要注意因为每个操作过后都会重新回到主界面,所以使用<code>while(true)</code>死循环的方式.</p><pre><code class="java">public class BookManager &#123;    public static void main(String[] args) &#123;        while (true) &#123;            //这是学生管理系统的主界面            System.out.println(&quot;--------欢迎来到学生管理系统--------&quot;);            System.out.println(&quot;1.查看所有书籍&quot;);            System.out.println(&quot;2.添加书&quot;);            System.out.println(&quot;3.删除书&quot;);            System.out.println(&quot;4.修改书&quot;);            System.out.println(&quot;5.退出&quot;);            System.out.println(&quot;请输入你的选择：&quot;);            //创建键盘录入对象            Scanner sc = new Scanner(System.in);            int num = sc.nextInt();            switch (num) &#123;                case 1:                    // 查看所有书籍                    break;                case 2:                    // 添加书籍                    break;                case 3:                    // 删除书                    break;                case 4:                    // 修改书                    break;                case 5:                    // 退出                    break;                default:                    System.out.println(&quot;输入错误,请重新输入&quot;);                    break;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="3-4-图书管理系统之查询所有图书"><a href="#3-4-图书管理系统之查询所有图书" class="headerlink" title="3.4 图书管理系统之查询所有图书"></a>3.4 图书管理系统之查询所有图书</h2><p><img src="/img/java/imgs6/1543582871305.png" alt="1543582871305"></p><pre><code class="java">public class BookManager &#123;    public static void main(String[] args) &#123;        Map&lt;String, ArrayList&lt;Book&gt;&gt; map = new HashMap&lt;&gt;();        // 创建集合对象，用于存储学生数据        ArrayList&lt;Book&gt; it = new ArrayList&lt;Book&gt;();        it.add(new Book(&quot;Java入门到精通&quot;, 99));        it.add(new Book(&quot;PHP入门到精通&quot;, 9.9));        map.put(&quot;it书籍&quot;, it);        ArrayList&lt;Book&gt; mz = new ArrayList&lt;Book&gt;();        mz.add(new Book(&quot;西游记&quot;, 19));        mz.add(new Book(&quot;水浒传&quot;, 29));        map.put(&quot;名著&quot;, mz);        while (true) &#123;            //这是学生管理系统的主界面            System.out.println(&quot;--------欢迎来到学生管理系统--------&quot;);            System.out.println(&quot;1.查看所有书籍&quot;);            System.out.println(&quot;2.添加书&quot;);            System.out.println(&quot;3.删除书&quot;);            System.out.println(&quot;4.修改书&quot;);            System.out.println(&quot;5.退出&quot;);            System.out.println(&quot;请输入你的选择：&quot;);            //创建键盘录入对象            Scanner sc = new Scanner(System.in);            int num = sc.nextInt();            switch (num) &#123;                case 1:                    // 查看所有书籍                    findAllBook(map);                    break;                case 2:                    // 添加书籍                    break;                case 3:                    // 删除书                    break;                case 4:                    // 修改书                    break;                case 5:                    // 退出                    System.out.println(&quot;谢谢你的使用&quot;);                    System.exit(0); // JVM退出                    break;                default:                    System.out.println(&quot;输入错误,请重新输入&quot;);                    break;            &#125;        &#125;    &#125;        private static void findAllBook(Map&lt;String, ArrayList&lt;Book&gt;&gt; map) &#123;        System.out.println(&quot;类型\t\t书名\t价格&quot;);        Set&lt;Map.Entry&lt;String, ArrayList&lt;Book&gt;&gt;&gt; entries = map.entrySet();        for (Map.Entry&lt;String, ArrayList&lt;Book&gt;&gt; entry : entries) &#123;            String key = entry.getKey();            System.out.println(key);            ArrayList&lt;Book&gt; value = entry.getValue();            for (Book book : value) &#123;                System.out.println(&quot;\t\t&quot; + book.getName() + &quot;\t&quot; + book.getPrice());            &#125;        &#125;    &#125;&#125;    </code></pre><h2 id="3-5-图书管理系统之添加图书"><a href="#3-5-图书管理系统之添加图书" class="headerlink" title="3.5 图书管理系统之添加图书"></a>3.5 图书管理系统之添加图书</h2><p><img src="/img/java/imgs6/1543580374974.png" alt="1543580374974"></p><pre><code class="java">private static void addBook(Map&lt;String, ArrayList&lt;Book&gt;&gt; map) &#123;    // 创建键盘录入对象    Scanner sc = new Scanner(System.in);    System.out.println(&quot;请输入要添加书籍的类型:&quot;);    String type = sc.next();    System.out.println(&quot;请输入要添加的书名:&quot;);    String name = sc.next();    System.out.println(&quot;请输入要添加书的价格:&quot;);    double price = sc.nextDouble();    Book book = new Book(name, price);    // 拿到书籍列表    ArrayList&lt;Book&gt; books = map.get(type);    if (books == null) &#123;        // 如果书籍列表不存在创建一个书籍列表        books = new ArrayList&lt;&gt;();        map.put(type, books);    &#125;    // 将书添加到集合中    books.add(book);    System.out.println(&quot;添加&quot; + name + &quot;成功&quot;);&#125;</code></pre><h2 id="3-6-图书管理系统之删除图书"><a href="#3-6-图书管理系统之删除图书" class="headerlink" title="3.6 图书管理系统之删除图书"></a>3.6 图书管理系统之删除图书</h2><p><img src="/img/java/imgs6/1543580413991.png" alt="1543580413991"></p><pre><code class="java">private static void deleteBook(Map&lt;String, ArrayList&lt;Book&gt;&gt; map) &#123;    // 创建键盘录入对象    Scanner sc = new Scanner(System.in);    System.out.println(&quot;请输入要删除书籍的类型:&quot;);    String type = sc.next();    System.out.println(&quot;请输入要删除的书名:&quot;);    String name = sc.next();    // 拿到书籍列表  ： 用Map集合的    ArrayList&lt;Book&gt; books = map.get(type);    if (books == null) &#123;        System.out.println(&quot;您删除的书籍类型不存在&quot;);        return;    &#125;    for (int i = 0; i &lt; books.size(); i++) &#123;        Book book = books.get(i);        if (book.getName().equals(name)) &#123;            books.remove(i); // 找到这本书,删除这本书            System.out.println(&quot;删除&quot; + name + &quot;书籍成功&quot;);            return; // 删除书籍后结束方法        &#125;    &#125;    System.out.println(&quot;没有找到&quot; + name + &quot;书籍&quot;);&#125;</code></pre><h2 id="3-7-图书管理系统之修改图书"><a href="#3-7-图书管理系统之修改图书" class="headerlink" title="3.7 图书管理系统之修改图书"></a>3.7 图书管理系统之修改图书</h2><p><img src="/img/java/imgs6/1543580469034.png" alt="1543580469034"></p><pre><code class="java">private static void editBook(Map&lt;String, ArrayList&lt;Book&gt;&gt; map) &#123;    // 创建键盘录入对象    Scanner sc = new Scanner(System.in);    System.out.println(&quot;请输入要修改书籍的类型:&quot;);    String type = sc.next();    System.out.println(&quot;请输入要修改的书名:&quot;);    String oldName = sc.next();    System.out.println(&quot;请输入新的书名:&quot;);    String newName = sc.next();    System.out.println(&quot;请输入新的价格:&quot;);    double price = sc.nextDouble();    // 拿到书籍列表    ArrayList&lt;Book&gt; books = map.get(type); // 根本不不像一个技术人员    if (books == null) &#123;        System.out.println(&quot;您修改的书籍类型不存在&quot;);        return;    &#125;    for (int i = 0; i &lt; books.size(); i++) &#123;        Book book = books.get(i);        if (book.getName().equals(oldName)) &#123;            // 找到这本书,修改这本书            book.setName(newName);            book.setPrice(price);            System.out.println(&quot;修改成功&quot;);            return; // 修改书籍后结束方法        &#125;    &#125;    System.out.println(&quot;没有找到&quot; + oldName + &quot;书籍&quot;);&#125;</code></pre><h2 id="3-8-Debug追踪调试"><a href="#3-8-Debug追踪调试" class="headerlink" title="3.8 Debug追踪调试"></a>3.8 Debug追踪调试</h2><p>之前我们看程序的执行流程都是通过<code>System.out.println();</code>但是有不能让程序执行到某条语句后<strong>停下来</strong>,也不能看到程序<strong>具体的执行步骤</strong>.而是执行完所有的语句程序结束了。</p><p><strong>断点调试可以查看程序的执行流程和暂停程序.可以快速解决程序中的bug</strong></p><p>Debug调试窗口介绍</p><p><img src="/img/java/imgs6%5Cdebug5.png"></p><h1 id="第四章-排序算法介绍"><a href="#第四章-排序算法介绍" class="headerlink" title="第四章 排序算法介绍"></a>第四章 排序算法介绍</h1><h2 id="4-1-冒泡排序"><a href="#4-1-冒泡排序" class="headerlink" title="4.1 冒泡排序"></a>4.1 冒泡排序</h2><h3 id="4-1-1-冒泡排序概述"><a href="#4-1-1-冒泡排序概述" class="headerlink" title="4.1.1 冒泡排序概述"></a>4.1.1 冒泡排序概述</h3><ul><li>一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序</li><li>如果有n个数据进行排序，总共需要比较n-1次</li><li>每一次比较完毕，下一次的比较就会少一个数据参与</li></ul><h3 id="4-1-2-冒泡排序图解"><a href="#4-1-2-冒泡排序图解" class="headerlink" title="4.1.2 冒泡排序图解"></a>4.1.2 冒泡排序图解</h3><p><img src="../../../../%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%E8%AF%BE%E6%94%B9/day01-day15%E8%AE%B2%E4%B9%89-MD/day07-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95,%E5%BC%82%E5%B8%B8,%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img/5.png" alt="5"></p><h3 id="4-1-3-冒泡排序代码实现"><a href="#4-1-3-冒泡排序代码实现" class="headerlink" title="4.1.3 冒泡排序代码实现"></a>4.1.3 冒泡排序代码实现</h3><pre><code class="java">/*    冒泡排序：        一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，        依次对所有的数据进行操作，直至所有数据按要求完成排序 */public class ArrayDemo &#123;    public static void main(String[] args) &#123;        //定义一个数组        int[] arr = &#123;7, 6, 5, 4, 3&#125;;        System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));        // 这里减1，是控制每轮比较的次数        for (int x = 0; x &lt; arr.length - 1; x++) &#123;            // -1是为了避免索引越界，-x是为了调高比较效率            for (int i = 0; i &lt; arr.length - 1 - x; i++) &#123;                if (arr[i] &gt; arr[i + 1]) &#123;                    int temp = arr[i];                    arr[i] = arr[i + 1];                    arr[i + 1] = temp;                &#125;            &#125;        &#125;        System.out.println(&quot;排序后：&quot; + Arrays.toString(arr));    &#125;&#125;</code></pre><h2 id="4-2-选择排序"><a href="#4-2-选择排序" class="headerlink" title="4.2 选择排序"></a>4.2 选择排序</h2><h3 id="4-2-1-选择排序概述"><a href="#4-2-1-选择排序概述" class="headerlink" title="4.2.1 选择排序概述"></a>4.2.1 选择排序概述</h3><ul><li>另外一种排序的方式，选中数组的某个元素,其后面的元素依次和选中的元素进行两两比较，将较大的数据放在后面，依次从前到后选中每个元素，直至所有数据按要求完成排序</li><li>如果有n个数据进行排序，总共需要比较n-1次</li><li>每一次比较完毕，下一次的比较就会少一个数据参与</li></ul><h3 id="4-2-2-选择排序图解"><a href="#4-2-2-选择排序图解" class="headerlink" title="4.2.2 选择排序图解"></a>4.2.2 选择排序图解</h3><p><img src="../../../../%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%E8%AF%BE%E6%94%B9/day01-day15%E8%AE%B2%E4%B9%89-MD/day07-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95,%E5%BC%82%E5%B8%B8,%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img/6.png" alt="5"></p><h3 id="4-2-3-选择排序代码实现"><a href="#4-2-3-选择排序代码实现" class="headerlink" title="4.2.3 选择排序代码实现"></a>4.2.3 选择排序代码实现</h3><pre><code class="java">/*    选择排序：        另外一种排序的方式，选中数组的某个元素,其后面的元素依次和选中的元素进行两两比较，将较大的数据放在后面，依次从前到后选中每个元素，直至所有数据按要求完成排序 */public class ArrayDemo &#123;    public static void main(String[] args) &#123;        //定义一个数组        int[] arr = &#123;7, 6, 5, 4, 3&#125;;        System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));          // 这里减1，是控制比较的轮数        for (int x = 0; x &lt; arr.length; x++) &#123;            // 从x+1开始,直到最后一个元素            for (int i = x+1; i &lt; arr.length; i++) &#123;                if (arr[x] &gt; arr[i]) &#123;                    int temp = arr[x];                    arr[x] = arr[i];                    arr[i] = temp;                &#125;            &#125;        &#125;        System.out.println(&quot;排序后：&quot; + Arrays.toString(arr));    &#125;&#125;</code></pre><h1 id="第五章-二分查找"><a href="#第五章-二分查找" class="headerlink" title="第五章 二分查找"></a>第五章 二分查找</h1><h2 id="5-1-普通查找和二分查找"><a href="#5-1-普通查找和二分查找" class="headerlink" title="5.1 普通查找和二分查找"></a>5.1 普通查找和二分查找</h2><p><strong>普通查找</strong></p><p>原理：遍历数组，获取每一个元素，然后判断当前遍历的元素是否和要查找的元素相同，如果相同就返回该元素的索引。如果没有找到，就返回一个负数作为标识(一般是-1)</p><p><strong>二分查找</strong></p><p>原理: 每一次都去获取数组的中间索引所对应的元素，然后和要查找的元素进行比对，如果相同就返回索引；</p><p>如果不相同，就比较中间元素和要查找的元素的值；</p><p>如果中间元素的值大于要查找的元素，说明要查找的元素在左侧，那么就从左侧按照上述思想继续查询(忽略右侧数据)；</p><p>如果中间元素的值小于要查找的元素，说明要查找的元素在右侧，那么就从右侧按照上述思想继续查询(忽略左侧数据)；</p><p><strong>二分查找对数组是有要求的,数组必须已经排好序</strong></p><h2 id="5-2-二分查找图解"><a href="#5-2-二分查找图解" class="headerlink" title="5.2 二分查找图解"></a>5.2 二分查找图解</h2><p>假设有一个给定有序数组(10,14,21,38,45,47,53,81,87,99),要查找50出现的索引</p><p>则查询过程如下图所示:</p><p><img src="../../../../%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%E8%AF%BE%E6%94%B9/day01-day15%E8%AE%B2%E4%B9%89-MD/day07-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95,%E5%BC%82%E5%B8%B8,%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img/7.png" alt="5"></p><h2 id="5-3-二分查找代码实现"><a href="#5-3-二分查找代码实现" class="headerlink" title="5.3 二分查找代码实现"></a>5.3 二分查找代码实现</h2><pre><code class="java">    public static void main(String[] args) &#123;        int[] arr = &#123;10, 14, 21, 38, 45, 47, 53, 81, 87, 99&#125;;        int index = binarySerach(arr, 38);        System.out.println(index);    &#125;    /**     * 二分查找方法     * @param arr 查找的目标数组     * @param number 查找的目标值     * @return 找到的索引,如果没有找到返回-1     */    public static int binarySerach(int[] arr, int number) &#123;        int start = 0;        int end = arr.length - 1;        while (start &lt;= end) &#123;            int mid = (start + end) / 2;            if (number == arr[mid]) &#123;                return mid + 1;            &#125; else if (number &lt; arr[mid]) &#123;                end = mid - 1;            &#125; else if (number &gt; arr[mid]) &#123;                start = mid + 1;            &#125;        &#125;        return -1;  //如果数组中有这个元素，则返回    &#125;</code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day06【Map】&quot;&gt;&lt;a href=&quot;#day06【Map】&quot; class=&quot;headerlink&quot; title=&quot;day06【Map】&quot;&gt;&lt;/a&gt;day06【Map】&lt;/h1&gt;&lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;head</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java进阶13天资料" scheme="http://example.com/tags/java%E8%BF%9B%E9%98%B613%E5%A4%A9%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Day05</title>
    <link href="http://example.com/2021/09/05/JAVA/day05-%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84,List,Set%20,TreeSet%E9%9B%86%E5%90%88,Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://example.com/2021/09/05/JAVA/day05-%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84,List,Set%20,TreeSet%E9%9B%86%E5%90%88,Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2021-09-05T02:34:46.000Z</published>
    <updated>2021-09-05T03:04:37.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day05【迭代器，数据结构-List-Set-TreeSet集合-Collections工具类】"><a href="#day05【迭代器，数据结构-List-Set-TreeSet集合-Collections工具类】" class="headerlink" title="day05【迭代器，数据结构,List,Set ,TreeSet集合,Collections工具类】"></a>day05【迭代器，数据结构,List,Set ,TreeSet集合,Collections工具类】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>Collection集合的遍历方式:</li></ul><ul><li>迭代器。<ul><li>foreach(增强for循环)</li><li>JDK 1.8开始的新技术Lambda表达式。</li></ul></li></ul><ul><li>数据结构<ul><li>是集合的底层，研究数据结构是为了选择使用某种集合。</li></ul></li><li>List接口<ul><li>元素是有序可重复有索引的。</li></ul></li><li>Set接口<ul><li>元素是无序不重复无索引的。</li></ul></li><li>Collections是操作集合的工具类。</li><li>把学的集合用起来：斗地主的游戏。</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><p><input disabled="" type="checkbox">  能够使用迭代器对集合进行取元素</p><ul><li><input disabled="" type="checkbox"> <pre><code class="java">Iterator&lt;String&gt; it = names.iterator();while(it.hasNext())&#123;    String rs = it.next();    System.out.println(rs);&#125;</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  能够说出List集合特点</p><ul><li><input disabled="" type="checkbox"> <strong>元素是有序，可重复的，有索引的，底层是基于数组存储元素的，查询快，增删慢！</strong></li></ul></li><li><p><input disabled="" type="checkbox">  能够说出常见的数据结构</p><ul><li><input disabled="" type="checkbox"> <strong>队列： 先进先出</strong></li><li><input disabled="" type="checkbox"> <strong>栈：先进后出，后进先出</strong></li><li><input disabled="" type="checkbox"> 数组：底层是连续内存区域，查询快，增删慢！</li><li><input disabled="" type="checkbox"> <strong>链表：元素是游离存储的，查询慢，首尾操作快！</strong></li><li><input disabled="" type="checkbox"> 红黑树 （HastSet ）：增删改查都很好，可以排序，可以提高检索数据的性能！</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出数组结构特点</p><ul><li><input disabled="" type="checkbox"> <strong>内存中的连续区域，每个区间大小固定，查询快，增删慢!</strong></li></ul></li><li><p><input disabled="" type="checkbox">  能够说出栈结构特点</p><ul><li><input disabled="" type="checkbox"> 先进后出。</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出队列结构特点</p><ul><li><input disabled="" type="checkbox"> 先进先出</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出单向链表结构特点</p><ul><li><input disabled="" type="checkbox"> 元素是游离存储的，查询慢, 一端的增删操作快！</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出Set集合的特点</p><ul><li><input disabled="" type="checkbox"> 元素是无序，不重复，无索引，底层是基于哈希表存储元素的，曾删查的性能都很好！！</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出哈希表的特点</p><ul><li><input disabled="" type="checkbox"> JDK 1.8之前是：链表+数组</li><li><input disabled="" type="checkbox"> JDK 1.8之后是：链表+数组+红黑树</li></ul></li><li><p><input disabled="" type="checkbox">  使用HashSet集合存储自定义元素</p><ul><li><input disabled="" type="checkbox"> Set<Apple> sets = new HashSet&lt;&gt;();</li></ul></li></ul><h1 id="第一章-Iterator迭代器"><a href="#第一章-Iterator迭代器" class="headerlink" title="第一章 Iterator迭代器"></a>第一章 Iterator迭代器</h1><h2 id="1-1-Iterator接口"><a href="#1-1-Iterator接口" class="headerlink" title="1.1 Iterator接口"></a>1.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>下面介绍一下迭代的概念：</p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p><pre><code class="java">public class IteratorDemo &#123;      public static void main(String[] args) &#123;        // 使用多态方式 创建对象        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();        // 添加元素到集合        coll.add(&quot;串串星人&quot;);        coll.add(&quot;吐槽星人&quot;);        coll.add(&quot;汪星人&quot;);        //遍历        //使用迭代器 遍历   每个集合对象都有自己的迭代器        Iterator&lt;String&gt; it = coll.iterator();        //  泛型指的是 迭代出 元素的数据类型        while(it.hasNext())&#123; //判断是否有迭代元素            String s = it.next();//获取迭代出的元素            System.out.println(s);        &#125;      &#125;&#125;</code></pre><blockquote><p>tips: </p><ol><li>在进行集合元素获取时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会抛出java.util.NoSuchElementException没有集合元素异常。</li><li>在进行集合元素获取时，如果添加或移除集合中的元素 , 将无法继续迭代 , 将会抛出ConcurrentModificationException并发修改异常.</li></ol></blockquote><h2 id="1-2-迭代器的实现原理"><a href="#1-2-迭代器的实现原理" class="headerlink" title="1.2 迭代器的实现原理"></a>1.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p><p><img src="/img/java/imgs5%5C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.bmp"></p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h1 id="第二章-数据结构"><a href="#第二章-数据结构" class="headerlink" title="第二章 数据结构"></a>第二章 数据结构</h1><h2 id="2-1-数据结构介绍"><a href="#2-1-数据结构介绍" class="headerlink" title="2.1 数据结构介绍"></a>2.1 数据结构介绍</h2><p>数据结构 : 数据用什么样的方式组合在一起。</p><h2 id="2-2-常见数据结构"><a href="#2-2-常见数据结构" class="headerlink" title="2.2 常见数据结构"></a>2.2 常见数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li></ul><p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p><ul><li>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</li><li>栈的入口、出口的都是栈的顶端位置。</li></ul><p>这里两个名词需要注意：</p><ul><li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li><li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li></ul><p><img src="img/%E9%98%9F%E5%88%97.png"></p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li></ul><p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p><p><img src="img/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png"></p></li><li><p>增删元素慢</p></li><li><p><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图<img src="img/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0.png"></p></li><li><p><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图<img src="img/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4.png"></p></li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p><p><img src="img/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png"></p></li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p></li><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p></li><li><p>增删元素快：</p><p><img src="img/%E9%93%BE%E8%A1%A8.png">树数据结构</p><p>树是有很多节点组成的</p></li></ul><h2 id="2-3-树基本结构介绍"><a href="#2-3-树基本结构介绍" class="headerlink" title="2.3. 树基本结构介绍"></a>2.3. 树基本结构介绍</h2><p>树具有的特点：</p><ol><li>每一个节点有零个或者多个子节点</li><li>没有父节点的节点称之为根节点，<strong>一个树最多有一个根节点。</strong></li><li>每一个非根节点有且只有一个父节点</li></ol><p><img src="img/1562637870270.png" alt="1562637870270"> </p><table><thead><tr><th>名词</th><th>含义</th></tr></thead><tbody><tr><td>节点</td><td>指树中的一个元素</td></tr><tr><td>节点的度</td><td>节点拥有的子树的个数，二叉树的度不大于2</td></tr><tr><td>叶子节点</td><td>度为0的节点，也称之为终端结点</td></tr><tr><td>高度</td><td>叶子结点的高度为1，叶子结点的父节点高度为2，以此类推，根节点的高度最高</td></tr><tr><td>层</td><td>根节点在第一层，以此类推</td></tr><tr><td>父节点</td><td>若一个节点含有子节点，则这个节点称之为其子节点的父节点</td></tr><tr><td>子节点</td><td>子节点是父节点的下一层节点</td></tr><tr><td>兄弟节点</td><td>拥有共同父节点的节点互称为兄弟节点</td></tr></tbody></table><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>如果树中的每个节点的子节点的个数不超过2，那么该树就是一个二叉树。</p><p><img src="img/1565609702432.png" alt="1565609702432"></p><h3 id="二叉查找树-二叉排序树"><a href="#二叉查找树-二叉排序树" class="headerlink" title="二叉查找树/二叉排序树"></a>二叉查找树/二叉排序树</h3><p>二叉查找树的特点：</p><ol><li>左子树上所有的节点的值均小于等于他的根节点的值</li><li>右子树上所有的节点值均大于或者等于他的根节点的值</li><li>每一个子节点最多有两个子树</li></ol><p>案例演示(20,18,23,22,17,24,19)数据的存储过程；</p><p><img src="img/1565611710800.png" alt="1565611710800"></p><p><strong>增删改查的性能都很高！！！</strong></p><p>遍历获取元素的时候可以按照”左中右”的顺序进行遍历；</p><p>注意：二叉查找树存在的问题：会出现”瘸子”的现象，影响查询效率。</p><p><img src="img/1565611927771.png" alt="1565611927771"></p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>（基于查找二叉树，但是让树不要太高，尽量让树的元素均衡分布。这样综合性能就高了）</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>为了避免出现”瘸子”的现象，减少树的高度，提高我们的搜素效率，又存在一种树的结构：”平衡二叉树”</p><p>规则：<strong>它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</strong></p><p>如下图所示：</p><p><img src="img/1562642409744.png" alt="1565611927771"></p><p>如下图所示，左图是一棵平衡二叉树，根节点10，左右两子树的高度差是1，而右图，虽然根节点左右两子树高度差是0，但是右子树15的左右子树高度差为2，不符合定义，</p><p>所以右图不是一棵平衡二叉树。</p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>在构建一棵平衡二叉树的过程中，当有新的节点要插入时，检查是否因插入后而破坏了树的平衡，如果是，则需要做旋转去改变树的结构。</p><p>左旋：</p><p><strong>左旋就是将节点的右支往左拉，右子节点变成父节点，并把晋升之后多余的左子节点出让给降级节点的右子节点；</strong></p><p><img src="img/%E5%B7%A6%E6%97%8B.png"></p><p>右旋：</p><p><strong>将节点的左支往右拉，左子节点变成了父节点，并把晋升之后多余的右子节点出让给降级节点的左子节点</strong></p><p><img src="img/%E5%8F%B3%E6%97%8B.png"></p><p>举个例子，像上图是否平衡二叉树的图里面，左图在没插入前”19”节点前，该树还是平衡二叉树，但是在插入”19”后，导致了”15”的左右子树失去了”平衡”，</p><p>所以此时可以将”15”节点进行左旋，让”15”自身把节点出让给”17”作为”17”的左树，使得”17”节点左右子树平衡，而”15”节点没有子树，左右也平衡了。如下图，</p><p><img src="img/1562644020804.png" alt="1562644020804"> </p><p>由于在构建平衡二叉树的时候，当有<strong>新节点插入</strong>时，都会判断插入后时候平衡，这说明了插入新节点前，都是平衡的，也即高度差绝对值不会超过1。当新节点插入后，</p><p>有可能会有导致树不平衡，这时候就需要进行调整，而可能出现的情况就有4种，分别称作<strong>左左，左右，右左，右右</strong>。</p><h5 id="左左"><a href="#左左" class="headerlink" title="左左"></a>左左</h5><p>左左即为在原来平衡的二叉树上，在节点的左子树的左子树下，有新节点插入，导致节点的左右子树的高度差为2，如下即为”10”节点的左子树”7”，的左子树”4”，插入了节点”5”或”3”导致失衡。</p><p><img src="img/1562644117681.png" alt="1562644117681"> </p><p>左左调整其实比较简单，只需要对节点进行右旋即可，如下图，对节点”10”进行右旋，</p><p><img src="img/1562645661857.png" alt="1562645661857"> </p><p><img src="img/1562645709201.png" alt="1562645709201"> </p><h5 id="左右"><a href="#左右" class="headerlink" title="左右"></a>左右</h5><p>左右即为在原来平衡的二叉树上，在节点的左子树的右子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”11”节点的左子树”7”，的右子树”9”，</p><p>插入了节点”10”或”8”导致失衡。</p><p><img src="img/1562644916480.png" alt="1562644916480"> </p><p>左右的调整就不能像左左一样，进行一次旋转就完成调整。我们不妨先试着让左右像左左一样对”11”节点进行右旋，结果图如下，右图的二叉树依然不平衡，而右图就是接下来要</p><p>讲的右左，即左右跟右左互为镜像，左左跟右右也互为镜像。</p><p><img src="img/1562645170454.png" alt="1562645170454"> </p><p>左右这种情况，进行一次旋转是不能满足我们的条件的，正确的调整方式是，将左右进行第一次旋转，将左右先调整成左左，然后再对左左进行调整，从而使得二叉树平衡。</p><p>即先对上图的节点”7”进行左旋，使得二叉树变成了左左，之后再对”11”节点进行右旋，此时二叉树就调整完成，如下图:</p><p><img src="img/1562645351977.png" alt="1562645351977"> </p><h5 id="右左"><a href="#右左" class="headerlink" title="右左"></a>右左</h5><p>右左即为在原来平衡的二叉树上，在节点的右子树的左子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”11”节点的右子树”15”，的左子树”13”，</p><p>插入了节点”12”或”14”导致失衡。</p><p><img src="img/1562645765291.png" alt="1562645765291"> </p><p>前面也说了，右左跟左右其实互为镜像，所以调整过程就反过来，先对节点”15”进行右旋，使得二叉树变成右右，之后再对”11”节点进行左旋，此时二叉树就调整完成，如下图:</p><p><img src="img/1562645894833.png" alt="1562645894833"> </p><h5 id="右右"><a href="#右右" class="headerlink" title="右右"></a>右右</h5><p>右右即为在原来平衡的二叉树上，在节点的右子树的右子树下，有新节点插入，导致节点的左右子树的高度差为2，如下即为”11”节点的右子树”13”，的左子树”15”，插入了节点</p><p>“14”或”19”导致失衡。</p><p><img src="img/1562645951703.png" alt="1562645951703"> </p><p>右右只需对节点进行一次左旋即可调整平衡，如下图，对”11”节点进行左旋。</p><p><img src="img/1562646135227.png" alt="1562646135227"> </p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>就是平衡的二叉查找树！！</p><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构，它是在1972年由Rudolf Bayer发明的，当时被称之为平衡二叉B树，后来，在1978年被</p><p>Leoj.Guibas和Robert Sedgewick修改为如今的”红黑树”。它是一种特殊的二叉查找树，红黑树的每一个节点上都有存储位表示节点的颜色，可以是红或者黑；</p><p>红黑树不是高度平衡的，它的平衡是通过”红黑树的特性”进行实现的；</p><p>红黑树的特性：</p><ol><li>每一个节点或是红色的，或者是黑色的。</li><li>根节点必须是黑色</li><li>每个叶节点(Nil)是黑色的；（如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点）</li><li>如果某一个节点是红色，那么它的子节点必须是黑色(不能出现两个红色节点相连的情况)</li><li>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点；</li></ol><p>如下图所示就是一个</p><p><img src="img/1562653205543.png" alt="1562653205543"> </p><p>在进行元素插入的时候，和之前一样； 每一次插入完毕以后，使用黑色规则进行校验，如果不满足红黑规则，就需要通过变色，左旋和右旋来调整树，使其满足红黑规则；</p><h1 id="第三章-List接口"><a href="#第三章-List接口" class="headerlink" title="第三章 List接口"></a>第三章 List接口</h1><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p><p>接下来，我们一起学习Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p><h2 id="3-1-List接口介绍"><a href="#3-1-List接口介绍" class="headerlink" title="3.1 List接口介绍"></a>3.1 List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><p>看完API，我们总结一下：</p><p>List接口特点：</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><blockquote><p>tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p></blockquote><h2 id="3-2-List接口中常用方法"><a href="#3-2-List接口中常用方法" class="headerlink" title="3.2 List接口中常用方法"></a>3.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>List集合特有的方法都是跟索引相关，我们在基础班都学习过。</p><blockquote><p>tips:我们之前学习Colletion体系的时候，发现List集合下有很多集合，它们的存储结构不同，这样就导致了这些集合它们有各自的特点，供我们在不同的环境下使用，那么常见的数据结构有哪些呢？在下一章我们来介绍：</p></blockquote><h2 id="3-3-ArrayList集合"><a href="#3-3-ArrayList集合" class="headerlink" title="3.3 ArrayList集合"></a>3.3 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p><h2 id="3-4-LinkedList集合"><a href="#3-4-LinkedList集合" class="headerlink" title="3.4 LinkedList集合"></a>3.4 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><blockquote><p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p></blockquote><p><img src="img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为<strong>了解即可</strong>：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。</p><pre><code class="java">public class Demo04LinkedList &#123;    public static void main(String[] args) &#123;        method4();    &#125;    /*     *  void push(E e)： 压入。把元素添加到集合的第一个位置。     *  E pop()： 弹出。把第一个元素删除，然后返回这个元素。     */    public static void method4() &#123;        //创建LinkedList对象        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();        //添加元素        list.add(&quot;达尔文&quot;);        list.add(&quot;达芬奇&quot;);        list.add(&quot;达尔优&quot;);        System.out.println(&quot;list:&quot; + list);        //调用push在集合的第一个位置添加元素        //list.push(&quot;爱迪生&quot;);        //System.out.println(&quot;list:&quot; + list);//[爱迪生, 达尔文, 达芬奇, 达尔优]                //E pop()： 弹出。把第一个元素删除，然后返回这个元素。        String value = list.pop();        System.out.println(&quot;value:&quot; + value);//达尔文        System.out.println(&quot;list:&quot; + list);//[达芬奇，达尔优]    &#125;        /*     * E removeFirst()：删除第一个元素     * E removeLast()：删除最后一个元素。     */    public static void method3() &#123;        //创建LinkedList对象        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();        //添加元素        list.add(&quot;达尔文&quot;);        list.add(&quot;达芬奇&quot;);        list.add(&quot;达尔优&quot;);        //删除集合的第一个元素//        String value = list.removeFirst();//        System.out.println(&quot;value:&quot; + value);//达尔文//        System.out.println(&quot;list:&quot; + list);//[达芬奇，达尔优]                //删除最后一个元素        String value = list.removeLast();        System.out.println(&quot;value:&quot; + value);//达尔优        System.out.println(&quot;list:&quot; + list);//[达尔文， 达芬奇]    &#125;        /*     * E getFirst()： 获取集合中的第一个元素     * E getLast()： 获取集合中的最后一个元素     */    public static void method2() &#123;        //创建LinkedList对象        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();        //添加元素        list.add(&quot;达尔文&quot;);        list.add(&quot;达芬奇&quot;);        list.add(&quot;达尔优&quot;);                System.out.println(&quot;list:&quot; + list);        //获取集合中的第一个元素        System.out.println(&quot;第一个元素是：&quot; + list.getFirst());        //获取集合中的最后一个元素怒        System.out.println(&quot;最后一个元素是：&quot; + list.getLast());    &#125;             /*     * void addFirst(E e)： 在集合的开头位置添加元素。     * void addLast(E e)： 在集合的尾部添加元素。     */    public static void method1() &#123;        //创建LinkedList对象        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();        //添加元素        list.add(&quot;达尔文&quot;);        list.add(&quot;达芬奇&quot;);        list.add(&quot;达尔优&quot;);        //打印这个集合        System.out.println(&quot;list:&quot; + list);//[达尔文, 达芬奇, 达尔优]        //调用addFirst添加元素        list.addFirst(&quot;曹操&quot;);        System.out.println(&quot;list:&quot; + list);//[曹操, 达尔文, 达芬奇, 达尔优]        //调用addLast方法添加元素        list.addLast(&quot;大乔&quot;);        System.out.println(&quot;list:&quot; + list);//[曹操, 达尔文, 达芬奇, 达尔优, 大乔]            &#125;&#125;</code></pre><h1 id="第四章-Set接口"><a href="#第四章-Set接口" class="headerlink" title="第四章 Set接口"></a>第四章 Set接口</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口都会以某种规则保证存入的元素不出现重复。</p><p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>、<code>java.util.TreeSet</code>这两个集合。</p><blockquote><p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p></blockquote><h2 id="4-1-HashSet集合介绍"><a href="#4-1-HashSet集合介绍" class="headerlink" title="4.1 HashSet集合介绍"></a>4.1 HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不能保证不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存储和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p><pre><code class="java">public class HashSetDemo &#123;    public static void main(String[] args) &#123;        //创建 Set集合        HashSet&lt;String&gt;  set = new HashSet&lt;String&gt;();        //添加元素        set.add(new String(&quot;cba&quot;));        set.add(&quot;abc&quot;);        set.add(&quot;bac&quot;);         set.add(&quot;cba&quot;);          //遍历        for (String name : set) &#123;            System.out.println(name);        &#125;    &#125;&#125;</code></pre><p>输出结果如下，说明集合中不能存储重复元素：</p><pre><code>cbaabcbac</code></pre><blockquote><p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p></blockquote><h2 id="4-2-HashSet集合存储数据的结构（哈希表）"><a href="#4-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="4.2  HashSet集合存储数据的结构（哈希表）"></a>4.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p><p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用数组处理冲突，同一hash值的链表都存储在一个数组里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<img src="assets/%E5%93%88%E5%B8%8C%E8%A1%A8.png"> </p><p>看到这张图就有人要问了，这个是怎么存储的呢？</p><p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p><p><img src="img/%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p><h2 id="4-3-HashSet存储自定义类型元素"><a href="#4-3-HashSet存储自定义类型元素" class="headerlink" title="4.3  HashSet存储自定义类型元素"></a>4.3  HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一.</p><p>创建自定义Student类:</p><pre><code class="java">public class Student &#123;    private String name;    private int age;    //get/set    @Override    public boolean equals(Object o) &#123;        if (this == o)            return true;        if (o == null || getClass() != o.getClass())            return false;        Student student = (Student) o;        return age == student.age &amp;&amp;               Objects.equals(name, student.name);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(name, age);    &#125;&#125;</code></pre><p>创建测试类:</p><pre><code class="java">public class HashSetDemo2 &#123;    public static void main(String[] args) &#123;        //创建集合对象   该集合中存储 Student类型对象        HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;();        //存储         Student stu = new Student(&quot;于谦&quot;, 43);        stuSet.add(stu);        stuSet.add(new Student(&quot;郭德纲&quot;, 44));        stuSet.add(new Student(&quot;于谦&quot;, 43));        stuSet.add(new Student(&quot;郭麒麟&quot;, 23));        stuSet.add(stu);        for (Student stu2 : stuSet) &#123;            System.out.println(stu2);        &#125;    &#125;&#125;执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23]</code></pre><h2 id="4-4-LinkedHashSet"><a href="#4-4-LinkedHashSet" class="headerlink" title="4.4 LinkedHashSet"></a>4.4 LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><p>演示代码如下:</p><pre><code class="java">public class LinkedHashSetDemo &#123;    public static void main(String[] args) &#123;        Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;();        set.add(&quot;bbb&quot;);        set.add(&quot;aaa&quot;);        set.add(&quot;abc&quot;);        set.add(&quot;bbc&quot;);        Iterator&lt;String&gt; it = set.iterator();        while (it.hasNext()) &#123;            System.out.println(it.next());        &#125;    &#125;&#125;结果：  bbb  aaa  abc  bbc</code></pre><h2 id="4-5-TreeSet集合"><a href="#4-5-TreeSet集合" class="headerlink" title="4.5 TreeSet集合"></a>4.5 TreeSet集合</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><p>TreeSet集合是Set接口的一个实现类,底层依赖于TreeMap,是一种基于<strong>红黑树</strong>的实现,其特点为：</p><ol><li>元素唯一</li><li>元素没有索引</li><li>使用元素的<a href="../../java/lang/Comparable.html">自然顺序</a>对元素进行排序，或者根据创建 TreeSet 时提供的 <a href="../../java/util/Comparator.html"><code>Comparator</code></a> 比较器<br>进行排序，具体取决于使用的构造方法：</li></ol><pre><code class="java">public TreeSet()：                                根据其元素的自然排序进行排序public TreeSet(Comparator&lt;E&gt; comparator):    根据指定的比较器进行排序</code></pre><h3 id="2-演示"><a href="#2-演示" class="headerlink" title="2. 演示"></a>2. 演示</h3><p>案例演示<strong>自然排序</strong>(20,18,23,22,17,24,19):</p><pre><code class="java">public static void main(String[] args) &#123;    //无参构造,默认使用元素的自然顺序进行排序    TreeSet&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;();    set.add(20);    set.add(18);      set.add(23);      set.add(22);      set.add(17);      set.add(24);      set.add(19);      System.out.println(set);&#125;控制台的输出结果为:[17, 18, 19, 20, 22, 23, 24]</code></pre><p>案例演示<strong>比较器排序</strong>(20,18,23,22,17,24,19):</p><pre><code class="java">public static void main(String[] args) &#123;      //有参构造,传入比较器,使用比较器对元素进行排序      TreeSet&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;(new Comparator&lt;Integer&gt;() &#123;        @Override        public int compare(Integer o1, Integer o2) &#123;              //元素前 - 元素后 : 升序              //元素后 - 元素前 : 降序              return o2 - o1;        &#125;      &#125;);      set.add(20);      set.add(18);      set.add(23);      set.add(22);      set.add(17);      set.add(24);      set.add(19);      System.out.println(set);&#125;控制台的输出结果为:[24, 23, 22, 20, 19, 18, 17]</code></pre><h1 id="第五章-Collections类"><a href="#第五章-Collections类" class="headerlink" title="第五章  Collections类"></a>第五章  Collections类</h1><h2 id="5-1-Collections常用功能"><a href="#5-1-Collections常用功能" class="headerlink" title="5.1 Collections常用功能"></a>5.1 Collections常用功能</h2><ul><li><p><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。</p><p>常用方法如下：</p></li><li><p><code>public static void shuffle(List&lt;?&gt; list) </code>:打乱集合顺序。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</p></li></ul><p>代码演示：</p><pre><code class="java">public class CollectionsDemo &#123;    public static void main(String[] args) &#123;        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();           list.add(100);        list.add(300);        list.add(200);        list.add(50);        //排序方法         Collections.sort(list);        System.out.println(list);    &#125;&#125;结果：[50,100, 200, 300]</code></pre><p>我们的集合按照默认的自然顺序进行了排列，如果想要指定顺序那该怎么办呢？</p><h2 id="5-2-Comparator比较器"><a href="#5-2-Comparator比较器" class="headerlink" title="5.2 Comparator比较器"></a>5.2 Comparator比较器</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p><p>Student 类</p><pre><code class="java">public class Student&#123;    private String name;    private int age;    //构造方法    //get/set     //toString&#125;</code></pre><p>测试类：</p><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        // 创建四个学生对象 存储到集合中        ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;();        list.add(new Student(&quot;rose&quot;,18));        list.add(new Student(&quot;jack&quot;,16));        list.add(new Student(&quot;abc&quot;,20));        Collections.sort(list, new Comparator&lt;Student&gt;() &#123;            @Override            public int compare(Student o1, Student o2) &#123;            return o1.getAge()-o2.getAge();//以学生的年龄升序            &#125;        &#125;);        for (Student student : list) &#123;            System.out.println(student);        &#125;    &#125;&#125;Student&#123;name=&#39;jack&#39;, age=16&#125;Student&#123;name=&#39;rose&#39;, age=18&#125;Student&#123;name=&#39;abc&#39;, age=20&#125;</code></pre><h2 id="5-3-可变参数"><a href="#5-3-可变参数" class="headerlink" title="5.3 可变参数"></a>5.3 可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化.</p><p><strong>格式：</strong></p><pre><code>修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</code></pre><p><strong>代码演示:</strong></p><pre><code class="java">  public class ChangeArgs &#123;    public static void main(String[] args) &#123;        int sum = getSum(6, 7, 2, 12, 2121);        System.out.println(sum);    &#125;        public static int getSum(int... arr) &#123;           int sum = 0;            for (int a : arr) &#123;         sum += a;        &#125;            return sum;    &#125;&#125;</code></pre><p><strong>注意：</strong></p><p>​    1.一个方法只能有一个可变参数</p><p>​    2.如果方法中有多个参数，可变参数要放到最后。</p><p><strong>应用场景: Collections</strong></p><p>​    在Collections中也提供了添加一些元素方法：</p><p>​    <code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</p><p><strong>代码演示:</strong></p><pre><code class="java">public class CollectionsDemo &#123;    public static void main(String[] args) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();      //原来写法      //list.add(12);      //list.add(14);      //list.add(15);      //list.add(1000);      //采用工具类 完成 往集合中添加元素        Collections.addAll(list, 5, 222, 1，2);      System.out.println(list);&#125;</code></pre><h1 id="第六章-集合综合案例"><a href="#第六章-集合综合案例" class="headerlink" title="第六章 集合综合案例"></a>第六章 集合综合案例</h1><h2 id="6-1-案例介绍"><a href="#6-1-案例介绍" class="headerlink" title="6.1 案例介绍"></a>6.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p><p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p><h2 id="6-2-案例分析"><a href="#6-2-案例分析" class="headerlink" title="6.2 案例分析"></a>6.2 案例分析</h2><ul><li><p>准备牌：</p><p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p></li><li><p>发牌</p><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p></li><li><p>看牌</p><p>直接打印每个集合。</p></li></ul><h2 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h2><ol><li>Poker.java</li></ol><pre><code class="java">public class Poker &#123;    private String name;    public Poker() &#123;    &#125;    public Poker(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;&#123;&quot; + name + &quot;&#125;&quot;;    &#125;&#125;</code></pre><p>2 测试类</p><pre><code class="java">public class Demo12 &#123;    public static void main(String[] args) &#123;        // 创建一个ArrayList用于存放一副牌        ArrayList&lt;Poker&gt; pokers = new ArrayList&lt;&gt;();        pokers.add(new Poker(&quot;大王&quot;, &quot;&quot;));        pokers.add(new Poker(&quot;小王&quot;, &quot;&quot;));        String[] colors = new String[] &#123;&quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot;&#125;;        String[] numbers = new String[] &#123;&quot;2&quot;, &quot;A&quot;, &quot;K&quot;, &quot;Q&quot;, &quot;J&quot;, &quot;10&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;&#125;;        // 组合牌, 嵌套循环的流程:外循环一次,内循环所有次        // 2.使用嵌套循环生成一副牌        for (String n : numbers) &#123;            // &quot;2&quot;, &quot;A&quot;            for (String c : colors) &#123;                // &quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot;                Poker p = new Poker(c, n);                // 3.将54张牌放到集合                pokers.add(p);            &#125;        &#125;        // 打印//        System.out.println(pokers);        // 洗牌: Collections,集合工具类        // static void shuffle​(List&lt;?&gt; list) 将集合中元素的顺序打乱        Collections.shuffle(pokers);        System.out.println(&quot;洗牌后:&quot; + pokers);        // 发牌        // 1.创建3个玩家集合,创建底牌集合        ArrayList&lt;Poker&gt; player01 = new ArrayList&lt;&gt;();        ArrayList&lt;Poker&gt; player02 = new ArrayList&lt;&gt;();        ArrayList&lt;Poker&gt; player03 = new ArrayList&lt;&gt;();        ArrayList&lt;Poker&gt; diPai = new ArrayList&lt;&gt;();        // 2.遍历牌的集合        //            0     1      2     3     4     5      6     7     8      9     10 ...51    52     53        // pokers = [♦5], [♣4], [♦8], [♣A], [♣7], [♦2], [♠6], [♣J], [♥A], [♥7], [♥6], [♣5], [♦7], [♥10]        // 玩家1:   索引0,3,6       索引 % 3 == 0        // 玩家2:   索引1,4,7       索引 % 3 == 1        // 玩家3:   索引2,5,8       索引 % 3 == 2        // 3.根据索引将牌发给不同的玩家        for (int i = 0; i &lt; pokers.size(); i++) &#123;            // i表示索引,poker就是i索引对应的poker            Poker poker = pokers.get(i);            if (i &gt;= 51) &#123; // 最后3张给底牌                diPai.add(poker);            &#125; else if (i % 3 == 0) &#123; // 玩家1                player01.add(poker);            &#125; else if (i % 3 == 1) &#123; // 玩家2                player02.add(poker);            &#125; else if (i % 3 == 2) &#123; // 玩家3                player03.add(poker);            &#125;        &#125;        // 看牌        System.out.println(&quot;玩家1: &quot; + player01);        System.out.println(&quot;玩家2: &quot; + player02);        System.out.println(&quot;玩家3: &quot; + player03);        System.out.println(&quot;底牌: &quot; + diPai);        // 还要创建一副牌        // 创建一个ArrayList用于存放一副牌    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day05【迭代器，数据结构-List-Set-TreeSet集合-Collections工具类】&quot;&gt;&lt;a href=&quot;#day05【迭代器，数据结构-List-Set-TreeSet集合-Collections工具类】&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java进阶13天资料" scheme="http://example.com/tags/java%E8%BF%9B%E9%98%B613%E5%A4%A9%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Day04</title>
    <link href="http://example.com/2021/09/05/JAVA/day04%E3%80%90%E5%B8%B8%E7%94%A8API%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E3%80%81collection%E6%8E%A5%E5%8F%A3%E3%80%91/"/>
    <id>http://example.com/2021/09/05/JAVA/day04%E3%80%90%E5%B8%B8%E7%94%A8API%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E3%80%81collection%E6%8E%A5%E5%8F%A3%E3%80%91/</id>
    <published>2021-09-05T02:33:46.000Z</published>
    <updated>2021-09-05T03:04:28.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day04【常用API、正则表达式，泛型、Collection集合API】"><a href="#day04【常用API、正则表达式，泛型、Collection集合API】" class="headerlink" title="day04【常用API、正则表达式，泛型、Collection集合API】"></a>day04【常用API、正则表达式，泛型、Collection集合API】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>Date类<ul><li>Java是面向对象的思想，会用一个类来代表一个事物。</li><li>Date代表了系统当前此刻日期对象！年月日时分秒。</li></ul></li><li>DateFormat类<ul><li>日期格式化类，认为日期对象拿到的时间是不好看的！</li><li>日期格式化类可以把时间格式化成我们喜欢的格式。</li><li>日期格式化类可以把字符串时间解析成日期对象!!  “2019-10-01 09:28:00”</li></ul></li><li>Calendar类  <ul><li>日历类，代表了此刻日期对象对应的日历对象。日历的信息更加的丰富。</li></ul></li><li>System类<ul><li>代表了当前JVM虚拟机对应的操作系统对象。</li><li>可以拿系统时间。</li><li>可以让程序退出JVM虚拟机，让程序立即死亡！！</li><li>可以做数组拷贝。</li></ul></li><li>StringBuilder类<ul><li>String类不适合做字符串的拼接，增删等运算。不可变字符串，增删性能较差！</li><li>StringBuillder非常适合做字符串的增删改查操作，性能更好！！</li></ul></li><li>包装类<ul><li>一切皆对象。   </li><li>int Integer   int age = 21;    Integer age1 = 21; </li><li>float Float </li><li>double Double</li></ul></li><li>泛型<ul><li>ArrayLIst<Integer> lists = new ArrayList&lt;&gt;();</li></ul></li><li><strong>Collection集合：List , Map , Set</strong> <ul><li>三天的集合框架（重点内容，开发必用的！！）</li></ul></li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><p><input disabled="" type="checkbox">  能够使用日期类输出当前日期</p><ul><li><input disabled="" type="checkbox"> <strong>Date d = new Date();</strong></li><li><input disabled="" type="checkbox"> <strong>System.out.println(d);</strong></li></ul></li><li><p><input disabled="" type="checkbox">  能够使用将日期格式化为字符串的方法</p><ul><li><input disabled="" type="checkbox"> <strong>SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);</strong></li><li><input disabled="" type="checkbox"> <strong>String rs = sdf.format(“日期对象”)</strong></li><li><input disabled="" type="checkbox"> <strong>String rs = sdf.format(“时间毫秒值”)</strong></li></ul></li><li><p><input disabled="" type="checkbox">  能够使用将字符串转换成日期的方法</p><ul><li><input disabled="" type="checkbox"> <strong>SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);</strong></li><li><input disabled="" type="checkbox"> <strong>String str = “2019-11-11 11:11:11”;</strong></li><li><input disabled="" type="checkbox"> <strong>Data d = sdf.parse(str );</strong></li><li><input disabled="" type="checkbox"> System.out.println(d);</li></ul></li><li><p><input disabled="" type="checkbox">  能够使用System类的数组复制方法</p><pre><code class="java">// 3.数组拷贝：int[] arrs1 = &#123;10 , 20 , 30 , 40 , 50 , 60 , 70 , 80&#125;;// arrs2 = [ 0 , 0 , 0 , 0 , 0 , 0]// arrs2 = [0 , 0 , 30 , 40 , 50 , 0]// 希望把第一个数组的 30 , 40 , 50赋值到第二个数组！int[] arrs2 = new int[6];/** arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length) 参数一：原数组。 参数二：从原数组哪个位置开始复制 参数三：目标数组 参数四：复制到目标数组的哪个位置开始。 参数五：复制多少个！ */System.arraycopy(arrs1, 2 ,arrs2 , 2 , 3);System.out.println(Arrays.toString(arrs2));</code></pre></li><li><p><input disabled="" type="checkbox">  能够使用System类获取当前毫秒时刻值</p><ul><li><input disabled="" type="checkbox"> <pre><code class="java">long time = System.currentTimeMillis();</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  能够说出使用StringBuilder类可以解决的问题</p><ul><li><input disabled="" type="checkbox"> 可以做字符串的运算（拼接，增删，反转）</li></ul></li><li><p><input disabled="" type="checkbox">  能够使用StringBuilder进行字符串拼接操作</p><ul><li><input disabled="" type="checkbox"> append</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出8种基本类型对应的包装类名称</p><ul><li><p><input disabled="" type="checkbox">  int Integer</p></li><li><p><input disabled="" type="checkbox">  char Character</p></li><li><p><input disabled="" type="checkbox"> </p><pre><code class="properties">基本数据类型              包装类    byte                 Byte    short                Short    int                  Integer(特殊)    long                 Long    float                Float    double               Double    char                 Character(特殊)    boolean              Boolean</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  能够说出自动装箱、自动拆箱的概念</p><ul><li><input disabled="" type="checkbox"> <pre><code class="properties">自动装箱：可以直接把基本数据类型的变量或者值赋值给对应的包装类对象。自动拆箱：可以把包装类的对象赋值给基本数据类型的变量。</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  能够将字符串转换为对应的基本类型</p><pre><code class="properties">功能3: 把字符串类型的数字转化成对应的基本数据类型的值！！（真的有用，而且挺重要）          Xxxx.parseXxxx(&quot;字符串类型的数字&quot;)          Xxxx.valueOf(&quot;字符串类型的数字&quot;)：推荐使用的！</code></pre></li><li><p><input disabled="" type="checkbox">  能够将基本类型转换为对应的字符串</p><pre><code class="java">// 功能2: 包装类可以把基本数据类型的值转换成字符串。// 1.把基本数据类型的值转换成字符串:toString()Integer num = 23 ;String numStr1 = num.toString();System.out.println(numStr1+1); // 231// 2.把基本数据类型的值转换成字符串:Integer num1 = 23 ;String num1Str1 = Integer.toString(num1);System.out.println(num1Str1+1); // 231// 3.把基本数据类型的值转换成字符串:Integer num2 = 23 ;String num2Str1 = num2 + &quot;&quot; ; //常见做法！System.out.println(num2Str1+1); // 231</code></pre></li><li><p><input disabled="" type="checkbox">  能够说出Collection集合的常用功能</p><ul><li><input disabled="" type="checkbox"> <pre><code class="properties">Collection集合作为集合的根类，它的功能是一切集合都可以直接使用的。 - public boolean add(E e)：  把给定的对象添加到当前集合中 。 - public void clear() :清空集合中所有的元素。 - public boolean remove(E e): 把给定的对象在当前集合中删除。 - public boolean contains(Object obj): 判断当前集合中是否包含给定的对象。 - public boolean isEmpty(): 判断当前集合是否为空。 - public int size(): 返回集合中元素的个数。 - public Object[] toArray(): 把集合中的元素，存储到数组中</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  能够使用泛型创建集合对象</p><ul><li><input disabled="" type="checkbox"> <pre><code class="java">ArrayList&lt;String&gt; lists = new ArrayList&lt;&gt;(); // JDK 1.7之后泛型的简化写法！ArrayList&lt;Integer&gt; lists1 = new ArrayList&lt;&gt;();// JDK 1.7之后泛型的简化写法！</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  能够理解泛型上下限</p><ul><li><input disabled="" type="checkbox"> ? extends Car : ?必须是Car的子类或者本身 。  上限</li><li><input disabled="" type="checkbox"> ? super Car : ?必须是Car的父类或者本身 。  下限   不用的!!</li></ul></li><li><p><input disabled="" type="checkbox">  能够阐述泛型通配符的作用</p><ul><li><input disabled="" type="checkbox"> ? 可以在使用泛型的时候，代表接收一切类型</li></ul></li></ul><h1 id="第一章-DateFormat类"><a href="#第一章-DateFormat类" class="headerlink" title="第一章 DateFormat类"></a>第一章 DateFormat类</h1><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p><ul><li><strong>格式化</strong>：按照指定的格式，把Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，把String对象转换为Date对象。</li></ul><h2 id="1-1-构造方法"><a href="#1-1-构造方法" class="headerlink" title="1.1 构造方法"></a>1.1 构造方法</h2><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。</li></ul><h2 id="1-2-格式规则"><a href="#1-2-格式规则" class="headerlink" title="1.2 格式规则"></a>1.2 格式规则</h2><p>常用的格式规则为：</p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><blockquote><p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档。</p></blockquote><h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><p>DateFormat类的常用方法有：</p><ul><li><p><code>public String format(Date date)</code>：将Date对象格式化为字符串。</p></li><li><p><code>public Date parse(String source)</code>：将字符串解析为Date对象。</p><pre><code class="java">public class SimpleDateFormatDemo &#123;    public static void main(String[] args) throws ParseException &#123;        //格式化：从 Date 到 String        Date d = new Date();        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);        String s = sdf.format(d);        System.out.println(s);        System.out.println(&quot;--------&quot;);        //从 String 到 Date        String ss = &quot;2048-08-09 11:11:11&quot;;        //ParseException        SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        Date dd = sdf2.parse(ss);        System.out.println(dd);    &#125;&#125;</code></pre></li></ul><blockquote><p>小结：DateFormat可以将Date对象和字符串相互转换。</p></blockquote><h1 id="第二章-Calendar类"><a href="#第二章-Calendar类" class="headerlink" title="第二章 Calendar类"></a>第二章 Calendar类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul><li>java.util.Calendar类表示一个“日历类”，可以进行日期运算。它是一个抽象类，不能创建对象，我们可以使用它的子类：java.util.GregorianCalendar类。</li><li>有两种方式可以获取GregorianCalendar对象：<ul><li>直接创建GregorianCalendar对象；</li><li>通过Calendar的静态方法getInstance()方法获取GregorianCalendar对象【本次课使用】</li></ul></li></ul><h2 id="2-2-常用方法"><a href="#2-2-常用方法" class="headerlink" title="2.2 常用方法"></a>2.2 常用方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Calendar getInstance()</td><td>获取一个它的子类GregorianCalendar对象。</td></tr><tr><td>public int get(int field)</td><td>获取某个字段的值。field参数表示获取哪个字段的值，<br />可以使用Calender中定义的常量来表示：<br />Calendar.YEAR : 年<br />Calendar.MONTH ：月<br />Calendar.DAY_OF_MONTH：月中的日期<br />Calendar.HOUR：小时<br />Calendar.MINUTE：分钟<br />Calendar.SECOND：秒<br />Calendar.DAY_OF_WEEK：星期</td></tr><tr><td>public void set(int field,int value)</td><td>设置某个字段的值</td></tr><tr><td>public void add(int field,int amount)</td><td>为某个字段增加/减少指定的值</td></tr></tbody></table><h2 id="2-3-get方法示例"><a href="#2-3-get方法示例" class="headerlink" title="2.3 get方法示例"></a>2.3 get方法示例</h2><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        //1.获取一个GregorianCalendar对象        Calendar instance = Calendar.getInstance();//获取子类对象        //2.打印子类对象        System.out.println(instance);        //3.获取属性        int year = instance.get(Calendar.YEAR);        int month = instance.get(Calendar.MONTH) + 1;//Calendar的月份值是0-11        int day = instance.get(Calendar.DAY_OF_MONTH);        int hour = instance.get(Calendar.HOUR);        int minute = instance.get(Calendar.MINUTE);        int second = instance.get(Calendar.SECOND);        int week = instance.get(Calendar.DAY_OF_WEEK);//返回值范围：1--7，分别表示：&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,...,&quot;星期六&quot;        System.out.println(year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot; +                                hour + &quot;:&quot; + minute + &quot;:&quot; + second);        System.out.println(getWeek(week));    &#125;    //查表法，查询星期几    public static String getWeek(int w) &#123;//w = 1 --- 7        //做一个表(数组)        String[] weekArray = &#123;&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;&#125;;        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]        //查表        return weekArray[w - 1];    &#125;&#125;</code></pre><h2 id="2-4-set方法示例："><a href="#2-4-set方法示例：" class="headerlink" title="2.4 set方法示例："></a>2.4 set方法示例：</h2><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        //设置属性——set(int field,int value):        Calendar c1 = Calendar.getInstance();//获取当前日期        //计算班长出生那天是星期几(假如班长出生日期为：1998年3月18日)        c1.set(Calendar.YEAR, 1998);        c1.set(Calendar.MONTH, 3 - 1);//转换为Calendar内部的月份值        c1.set(Calendar.DAY_OF_MONTH, 18);        int w = c1.get(Calendar.DAY_OF_WEEK);        System.out.println(&quot;班长出生那天是：&quot; + getWeek(w));            &#125;    //查表法，查询星期几    public static String getWeek(int w) &#123;//w = 1 --- 7        //做一个表(数组)        String[] weekArray = &#123;&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;&#125;;        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]        //查表        return weekArray[w - 1];    &#125;&#125;</code></pre><h2 id="2-5-add方法示例："><a href="#2-5-add方法示例：" class="headerlink" title="2.5 add方法示例："></a>2.5 add方法示例：</h2><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        //计算200天以后是哪年哪月哪日，星期几？        Calendar c2 = Calendar.getInstance();//获取当前日期        c2.add(Calendar.DAY_OF_MONTH, 200);//日期加200        int y = c2.get(Calendar.YEAR);        int m = c2.get(Calendar.MONTH) + 1;//转换为实际的月份        int d = c2.get(Calendar.DAY_OF_MONTH);        int wk = c2.get(Calendar.DAY_OF_WEEK);        System.out.println(&quot;200天后是：&quot; + y + &quot;年&quot; + m + &quot;月&quot; + d + &quot;日&quot; + getWeek(wk));    &#125;    //查表法，查询星期几    public static String getWeek(int w) &#123;//w = 1 --- 7        //做一个表(数组)        String[] weekArray = &#123;&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;&#125;;        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]        //查表        return weekArray[w - 1];    &#125;&#125;</code></pre><h1 id="第三章-Math类"><a href="#第三章-Math类" class="headerlink" title="第三章 Math类"></a>第三章 Math类</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ul><li>java.lang.Math(类): Math包含执行基本数字运算的方法。</li><li>它不能创建对象，它的构造方法被“私有”了。因为他内部都是“静态方法”，通过“类名”直接调用即可。</li></ul><h2 id="3-2-常用方法"><a href="#3-2-常用方法" class="headerlink" title="3.2 常用方法"></a>3.2 常用方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static int abs(int a)</td><td>获取参数a的绝对值：</td></tr><tr><td>public static double ceil(double a)</td><td>向上取整</td></tr><tr><td>public static double floor(double a)</td><td>向下取整</td></tr><tr><td>public static double pow(double a, double b)</td><td>获取a的b次幂</td></tr><tr><td>public static long round(double a)</td><td>四舍五入取整</td></tr></tbody></table><h2 id="3-3-示例代码"><a href="#3-3-示例代码" class="headerlink" title="3.3 示例代码"></a>3.3 示例代码</h2><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;-5的绝对值：&quot; + Math.abs(-5));//5        System.out.println(&quot;3.4向上取整：&quot; + Math.ceil(3.4));//4.0        System.out.println(&quot;3.4向下取整：&quot; + Math.floor(3.4));//3.0        System.out.println(&quot;2的8次幂：&quot; + Math.pow(2, 8));//256.0        System.out.println(&quot;3.2四舍五入：&quot; + Math.round(3.2));//3        System.out.println(&quot;3.5四舍五入：&quot; + Math.round(3.5));//4    &#125;&#125;</code></pre><h1 id="第四章-System"><a href="#第四章-System" class="headerlink" title="第四章 System"></a>第四章 System</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作。</p><h2 id="4-2-常用方法"><a href="#4-2-常用方法" class="headerlink" title="4.2 常用方法"></a>4.2 常用方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public   static void exit(int status)</td><td>终止当前运行的   Java   虚拟机，非零表示异常终止</td></tr><tr><td>public   static long currentTimeMillis()</td><td>返回当前时间(以毫秒为单位)</td></tr></tbody></table><h2 id="4-3-练习"><a href="#4-3-练习" class="headerlink" title="4.3 练习"></a>4.3 练习</h2><p>在控制台输出1-10000，计算这段代码执行了多少毫秒 </p><pre><code class="java">import java.util.Date;//验证for循环打印数字1-9999所需要使用的时间（毫秒）public class SystemDemo &#123;    public static void main(String[] args) &#123;           //获取当前时间毫秒值       System.out.println(System.currentTimeMillis());       //计算程序运行时间       long start = System.currentTimeMillis();        for (int i = 1; i &lt;= 10000; i++) &#123;            System.out.println(i);        &#125;        long end = System.currentTimeMillis();        System.out.println(&quot;共耗时毫秒：&quot; + (end - start));    &#125;  &#125;</code></pre><h1 id="第五章-BigDecimal类"><a href="#第五章-BigDecimal类" class="headerlink" title="第五章 BigDecimal类"></a>第五章 BigDecimal类</h1><h2 id="5-1-引入"><a href="#5-1-引入" class="headerlink" title="5.1 引入"></a>5.1 引入</h2><p>浮点数做运算精度问题；</p><p>看程序说结果：</p><pre><code class="java">public static void main(String[] args) &#123;    System.out.println(0.09 + 0.01);    System.out.println(1.0 - 0.32);    System.out.println(1.015 * 100);    System.out.println(1.301 / 100);&#125;</code></pre><h2 id="5-2-概述"><a href="#5-2-概述" class="headerlink" title="5.2 概述"></a>5.2 概述</h2><table><thead><tr><th>相关内容</th><th align="left">具体描述</th></tr></thead><tbody><tr><td>包</td><td align="left">java.math                                                                  使用时需要导包</td></tr><tr><td>类声明</td><td align="left">public class BigDecimal extends Number implements Comparable<BigDecimal></td></tr><tr><td>描述</td><td align="left">BigDecimal类提供了算术，缩放操作，舍入，比较，散列和格式转换的操作。提供了更加精准的数据计算方式</td></tr></tbody></table><h2 id="5-3-构造方法"><a href="#5-3-构造方法" class="headerlink" title="5.3 构造方法"></a>5.3 构造方法</h2><table><thead><tr><th>构造方法名</th><th>描述</th></tr></thead><tbody><tr><td>BigDecimal(double val)</td><td>将double类型的数据封装为BigDecimal对象</td></tr><tr><td>BigDecimal(String val)</td><td>将 BigDecimal 的字符串表示形式转换为 BigDecimal</td></tr></tbody></table><p>注意：推荐使用第二种方式，第一种存在精度问题；</p><h2 id="5-4-常用方法"><a href="#5-4-常用方法" class="headerlink" title="5.4 常用方法"></a>5.4 常用方法</h2><p>BigDecimal类中使用最多的还是提供的进行四则运算的方法，如下：</p><table><thead><tr><th>方法声明</th><th>描述</th></tr></thead><tbody><tr><td>public BigDecimal add(BigDecimal value)</td><td>加法运算</td></tr><tr><td>public BigDecimal subtract(BigDecimal value)</td><td>减法运算</td></tr><tr><td>public BigDecimal multiply(BigDecimal value)</td><td>乘法运算</td></tr><tr><td>public BigDecimal divide(BigDecimal value)</td><td>触发运算</td></tr></tbody></table><p>注意：对于divide方法来说，如果除不尽的话，就会出现java.lang.ArithmeticException异常。此时可以使用divide方法的另一个重载方法；</p><blockquote><p>BigDecimal divide(BigDecimal divisor, int scale, int roundingMode): divisor：除数对应的BigDecimal对象；scale:精确的位数；roundingMode取舍模式</p></blockquote><blockquote><p>小结：Java中小数运算有可能会有精度问题，如果要解决这种精度问题，可以使用BigDecimal</p></blockquote><h1 id="第六章-正则表达式"><a href="#第六章-正则表达式" class="headerlink" title="第六章 正则表达式"></a>第六章 正则表达式</h1><h2 id="6-1-正则表达式的概念及演示"><a href="#6-1-正则表达式的概念及演示" class="headerlink" title="6.1 正则表达式的概念及演示"></a>6.1 正则表达式的概念及演示</h2><ul><li>在Java中，我们经常需要验证一些字符串，例如：年龄必须是2位的数字、用户名必须是8位长度而且只能包含大小写字母、数字等。正则表达式就是用来验证各种字符串的规则。它内部描述了一些规则，我们可以验证用户输入的字符串是否匹配这个规则。</li><li>先看一个不使用正则表达式验证的例子：下面的程序让用户输入一个QQ号码，我们要验证：<ul><li>QQ号码必须是5–15位长度</li><li>而且必须全部是数字</li><li>而且首位不能为0</li></ul></li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);                System.out.println(&quot;请输入你的QQ号码：&quot;);        String qq = sc.next();                System.out.println(checkQQ(qq));    &#125;    //我们自己编写代码，验证QQ号码    private static boolean checkQQ(String qq) &#123;        //1.验证5--15位        if(qq.length() &lt; 5 || qq.length() &gt; 15)&#123;            return false;        &#125;        //2.必须都是数字；        for(int i = 0;i &lt; qq.length() ; i++)&#123;            char c = qq.charAt(i);            if(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)&#123;                return false;            &#125;        &#125;        //3.首位不能是0；        char c = qq.charAt(0);        if(c == &#39;0&#39;)&#123;            return false;        &#125;        return true;//验证通过    &#125;    &#125;</code></pre><ul><li>使用正则表达式验证：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);                System.out.println(&quot;请输入你的QQ号码：&quot;);        String qq = sc.next();                System.out.println(checkQQ2(qq));    &#125;    //使用正则表达式验证    private static boolean checkQQ2(String qq)&#123;        String regex = &quot;[1-9]\\d&#123;4,14&#125;&quot;;//正则表达式        return qq.matches(regex);    &#125;&#125;</code></pre><p>上面程序checkQQ2()方法中String类型的变量regex就存储了一个”正则表达式 “，而这个正则表达式就描述了我们需要的三个规则。matches()方法是String类的一个方法，用于接收一个正则表达式，并将”本对象”与参数”正则表达式”进行匹配，如果本对象符合正则表达式的规则，则返回true，否则返回false。</p><p><strong>我们接下来就重点学习怎样写正则表达式</strong></p><h2 id="6-2-正则表达式-字符类"><a href="#6-2-正则表达式-字符类" class="headerlink" title="6.2 正则表达式-字符类"></a>6.2 正则表达式-字符类</h2><ul><li>语法示例：</li></ul><ol><li>[abc]：代表a或者b，或者c字符中的一个。</li><li>[^abc]：代表除a,b,c以外的任何字符。</li><li>[a-z]：代表a-z的所有小写字符中的一个。</li><li>[A-Z]：代表A-Z的所有大写字符中的一个。</li><li>[0-9]：代表0-9之间的某一个数字字符。</li><li>[a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。</li><li>[a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。 </li></ol><ul><li>代码示例：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;ead&quot;;                //1.验证str是否以h开头，以d结尾，中间是a,e,i,o,u中某个字符        String regex = &quot;h[aeiou]d&quot;;        System.out.println(&quot;1.&quot; + str.matches(regex));                //2.验证str是否以h开头，以d结尾，中间不是a,e,i,o,u中的某个字符        regex = &quot;h[^aeiou]d&quot;;        System.out.println(&quot;2.&quot; +  str.matches(regex));                //3.验证str是否a-z的任何一个小写字符开头，后跟ad        regex = &quot;[a-z]ad&quot;;        System.out.println(&quot;3.&quot; + str.matches(regex));                //4.验证str是否以a-d或者m-p之间某个字符开头，后跟ad        regex = &quot;[[a-d][m-p]]ad&quot;;        System.out.println(&quot;4.&quot; + str.matches(regex));    &#125;&#125;</code></pre><h2 id="6-3-正则表达式-逻辑运算符"><a href="#6-3-正则表达式-逻辑运算符" class="headerlink" title="6.3 正则表达式-逻辑运算符"></a>6.3 正则表达式-逻辑运算符</h2><ul><li>语法示例：<ol><li>&amp;&amp;：并且</li><li>|    ：或者</li></ol></li><li>代码示例：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;had&quot;;                //1.要求字符串是小写辅音字符开头，后跟ad        String regex = &quot;[a-z&amp;&amp;[^aeiou]]ad&quot;;        System.out.println(&quot;1.&quot; + str.matches(regex));                //2.要求字符串是aeiou中的某个字符开头，后跟ad        regex = &quot;[a|e|i|o|u]ad&quot;;//这种写法相当于：regex = &quot;[aeiou]ad&quot;;        System.out.println(&quot;2.&quot; + str.matches(regex));    &#125;&#125;</code></pre><h2 id="6-4-正则表达式-预定义字符"><a href="#6-4-正则表达式-预定义字符" class="headerlink" title="6.4 正则表达式-预定义字符"></a>6.4 正则表达式-预定义字符</h2><ul><li>语法示例：<ol><li>“.” ： 匹配任何字符。</li><li>“\d”：任何数字[0-9]的简写；</li><li>“\D”：任何非数字[^0-9]的简写；</li><li>“\s”： 空白字符：[ \t\n\x0B\f\r] 的简写</li><li>“\S”： 非空白字符：[^\s] 的简写</li><li>“\w”：单词字符：[a-zA-Z_0-9]的简写</li><li>“\W”：非单词字符：[^\w]</li></ol></li><li>代码示例：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;258&quot;;                //1.验证str是否3位数字        String regex = &quot;\\d\\d\\d&quot;;        System.out.println(&quot;1.&quot; + str.matches(regex));                //2.验证手机号：1开头，第二位：3/5/8，剩下9位都是0-9的数字        str = &quot;13513153355&quot;;//要验证的字符串        regex = &quot;1[358]\\d\\d\\d\\d\\d\\d\\d\\d\\d&quot;;//正则表达式        System.out.println(&quot;2.&quot; + str.matches(regex));                //3.验证字符串是否以h开头，以d结尾，中间是任何字符        str = &quot;had&quot;;//要验证的字符串        regex = &quot;h.d&quot;;//正则表达式        System.out.println(&quot;3.&quot; + str.matches(regex));                //4.验证str是否是：had.        str = &quot;had.&quot;;//要验证的字符串        regex = &quot;had\\.&quot;;//\\.代表&#39;.&#39;符号，因为.在正则中被预定义为&quot;任意字符&quot;，不能直接使用        System.out.println(&quot;4.&quot; + str.matches(regex));            &#125;&#125;</code></pre><h2 id="6-5-正则表达式-数量词"><a href="#6-5-正则表达式-数量词" class="headerlink" title="6.5 正则表达式-数量词"></a>6.5 正则表达式-数量词</h2><ul><li>语法示例：<ol><li>X? : 0次或1次</li><li>X* : 0次到多次</li><li>X+ : 1次或多次</li><li>X{n} : 恰好n次</li><li>X{n,} : 至少n次</li><li>X{n,m}: n到m次(n和m都是包含的)</li></ol></li><li>代码示例：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;&quot;;                //1.验证str是否是三位数字        str = &quot;012&quot;;        String regex = &quot;\\d&#123;3&#125;&quot;;        System.out.println(&quot;1.&quot; + str.matches(regex));                //2.验证str是否是多位数字        str = &quot;88932054782342&quot;;        regex = &quot;\\d+&quot;;        System.out.println(&quot;2.&quot; + str.matches(regex));                //3.验证str是否是手机号：        str = &quot;13813183388&quot;;        regex = &quot;1[358]\\d&#123;9&#125;&quot;;        System.out.println(&quot;3.&quot; + str.matches(regex));                //4.验证小数:必须出现小数点，但是只能出现1次        String s2 = &quot;3.1&quot;;        regex = &quot;\\d*\\.&#123;1&#125;\\d+&quot;;        System.out.println(&quot;4.&quot; + s2.matches(regex));                //5.验证小数：小数点可以不出现，也可以出现1次        regex = &quot;\\d+\\.?\\d+&quot;;        System.out.println(&quot;5.&quot; + s2.matches(regex));                //6.验证小数：要求匹配：3、3.、3.14、+3.14、-3.        s2 = &quot;-3.&quot;;        regex = &quot;[+-]\\d+\\.?\\d*&quot;;        System.out.println(&quot;6.&quot; + s2.matches(regex));                //7.验证qq号码：1).5--15位；2).全部是数字;3).第一位不是0        s2 = &quot;1695827736&quot;;        regex = &quot;[1-9]\\d&#123;4,14&#125;&quot;;        System.out.println(&quot;7.&quot; + s2.matches(regex));    &#125;&#125;</code></pre><h2 id="6-6-正则表达式-分组括号"><a href="#6-6-正则表达式-分组括号" class="headerlink" title="6.6 正则表达式-分组括号( )"></a>6.6 正则表达式-分组括号( )</h2><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;DG8FV-B9TKY-FRT9J-99899-XPQ4G&quot;;                //验证这个序列号：分为5组，每组之间使用-隔开，每组由5位A-Z或者0-9的字符组成        String regex = &quot;([A-Z0-9]&#123;5&#125;-)&#123;4&#125;[A-Z0-9]&#123;5&#125;&quot;;        System.out.println(str.matches(regex));    &#125;&#125;</code></pre><h2 id="6-7-String的split方法中使用正则表达式"><a href="#6-7-String的split方法中使用正则表达式" class="headerlink" title="6.7 String的split方法中使用正则表达式"></a>6.7 String的split方法中使用正则表达式</h2><ul><li><p>String类的split()方法原型：</p><pre><code class="java">public String[] split(String regex)//参数regex就是一个正则表达式。可以将当前字符串中匹配regex正则表达式的符号作为&quot;分隔符&quot;来切割字符串。</code></pre></li><li><p>代码示例：</p></li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;18  4 567       99     56&quot;;        String[] strArray = str.split(&quot; +&quot;);        for (int i = 0; i &lt; strArray.length; i++) &#123;            System.out.println(strArray[i]);        &#125;    &#125;&#125;</code></pre><h2 id="6-8-String类的replaceAll方法中使用正则表达式"><a href="#6-8-String类的replaceAll方法中使用正则表达式" class="headerlink" title="6.8 String类的replaceAll方法中使用正则表达式"></a>6.8 String类的replaceAll方法中使用正则表达式</h2><ul><li>String类的replaceAll()方法原型：</li></ul><pre><code class="java">public String replaceAll(String regex,String newStr)//参数regex就是一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。</code></pre><ul><li>代码示例：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        //将下面字符串中的&quot;数字&quot;替换为&quot;*&quot;        String str = &quot;jfdk432jfdk2jk24354j47jk5l31324&quot;;        System.out.println(str.replaceAll(&quot;\\d+&quot;, &quot;*&quot;));    &#125;&#125;</code></pre><h1 id="第七章-包装类"><a href="#第七章-包装类" class="headerlink" title="第七章  包装类"></a>第七章  包装类</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="7-2-Integer类"><a href="#7-2-Integer类" class="headerlink" title="7.2 Integer类"></a>7.2 Integer类</h2><ul><li><p>Integer类概述</p><p>包装一个对象中的原始类型 int 的值</p></li><li><p>Integer类构造方法及静态方法</p></li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Integer(int   value)</td><td>根据 int 值创建 Integer 对象(过时)</td></tr><tr><td>public Integer(String s)</td><td>根据 String 值创建 Integer 对象(过时)</td></tr><tr><td>public static Integer valueOf(int i)</td><td>返回表示指定的 int 值的 Integer   实例</td></tr><tr><td>public static Integer valueOf(String s)</td><td>返回保存指定String值的 Integer 对象</td></tr></tbody></table><ul><li>示例代码</li></ul><pre><code class="java">public class IntegerDemo &#123;    public static void main(String[] args) &#123;        //public Integer(int value)：根据 int 值创建 Integer 对象(过时)        Integer i1 = new Integer(100);        System.out.println(i1);        //public Integer(String s)：根据 String 值创建 Integer 对象(过时)        Integer i2 = new Integer(&quot;100&quot;);        //Integer i2 = new Integer(&quot;abc&quot;); //NumberFormatException        System.out.println(i2);        System.out.println(&quot;--------&quot;);        //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例        Integer i3 = Integer.valueOf(100);        System.out.println(i3);        //public static Integer valueOf(String s)：返回保存指定String值的Integer对象         Integer i4 = Integer.valueOf(&quot;100&quot;);        System.out.println(i4);    &#125;&#125;</code></pre><h2 id="7-3-装箱与拆箱"><a href="#7-3-装箱与拆箱" class="headerlink" title="7.3 装箱与拆箱"></a>7.3 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</li><li><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</li></ul><p>用Integer与 int为例：（看懂代码即可）</p><p>基本数值—-&gt;包装对象</p><pre><code class="java">Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法</code></pre><p>包装对象—-&gt;基本数值</p><pre><code class="java">int num = i.intValue();</code></pre><h2 id="7-4-自动装箱与自动拆箱"><a href="#7-4-自动装箱与自动拆箱" class="headerlink" title="7.4 自动装箱与自动拆箱"></a>7.4 自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p><pre><code class="java">Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。</code></pre><h2 id="7-5-基本类型与字符串之间的转换"><a href="#7-5-基本类型与字符串之间的转换" class="headerlink" title="7.5 基本类型与字符串之间的转换"></a>7.5 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><ul><li>转换方式</li><li>方式一：直接在数字后加一个空字符串</li><li>方式二：通过String类静态方法valueOf()</li><li>示例代码</li></ul><pre><code class="java">public class IntegerDemo &#123;    public static void main(String[] args) &#123;        //int --- String        int number = 100;        //方式1        String s1 = number + &quot;&quot;;        System.out.println(s1);        //方式2        //public static String valueOf(int i)        String s2 = String.valueOf(number);        System.out.println(s2);        System.out.println(&quot;--------&quot;);    &#125;&#125;</code></pre><h3 id="String转换成基本类型"><a href="#String转换成基本类型" class="headerlink" title="String转换成基本类型"></a>String转换成基本类型</h3><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><strong><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</strong></li><li><strong><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</strong></li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p><ul><li>转换方式<ul><li>方式一：先将字符串数字转成Integer，再调用valueOf()方法</li><li>方式二：通过Integer静态方法parseInt()进行转换</li></ul></li><li>示例代码</li></ul><pre><code class="java">public class IntegerDemo &#123;    public static void main(String[] args) &#123;        //String --- int        String s = &quot;100&quot;;        //方式1：String --- Integer --- int        Integer i = Integer.valueOf(s);        //public int intValue()        int x = i.intValue();        System.out.println(x);        //方式2        //public static int parseInt(String s)        int y = Integer.parseInt(s);        System.out.println(y);    &#125;&#125;</code></pre><blockquote><p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote><h1 id="第八章-泛型（难点）"><a href="#第八章-泛型（难点）" class="headerlink" title="第八章 泛型（难点）"></a>第八章 泛型（难点）</h1><h2 id="8-1-泛型概述"><a href="#8-1-泛型概述" class="headerlink" title="8.1  泛型概述"></a>8.1  泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><p>大家观察下面代码：</p><pre><code class="java">public class GenericDemo &#123;    public static void main(String[] args) &#123;        Collection coll = new ArrayList();        coll.add(&quot;abc&quot;);        coll.add(&quot;itcast&quot;);        coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放        Iterator it = coll.iterator();        while(it.hasNext())&#123;            //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型            String str = (String) it.next();            System.out.println(str.length());        &#125;    &#125;&#125;</code></pre><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h2 id="8-2-使用泛型的好处"><a href="#8-2-使用泛型的好处" class="headerlink" title="8.2  使用泛型的好处"></a>8.2  使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>通过我们如下代码体验一下：</p><pre><code class="java">public class GenericDemo2 &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;abc&quot;);        list.add(&quot;itcast&quot;);        // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错        // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型        Iterator&lt;String&gt; it = list.iterator();        while(it.hasNext())&#123;            String str = it.next();            //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型            System.out.println(str.length());        &#125;    &#125;&#125;</code></pre><blockquote><p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p></blockquote><h2 id="8-3-泛型的定义与使用"><a href="#8-3-泛型的定义与使用" class="headerlink" title="8.3  泛型的定义与使用"></a>8.3  泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><pre><code>修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</code></pre><p>例如，API中的ArrayList集合：</p><p>泛型在定义的时候不具体，使用的时候才变得具体。在使用的时候确定泛型的具体数据类型。</p><pre><code class="java">class ArrayList&lt;E&gt;&#123;     public boolean add(E e)&#123; &#125;    public E get(int index)&#123; &#125;       ....&#125;</code></pre><p>使用泛型： 即什么时候确定泛型。</p><p><strong>在创建对象的时候确定泛型</strong></p><p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p><pre><code class="java">class ArrayList&lt;String&gt;&#123;      public boolean add(String e)&#123; &#125;     public String get(int index)&#123;  &#125;     ...&#125;</code></pre><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><pre><code class="java">class ArrayList&lt;Integer&gt; &#123;      public boolean add(Integer e) &#123; &#125;     public Integer get(int index) &#123;  &#125;     ...&#125;</code></pre><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><pre><code>修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</code></pre><p>例如，</p><pre><code class="java">public class MyGenericMethod &#123;          public &lt;MVP&gt; void show(MVP mvp) &#123;        System.out.println(mvp.getClass());    &#125;        public &lt;MVP&gt; MVP show2(MVP mvp) &#123;            return mvp;    &#125;&#125;</code></pre><p><strong>调用方法时，确定泛型的类型</strong></p><pre><code class="java">public class GenericMethodDemo &#123;    public static void main(String[] args) &#123;        // 创建对象        MyGenericMethod mm = new MyGenericMethod();        // 演示看方法提示        mm.show(&quot;aaa&quot;);        mm.show(123);        mm.show(12.45);    &#125;&#125;</code></pre><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><pre><code>修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</code></pre><p>例如，</p><pre><code class="java">public interface MyGenericInterface&lt;E&gt;&#123;    public abstract void add(E e);        public abstract E getE();  &#125;</code></pre><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如</p><pre><code class="java">public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123;    @Override    public void add(String e) &#123;        // 省略...    &#125;    @Override    public String getE() &#123;        return null;    &#125;&#125;</code></pre><p>此时，泛型E的值就是String类型。</p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p> 例如</p><pre><code class="java">public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123;    @Override    public void add(E e) &#123;            // 省略...    &#125;    @Override    public E getE() &#123;        return null;    &#125;&#125;</code></pre><p>确定泛型：</p><pre><code class="java">/* * 使用 */public class GenericInterface &#123;    public static void main(String[] args) &#123;        MyImp2&lt;String&gt;  my = new MyImp2&lt;String&gt;();          my.add(&quot;aa&quot;);    &#125;&#125;</code></pre><h2 id="8-4-泛型通配符"><a href="#8-4-泛型通配符" class="headerlink" title="8.4  泛型通配符"></a>8.4  泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h3 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h3><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><pre><code class="java">public static void main(String[] args) &#123;    Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;();    getElement(list1);    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();    getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;// ？代表可以接收任意类型泛型不存在继承关系 Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;();这种是错误的</code></pre><h3 id="通配符高级使用"><a href="#通配符高级使用" class="headerlink" title="通配符高级使用"></a>通配符高级使用</h3><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><pre><code class="java">public static void main(String[] args) &#123;    Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();    Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;();    Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;();        getElement(list1);    getElement(list2);//报错    getElement(list3);    getElement(list4);//报错      getElement2(list1);//报错    getElement2(list2);//报错    getElement2(list3);    getElement2(list4);  &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;</code></pre><h1 id="第九章-Collection集合"><a href="#第九章-Collection集合" class="headerlink" title="第九章 Collection集合"></a>第九章 Collection集合</h1><h2 id="9-1-集合概述"><a href="#9-1-集合概述" class="headerlink" title="9.1 集合概述"></a>9.1 集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</p><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有什么区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储任意类型数据。集合存储的都是引用数据类型。如果想存储基本类型数据需要存储对应的包装类型。</li></ul><h2 id="9-2-集合常用类的继承体系"><a href="#9-2-集合常用类的继承体系" class="headerlink" title="9.2  集合常用类的继承体系"></a>9.2  集合常用类的继承体系</h2><p>Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.LinkedHashSet</code>。</p><p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述集合常用类的继承体系</p><p><img src="/img/java/imgs4%5CCollection%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE.jpg"></p><p>注意:这张图只是我们常用的集合有这些，不是说就只有这些集合。</p><p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p><h2 id="9-3-Collection-常用API"><a href="#9-3-Collection-常用API" class="headerlink" title="9.3 Collection 常用API"></a>9.3 Collection 常用API</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(Object obj)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中</li></ul><blockquote><p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。!</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day04【常用API、正则表达式，泛型、Collection集合API】&quot;&gt;&lt;a href=&quot;#day04【常用API、正则表达式，泛型、Collection集合API】&quot; class=&quot;headerlink&quot; title=&quot;day04【常用API、正则表达式，</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java进阶13天资料" scheme="http://example.com/tags/java%E8%BF%9B%E9%98%B613%E5%A4%A9%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Day03</title>
    <link href="http://example.com/2021/09/05/JAVA/day03%E3%80%90%E5%A4%9A%E6%80%81%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8CObject%E7%B1%BB%E3%80%91/"/>
    <id>http://example.com/2021/09/05/JAVA/day03%E3%80%90%E5%A4%9A%E6%80%81%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8CObject%E7%B1%BB%E3%80%91/</id>
    <published>2021-09-05T02:32:46.000Z</published>
    <updated>2021-09-05T03:04:04.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day03【多态、包、权限修饰符、内部类，Object类-Date类】"><a href="#day03【多态、包、权限修饰符、内部类，Object类-Date类】" class="headerlink" title="day03【多态、包、权限修饰符、内部类，Object类,Date类】"></a>day03【多态、包、权限修饰符、内部类，Object类,Date类】</h1><h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><ul><li><strong>多态（重点）</strong>：<ul><li>面向对象的三大特征之一：封装，继承，多态。</li></ul></li><li>代码块<ul><li><strong>已经讲完了</strong>。</li></ul></li><li>包  <ul><li>包我们介绍一下就好了</li></ul></li><li>权限修饰符<ul><li>介绍一下： private -&gt; 缺省 -&gt; protected -&gt; public</li></ul></li><li>内部类(很抽象)<ul><li>知识完整性（5大成分之一）</li><li>只关注语法即可，实际开发几乎无用，主要是sun公司自己用，我们能理解即可！！</li><li><strong>匿名内部类（重点,必须掌握的）</strong></li></ul></li><li>Object类<ul><li>API使用工程师。90%的技术都是别人写好的.我们直接调用。</li><li>从这里开始，几乎没有语法了，全部是别人写好的技术我们直接调用即可，调用API。</li><li>都是别人做好的技术，我们拿来用： <ul><li>MySQL  , JDBC, Mybatis,HTML , CSS , JS  , JQuery ,UI框架 ， WEB开发， Servlet , JSP</li><li>Tomcat , Spring家族的技术（Spring , Spring MVC  Spring Data JPA ） , Spring Boot</li><li>Spring Cloud</li></ul></li></ul></li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><p><input disabled="" type="checkbox">  能够说出使用多态的前提条件</p><ul><li><input disabled="" type="checkbox"> <pre><code>（1）必须有继承或者实现关系！（2）必须存在父类类的变量引用子类类型的对象！（3）存在方法重写！</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  理解多态的向上转型（自动类型转换）</p><ul><li><input disabled="" type="checkbox"> 自动类型转换。Animal a = new Cat();</li></ul></li><li><p><input disabled="" type="checkbox">  理解多态的向下转型</p><ul><li><input disabled="" type="checkbox"> 强制类型转换。</li><li><input disabled="" type="checkbox"> Animal a= new Cat();</li><li><input disabled="" type="checkbox"> Cat c = (Cat)a;</li></ul></li><li><p><input disabled="" type="checkbox">  能够完成笔记本案例</p><ul><li><input disabled="" type="checkbox"> 参见代码！</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出权限修饰符作用范</p><ul><li><input disabled="" type="checkbox"> <strong>private   本类</strong></li><li><input disabled="" type="checkbox"> <strong>缺省 本类 本包其他类</strong></li><li><input disabled="" type="checkbox"> <strong>protected 本类 本包其他类 其他包下的子类中</strong></li><li><input disabled="" type="checkbox"> <strong>public     任何地方</strong></li></ul></li><li><p><input disabled="" type="checkbox">  说出内部类的概念</p><ul><li><input disabled="" type="checkbox"> 定义在一个类里面的类就是内部类。</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出Object类的特点</p><ul><li><input disabled="" type="checkbox"> 祖宗类，它的功能，全部类都 可以使用！！</li></ul></li><li><p><input disabled="" type="checkbox">  能够重写Object类的toString方法</p><ul><li><input disabled="" type="checkbox"> 自动生成：重写返回对象内容输出。</li></ul></li><li><p><input disabled="" type="checkbox">  能够重写Object类的equals方法</p><ul><li><input disabled="" type="checkbox"> 自动生成：比较对象的内容，制定比较规则。</li></ul></li></ul><h1 id="第一章-多态-重点"><a href="#第一章-多态-重点" class="headerlink" title="第一章 多态[重点]"></a>第一章 多态[重点]</h1><h2 id="1-1-多态的形式"><a href="#1-1-多态的形式" class="headerlink" title="1.1 多态的形式"></a>1.1 多态的形式</h2><p><strong>多态是继封装、继承之后，面向对象的第三大特性。</strong></p><p><strong>多态是出现在继承或者实现关系中的</strong>。</p><p><strong>多态体现的格式</strong>：</p><pre><code class="java">父类类型 变量名 = new 子类/实现类构造器;变量名.方法名();</code></pre><p><strong>多态的前提</strong>：有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。</p><h2 id="1-2-多态的案例演示"><a href="#1-2-多态的案例演示" class="headerlink" title="1.2 多态的案例演示"></a>1.2 多态的案例演示</h2><p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。如果子类没有重写该方法，就会调用父类的该方法</strong>。</p><p>总结起来就是：<strong>编译看左边，运行看右边。</strong></p><p>代码如下：</p><p>定义父类：</p><pre><code class="java">public class Animal &#123;      public void eat()｛        System.out.println(&quot;动物吃东西！&quot;)    ｝&#125;  </code></pre><p>定义子类：</p><pre><code class="java">class Cat extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃鱼&quot;);      &#125;  &#125;  class Dog extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃骨头&quot;);      &#125;  &#125;</code></pre><p>定义测试类：</p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        // 多态形式，创建对象        Animal a1 = new Cat();        // 调用的是 Cat 的 eat        a1.eat();        // 多态形式，创建对象        Animal a2 = new Dog();        // 调用的是 Dog 的 eat        a2.eat();    &#125;  &#125;</code></pre><h2 id="1-3-多态的定义和前提"><a href="#1-3-多态的定义和前提" class="headerlink" title="1.3 多态的定义和前提"></a>1.3 多态的定义和前提</h2><p><strong>多态</strong>： 是指同一行为，具有多个不同表现形式。</p><p>从上面案例可以看出，Cat和Dog都是动物，都是吃这一行为，但是出现的效果（表现形式）是不一样的。</p><p> <strong>前提【重点】</strong></p><ol><li><p>继承或者实现【二选一】</p></li><li><p>方法的重写【意义体现：不重写，无意义】</p></li><li><p>父类引用指向子类对象【格式体现】</p><blockquote><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p></blockquote></li></ol><h2 id="1-4-多态的好处"><a href="#1-4-多态的好处" class="headerlink" title="1.4 多态的好处"></a>1.4 多态的好处</h2><p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下：</p><p>定义父类：</p><pre><code class="java">public abstract class Animal &#123;      public abstract void eat();  &#125;  </code></pre><p>定义子类：</p><pre><code class="java">class Cat extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃鱼&quot;);      &#125;  &#125;  class Dog extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃骨头&quot;);      &#125;  &#125;</code></pre><p>定义测试类：</p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        // 多态形式，创建对象        Cat c = new Cat();          Dog d = new Dog();         // 调用showCatEat         showCatEat(c);        // 调用showDogEat         showDogEat(d);         /*        以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代        而执行效果一致        */        showAnimalEat(c);        showAnimalEat(d);     &#125;    public static void showCatEat (Cat c)&#123;        c.eat();     &#125;    public static void showDogEat (Dog d)&#123;        d.eat();    &#125;    public static void showAnimalEat (Animal a)&#123;        a.eat();    &#125;&#125;</code></pre><p>由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。</p><p>当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。</p><p>不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。<strong>从而实现了实现类的自动切换。</strong></p><p>所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。</p><h2 id="1-5-多态的弊端"><a href="#1-5-多态的弊端" class="headerlink" title="1.5 多态的弊端"></a>1.5 多态的弊端</h2><p>我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时<strong>多态的写法就无法访问子类独有功能了</strong>。</p><pre><code class="java">class Animal&#123;    public  void eat()｛        System.out.println(&quot;动物吃东西！&quot;)    ｝&#125;class Cat extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃鱼&quot;);      &#125;         public void catchMouse() &#123;          System.out.println(&quot;抓老鼠&quot;);      &#125;  &#125;  class Dog extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃骨头&quot;);      &#125;  &#125;class Test&#123;    public static void main(String[] args)&#123;        Animal a = new Cat();        a.eat();        a.catchMouse();//编译报错，编译看左边，Animal没有这个方法    &#125;&#125;</code></pre><h2 id="1-6-引用类型转换"><a href="#1-6-引用类型转换" class="headerlink" title="1.6 引用类型转换"></a>1.6 引用类型转换</h2><h3 id="1-6-1-为什么要转型"><a href="#1-6-1-为什么要转型" class="headerlink" title="1.6.1 为什么要转型"></a>1.6.1 为什么要转型</h3><p><strong>多态的写法就无法访问子类独有功能了。</strong></p><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。</p><p>回顾基本数据类型转换</p><ul><li>自动转换: 范围小的赋值给范围大的.自动完成:double d = 5; </li><li>强制转换: 范围大的赋值给范围小的,强制转换:int i = (int)3.14 </li></ul><p>​     多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。</p><h3 id="1-6-2-向上转型（自动转换）"><a href="#1-6-2-向上转型（自动转换）" class="headerlink" title="1.6.2 向上转型（自动转换）"></a>1.6.2 向上转型（自动转换）</h3><ul><li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。<br>当父类引用指向一个子类对象时，便是向上转型。<br>使用格式：</li></ul><pre><code class="java">父类类型  变量名 = new 子类类型();如：Animal a = new Cat();</code></pre><p><strong>原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。</strong>所以子类范围小可以直接自动转型给父类类型的变量。</p><h3 id="1-6-3-向下转型（强制转换）"><a href="#1-6-3-向下转型（强制转换）" class="headerlink" title="1.6.3 向下转型（强制转换）"></a>1.6.3 向下转型（强制转换）</h3><ul><li><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。<br>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</li></ul><p>使用格式：</p><pre><code class="java">子类类型 变量名 = (子类类型) 父类变量名;如:Aniaml a = new Cat();   Cat c =(Cat) a;  </code></pre><h3 id="1-6-4-案例演示"><a href="#1-6-4-案例演示" class="headerlink" title="1.6.4 案例演示"></a>1.6.4 案例演示</h3><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。</p><p>转型演示，代码如下：</p><p>定义类：</p><pre><code class="java">abstract class Animal &#123;      abstract void eat();  &#125;  class Cat extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃鱼&quot;);      &#125;      public void catchMouse() &#123;          System.out.println(&quot;抓老鼠&quot;);      &#125;  &#125;  class Dog extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃骨头&quot;);      &#125;      public void watchHouse() &#123;          System.out.println(&quot;看家&quot;);      &#125;  &#125;</code></pre><p>定义测试类：</p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        // 向上转型          Animal a = new Cat();          a.eat();                 // 调用的是 Cat 的 eat        // 向下转型          Cat c = (Cat)a;               c.catchMouse();         // 调用的是 Cat 的 catchMouse    &#125;  &#125;</code></pre><h3 id="1-6-5-转型的异常"><a href="#1-6-5-转型的异常" class="headerlink" title="1.6.5 转型的异常"></a>1.6.5 转型的异常</h3><p>转型的过程中，一不小心就会遇到这样的问题，请看如下代码：</p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        // 向上转型          Animal a = new Cat();          a.eat();               // 调用的是 Cat 的 eat        // 向下转型          Dog d = (Dog)a;               d.watchHouse();        // 调用的是 Dog 的 watchHouse 【运行报错】    &#125;  &#125;</code></pre><p>这段代码可以通过编译，但是运行时，却报出了 <code>ClassCastException</code> ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。</p><h3 id="1-6-6-instanceof关键字"><a href="#1-6-6-instanceof关键字" class="headerlink" title="1.6.6 instanceof关键字"></a>1.6.6 instanceof关键字</h3><p>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验，格式如下：</p><pre><code class="java">变量名 instanceof 数据类型 如果变量属于该数据类型或者其子类类型，返回true。如果变量不属于该数据类型或者其子类类型，返回false。</code></pre><p>所以，转换前，我们最好先做一个判断，代码如下：</p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        // 向上转型          Animal a = new Cat();          a.eat();               // 调用的是 Cat 的 eat        // 向下转型          if (a instanceof Cat)&#123;            Cat c = (Cat)a;                   c.catchMouse();        // 调用的是 Cat 的 catchMouse        &#125; else if (a instanceof Dog)&#123;            Dog d = (Dog)a;                   d.watchHouse();       // 调用的是 Dog 的 watchHouse        &#125;    &#125;  &#125;</code></pre><h1 id="第二章-内部类"><a href="#第二章-内部类" class="headerlink" title="第二章 内部类"></a>第二章 内部类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><h3 id="2-1-1-什么是内部类"><a href="#2-1-1-什么是内部类" class="headerlink" title="2.1.1 什么是内部类"></a>2.1.1 什么是内部类</h3><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<strong>内部类</strong>，B则称为<strong>外部类</strong>。可以把内部类理解成寄生，外部类理解成宿主。</p><p>内部类是Java类的五大成份之一，也是我们最后一个需要学习的成份。</p><h3 id="2-1-2-什么时候使用内部类"><a href="#2-1-2-什么时候使用内部类" class="headerlink" title="2.1.2 什么时候使用内部类"></a>2.1.2 什么时候使用内部类</h3><p>一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用</p><ol><li>人里面有一颗心脏。</li><li>汽车内部有一个发动机。</li><li>为了实现更好的封装性。</li></ol><h2 id="2-2-内部类的分类"><a href="#2-2-内部类的分类" class="headerlink" title="2.2 内部类的分类"></a>2.2 内部类的分类</h2><p>按定义的位置来分</p><ol><li><strong>静态内部类</strong>，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)</li><li><strong>实例内部内</strong>，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)</li><li><strong>局部内部类</strong>，类定义在方法内</li><li><strong>匿名内部类</strong>。一般定义在方法中，或者可执行代码中</li></ol><h2 id="2-3-静态内部类"><a href="#2-3-静态内部类" class="headerlink" title="2.3 静态内部类"></a>2.3 静态内部类</h2><p><strong>静态内部类特点</strong>：</p><ul><li>有static修饰的内部类，属于外部类本身的。</li><li>总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。</li><li><strong>拓展</strong>:静态内部类可以直接访问外部类的静态成员。</li></ul><p><strong>内部类的使用格式</strong>：</p><pre><code>外部类.内部类。</code></pre><p><strong>静态内部类对象的创建格式</strong>：</p><pre><code class="java">外部类.内部类  变量 = new  外部类.内部类构造器;</code></pre><p><strong>案例演示</strong>：</p><pre><code class="java">// 外部类：Outer01class Outer01&#123;    private static  String sc_name = &quot;黑马程序&quot;;    // 内部类: Inner01    public static class Inner01&#123;        // 这里面的东西与类是完全一样的。        private String name;        public Inner01(String name) &#123;            this.name = name;        &#125;        public void showName()&#123;            System.out.println(this.name);            // 拓展:静态内部类可以直接访问外部类的静态成员。            System.out.println(sc_name);        &#125;    &#125;&#125;public class InnerClassDemo01 &#123;    public static void main(String[] args) &#123;        // 创建静态内部类对象。        // 外部类.内部类  变量 = new  外部类.内部类构造器;        Outer01.Inner01 in  = new Outer01.Inner01(&quot;张三&quot;);        in.showName();    &#125;&#125;</code></pre><h2 id="2-4-实例内部类"><a href="#2-4-实例内部类" class="headerlink" title="2.4 实例内部类"></a>2.4 实例内部类</h2><p><strong>实例内部类特点</strong>：</p><ul><li>无static修饰的内部类，属于外部类对象的。</li><li>宿主：外部类对象。</li></ul><p><strong>内部类的使用格式</strong>：</p><pre><code class="java"> 外部类.内部类。 // 访问内部类的类型都是用 外部类.内部类</code></pre><p><strong>实例内部类创建对象格式</strong>：</p><pre><code>外部类.内部类 变量 = new 外部类构造器.new 内部类构造器;</code></pre><ul><li><p>拓展1：实例内部类不能定义静态成员。</p></li><li><p>拓展2：实例内部类可以直接访问外部类的私有和静态成员。</p><p><strong>案例演示</strong></p></li></ul><pre><code class="java">public class InnerClassDemo02 &#123;    public static void main(String[] args) &#123;        //  宿主：外部类对象。       // Outer02 out = new Outer02();        // 创建内部类对象。        Outer02.Inner02 in = new Outer02().new Inner02(&quot;张三&quot;);        in.showName();    &#125;&#125;class Outer02&#123;    // 实例内部类，属于外部类对象的。    // 拓展：实例内部类不能定义静态成员。    public class Inner02&#123;        // 这里面的东西与类是完全一样的。        private String name;        public Inner02(String name) &#123;            this.name = name;        &#125;        public void showName()&#123;            System.out.println(this.name);        &#125;    &#125;&#125;</code></pre><h2 id="2-5-实例内部类面试题"><a href="#2-5-实例内部类面试题" class="headerlink" title="2.5 实例内部类面试题"></a>2.5 实例内部类面试题</h2><p>请在?地方向上相应代码,以达到输出的内容</p><p>注意：内部类访问外部类对象的格式是：<strong>外部类名.this</strong></p><pre><code class="java">public class Demo05 &#123;    public static void main(String[] args) &#123;        Body.Heart heart = new Body().new Heart();        heart.jump();    &#125;&#125;class Body &#123;    // 身体    private int weight = 30;    // 在成员位置定义一个类    class Heart &#123;        private int weight = 20;        public void jump() &#123;            int weight = 10;            System.out.println(&quot;心脏在跳动 &quot; + ?);    // 10            System.out.println(&quot;心脏在跳动 &quot; + ?);    // 20            System.out.println(&quot;心脏在跳动 &quot; + ?);    // 30        &#125;    &#125;&#125;</code></pre><h2 id="2-6-局部内部类"><a href="#2-6-局部内部类" class="headerlink" title="2.6 局部内部类"></a>2.6 局部内部类</h2><ul><li><strong>局部内部类</strong> ：定义在<strong>方法中</strong>的类。</li></ul><p>定义格式:</p><pre><code class="java">class 外部类名 &#123;    数据类型 变量名;        修饰符 返回值类型 方法名(参数列表) &#123;        // …        class 内部类 &#123;            // 成员变量            // 成员方法        &#125;    &#125;&#125;</code></pre><blockquote><p>局部内部类编译后仍然是一个独立的类，编译后有$还有一个数字。Chinese$1Chopsticks.class</p></blockquote><h2 id="2-7-匿名内部类【重点】"><a href="#2-7-匿名内部类【重点】" class="headerlink" title="2.7 匿名内部类【重点】"></a>2.7 匿名内部类【重点】</h2><h3 id="2-7-1-概述"><a href="#2-7-1-概述" class="headerlink" title="2.7.1 概述"></a>2.7.1 概述</h3><p><strong>匿名内部类</strong> ：是内部类的简化写法。它的本质是一个<code>带具体实现的</code> <code>父类或者父接口的</code> <code>匿名的</code> <strong>子类对象</strong>。<br>开发中，最常用到的内部类就是匿名内部类了。</p><h3 id="2-7-2-引入"><a href="#2-7-2-引入" class="headerlink" title="2.7.2 引入"></a>2.7.2 引入</h3><p><strong>实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用</strong></p><p><strong>是为了简化代码</strong>。 </p><p>之前我們使用接口时，似乎得做如下几步操作：</p><ol><li>定义子类</li><li>重写接口中的方法</li><li>创建子类对象</li><li>调用重写后的方法</li></ol><pre><code class="java">interface Swim &#123;    public abstract void swimming();&#125;// 1. 定义接口的实现类class Student implements Swim &#123;    // 2. 重写抽象方法    @Override    public void swimming() &#123;        System.out.println(&quot;狗刨式...&quot;);    &#125;&#125;public class Demo07 &#123;    public static void main(String[] args) &#123;        // 3. 创建实现类对象        Student s = new Student();        // 4. 调用方法        s.swimming();    &#125;&#125;</code></pre><p>我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。</p><h3 id="2-7-3-匿名内部类前提和格式"><a href="#2-7-3-匿名内部类前提和格式" class="headerlink" title="2.7.3 匿名内部类前提和格式"></a>2.7.3 匿名内部类前提和格式</h3><p>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p><p><strong>匿名内部类格式</strong></p><pre><code class="java">new 父类名或者接口名()&#123;    // 方法重写    @Override     public void method() &#123;        // 执行语句    &#125;&#125;;</code></pre><h3 id="2-7-4-使用方式"><a href="#2-7-4-使用方式" class="headerlink" title="2.7.4 使用方式"></a>2.7.4 使用方式</h3><p>以接口为例，匿名内部类的使用，代码如下：</p><p>创建匿名内部类，并调用：GUI做界面</p><pre><code class="java">interface Swim &#123;    public abstract void swimming();&#125;public class Demo07 &#123;    public static void main(String[] args) &#123;        // 使用匿名内部类        new Swim() &#123;            @Override            public void swimming() &#123;                System.out.println(&quot;自由泳...&quot;);            &#125;        &#125;.swimming();        // 接口 变量 = new 实现类(); // 多态,走子类的重写方法        Swim s2 = new Swim() &#123;            @Override            public void swimming() &#123;                System.out.println(&quot;蛙泳...&quot;);            &#125;        &#125;;        s2.swimming();        s2.swimming();    &#125;&#125;</code></pre><h3 id="2-7-5-匿名内部类的特点"><a href="#2-7-5-匿名内部类的特点" class="headerlink" title="2.7.5 匿名内部类的特点"></a>2.7.5 匿名内部类的特点</h3><ol><li>定义一个没有名字的内部类</li><li>这个类实现了父类，或者父类接口</li><li>匿名内部类会创建这个没有名字的类的对象</li></ol><h3 id="2-7-6-匿名内部类的使用场景"><a href="#2-7-6-匿名内部类的使用场景" class="headerlink" title="2.7.6 匿名内部类的使用场景"></a>2.7.6 匿名内部类的使用场景</h3><p>通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：</p><pre><code class="java">interface Swim &#123;    public abstract void swimming();&#125;public class Demo07 &#123;    public static void main(String[] args) &#123;        // 普通方式传入对象        // 创建实现类对象        Student s = new Student();                goSwimming(s);        // 匿名内部类使用场景:作为方法参数传递        Swim s3 = new Swim() &#123;            @Override            public void swimming() &#123;                System.out.println(&quot;蝶泳...&quot;);            &#125;        &#125;;        // 传入匿名内部类        goSwimming(s3);        // 完美方案: 一步到位        goSwimming(new Swim() &#123;            public void swimming() &#123;                System.out.println(&quot;大学生, 蛙泳...&quot;);            &#125;        &#125;);        goSwimming(new Swim() &#123;            public void swimming() &#123;                System.out.println(&quot;小学生, 自由泳...&quot;);            &#125;        &#125;);    &#125;    // 定义一个方法,模拟请一些人去游泳    public static void goSwimming(Swim s) &#123;        s.swimming();    &#125;&#125;</code></pre><h1 id="第三章-包和权限修饰符"><a href="#第三章-包和权限修饰符" class="headerlink" title="第三章 包和权限修饰符"></a>第三章 包和权限修饰符</h1><h2 id="3-1-包"><a href="#3-1-包" class="headerlink" title="3.1 包"></a>3.1 包</h2><p>包我们每天建的项目就是在一个目录下，我们每次都会建立一个包，这个包在磁盘下其实就是一个目录。<strong>包是用来分门别类的管理技术，不同的技术类放在不同的包下</strong>，方便管理和维护。</p><p>在IDEA项目中，建包的操作如下：</p><p><img src="/img/java/imgs3/aaa.jpg"></p><p><strong>包名的命名规范</strong>：</p><pre><code>路径名.路径名.xxx.xxx// 例如：com.itheima.oa</code></pre><ul><li>包名一般是公司域名的倒写。例如：黑马是<a href="http://www.itheima.com,包名就可以定义成com.itheima.技术名称./">www.itheima.com,包名就可以定义成com.itheima.技术名称。</a></li><li>包名必须用”.“连接。</li><li>包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。</li></ul><h2 id="3-2-权限修饰符"><a href="#3-2-权限修饰符" class="headerlink" title="3.2 权限修饰符"></a>3.2 权限修饰符</h2><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和缺省（default默认）修饰符的作用。</p><ul><li>public：公共的，所有地方都可以访问。</li><li>protected：当前类 ，当前包，当前类的子类可以访问。</li><li>缺省（没有修饰符）：当前类 ，当前包可以访问。</li><li>private：私有的，当前类可以访问。<br><code>public &gt; protected &gt; 缺省 &gt; private</code></li></ul><h2 id="3-3-不同权限的访问能力"><a href="#3-3-不同权限的访问能力" class="headerlink" title="3.3 不同权限的访问能力"></a>3.3 不同权限的访问能力</h2><table><thead><tr><th></th><th>public</th><th>protected</th><th>缺省（空的）</th><th>private</th></tr></thead><tbody><tr><td>同一类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一包中的类</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不同包的子类</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>不同包中的无关类</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><p>可见，public具有最大权限。private则是最小权限。</p><p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p><ul><li>成员变量使用<code>private</code> ，隐藏细节。</li><li>构造方法使用<code> public</code> ，方便创建对象。</li><li>成员方法使用<code>public</code> ，方便调用方法。</li></ul><blockquote><p>小贴士：不加权限修饰符，就是default权限</p></blockquote><h1 id="第四章-Object类"><a href="#第四章-Object类" class="headerlink" title="第四章 Object类"></a>第四章 Object类</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p><p>如果一个类没有特别指定父类，    那么默认则继承自Object类。例如：</p><pre><code class="java">public class MyClass /*extends Object*/ &#123;      // ...&#125;</code></pre><p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><h2 id="4-2-toString方法"><a href="#4-2-toString方法" class="headerlink" title="4.2 toString方法"></a>4.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p><pre><code class="java">public class Person &#123;      private String name;    private int age;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; + &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; + &quot;, age=&quot; + age + &#39;&#125;&#39;;    &#125;    // 省略构造器与Getter Setter&#125;</code></pre><p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。如下图所示：</p><p><img src="/img/java/imgs3%5CtoString%E6%96%B9%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E9%87%8D%E5%86%99.bmp" alt="toString方法的自动重写"></p><blockquote><p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p></blockquote><h2 id="4-3-equals方法"><a href="#4-3-equals方法" class="headerlink" title="4.3 equals方法"></a>4.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p><h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p><h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p><pre><code class="java">import java.util.Objects;public class Person &#123;        private String name;    private int age;        @Override    public boolean equals(Object o) &#123;        // 如果对象地址一样，则认为相同        if (this == o)            return true;        // 如果参数为空，或者类型信息不一样，则认为不同        if (o == null || getClass() != o.getClass())            return false;        // 转换为当前类型        Person person = (Person) o;        // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果        return age == person.age &amp;&amp; Objects.equals(name, person.name);    &#125;&#125;</code></pre><p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成。如下图所示：</p><p><img src="/img/java/imgs3%5Cequals%E6%96%B9%E6%B3%951.png"></p><p><img src="/img/java/imgs3%5Cequals%E6%96%B9%E6%B3%952.png"></p><p><img src="/img/java/imgs3%5Cequals%E6%96%B9%E6%B3%953.png"></p><blockquote><p>tips：Object类当中的hashCode等其他方法，今后学习。</p></blockquote><h1 id="第五章-Objects类"><a href="#第五章-Objects类" class="headerlink" title="第五章 Objects类"></a>第五章 Objects类</h1><p>Objects类是对象工具类，它里面的的方法都是用来操作对象的。</p><h2 id="5-1-equals方法"><a href="#5-1-equals方法" class="headerlink" title="5.1 equals方法"></a>5.1 equals方法</h2><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p><p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p><p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p><ul><li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li></ul><p>我们可以查看一下源码，学习一下：</p><pre><code class="java">public static boolean equals(Object a, Object b) &#123;      return (a == b) || (a != null &amp;&amp; a.equals(b));  </code></pre><h2 id="5-2-isNull"><a href="#5-2-isNull" class="headerlink" title="5.2 isNull"></a>5.2 isNull</h2><p>static boolean isNull(Object obj) 判断对象是否为null，如果为null返回true。</p><pre><code class="java">Student s1 = null;Student s2 = new Student(&quot;蔡徐坤&quot;, 22);// static boolean isNull(Object obj) 判断对象是否为null,如果为null返回trueSystem.out.println(Objects.isNull(s1)); // trueSystem.out.println(Objects.isNull(s2)); // false</code></pre><h1 id="第六章-Date类"><a href="#第六章-Date类" class="headerlink" title="第六章 Date类"></a>第六章 Date类</h1><h2 id="6-1-Date概述"><a href="#6-1-Date概述" class="headerlink" title="6.1 Date概述"></a>6.1 Date概述</h2><p>java.util.Date`类 表示特定的瞬间，精确到毫秒。</p><p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，我们重点看以下两个构造函数</p><ul><li><code>public Date()</code>：从运行程序的此时此刻到时间原点经历的毫秒值,转换成Date对象，分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li><code>public Date(long date)</code>：将指定参数的毫秒值date,转换成Date对象，分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li></ul><blockquote><p>tips: 由于中国处于东八区（GMT+08:00）是比世界协调时间/格林尼治时间（GMT）快8小时的时区，当格林尼治标准时间为0:00时，东八区的标准时间为08:00。</p></blockquote><p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p><pre><code class="java">import java.util.Date;public class Demo01Date &#123;    public static void main(String[] args) &#123;        // 创建日期对象，把当前的时间        System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2020        // 创建日期对象，把当前的毫秒值转成日期对象        System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970    &#125;&#125;</code></pre><blockquote><p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p></blockquote><h2 id="6-2-Date常用方法"><a href="#6-2-Date常用方法" class="headerlink" title="6.2 Date常用方法"></a>6.2 Date常用方法</h2><p>Date类中的多数方法已经过时，常用的方法有：</p><ul><li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li><li><code>public void setTime(long time)</code> 把方法参数给定的毫秒值设置给日期对象</li></ul><p>示例代码</p><pre><code class="java">public class DateDemo02 &#123;    public static void main(String[] args) &#123;        //创建日期对象        Date d = new Date();                //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值        //System.out.println(d.getTime());        //System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + &quot;年&quot;);        //public void setTime(long time):设置时间，给的是毫秒值        //long time = 1000*60*60;        long time = System.currentTimeMillis();        d.setTime(time);        System.out.println(d);    &#125;&#125;</code></pre><blockquote><p>小结：Date表示特定的时间瞬间，我们可以使用Date对象对时间进行操作。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day03【多态、包、权限修饰符、内部类，Object类-Date类】&quot;&gt;&lt;a href=&quot;#day03【多态、包、权限修饰符、内部类，Object类-Date类】&quot; class=&quot;headerlink&quot; title=&quot;day03【多态、包、权限修饰符、内部类，O</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java进阶13天资料" scheme="http://example.com/tags/java%E8%BF%9B%E9%98%B613%E5%A4%A9%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Day02</title>
    <link href="http://example.com/2021/09/05/JAVA/day02-%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81final%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E6%9E%9A%E4%B8%BE/"/>
    <id>http://example.com/2021/09/05/JAVA/day02-%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81final%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E6%9E%9A%E4%B8%BE/</id>
    <published>2021-09-05T02:31:46.000Z</published>
    <updated>2021-09-05T03:02:39.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day02【抽象类，接口、代码块、final、单例、枚举】"><a href="#day02【抽象类，接口、代码块、final、单例、枚举】" class="headerlink" title="day02【抽象类，接口、代码块、final、单例、枚举】"></a>day02【抽象类，接口、代码块、final、单例、枚举】</h1><h2 id="今日内容-记住语法"><a href="#今日内容-记住语法" class="headerlink" title="今日内容(记住语法)"></a>今日内容(记住语法)</h2><ul><li>抽象类<ul><li>拥有抽象方法的类就是抽象类。</li><li>抽象方法：是只有方法签名没有方法体，必须用abstract修饰。</li><li>抽象类本身也要用abstract修饰的，作用是让子类继承，子类一定要重写抽象方法。</li><li>模板思想，设计模板模式。</li></ul></li><li>接口<ul><li>更加彻底的抽象，接口中全部是抽象方法和常量（JDK1.8之后）</li><li>接口体现的是规范思想，实现接口的类必须重写完接口的全部抽象方法，否则这个类必须是抽象类。 </li><li>JDK 1.8之后的接口新增了三个方法。接口不再纯洁。</li></ul></li><li>代码块（成员变量，方法，构造器，代码块，内部类）</li><li>final关键字<ul><li>final是最终的意思。可以修饰类，变量，和方法。</li><li>修饰类：类不能被继承。类绝育了。</li><li>修饰方法：方法不能被重写。</li><li>修饰变量：变量有且仅能被赋值一次。</li></ul></li><li>单例设计模式<ul><li>设计模式，面试必考，经典模式。</li></ul></li><li>枚举<ul><li>面向对象的一种特殊类型，做信息分类和信息标志的。</li></ul></li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><p><input checked="" disabled="" type="checkbox">  能够写出抽象类的格式</p><ul><li><input disabled="" type="checkbox"> <strong>abstract</strong> class Animal{</li><li><input disabled="" type="checkbox"> }</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  能够写出抽象方法的格式</p><ul><li><input disabled="" type="checkbox"> <strong>public abstract void run();</strong></li><li><input disabled="" type="checkbox"> 只有方法签名，没有方法体，必须用abstract修饰。</li></ul></li><li><p><input disabled="" type="checkbox">  父类抽象方法的意义</p><ul><li><input disabled="" type="checkbox"> 被子类继承</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  写出定义接口的格式</p><ul><li><p><input disabled="" type="checkbox">  public <strong>interface</strong> SportMan{</p><p>​        </p></li><li><p><input disabled="" type="checkbox">  }</p></li></ul></li><li><p><input checked="" disabled="" type="checkbox">  写出实现接口的格式</p><ul><li><input disabled="" type="checkbox"> 修饰符 class 实现类  <strong>implements</strong>  接口1 , 接口2{</li><li><input disabled="" type="checkbox"> }</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  说出接口中成员的特点</p><ul><li><input disabled="" type="checkbox"> JDK 1.8之前全部是抽象方法和常量，其他都没有。</li><li><input disabled="" type="checkbox"> JDK 1.8之后，有了静态方法，默认方法，JDK 1.9之后有了私有方法。</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  描述final修饰的类的特点</p><ul><li><input disabled="" type="checkbox"> 类不能被继承</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  描述final修饰的方法的特点</p><ul><li><input disabled="" type="checkbox"> 方法不能被重写了</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  描述final修饰的变量的特点</p><ul><li><input disabled="" type="checkbox"> 变量有且仅能被赋值一次</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  能够写出静态代码块的</p><ul><li><input disabled="" type="checkbox"> static{ </li><li><input disabled="" type="checkbox"> }</li></ul></li></ul><h1 id="第一章-抽象类"><a href="#第一章-抽象类" class="headerlink" title="第一章 抽象类"></a>第一章 抽象类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><h3 id="1-1-1-抽象类引入"><a href="#1-1-1-抽象类引入" class="headerlink" title="1.1.1 抽象类引入"></a>1.1.1 抽象类引入</h3><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类完全只需要提供一个没有方法体的方法签名即可，具体实现交给子类自己去实现。<strong>我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类</strong>。</p><ul><li><strong>抽象方法</strong> ： 没有方法体的方法。</li><li><strong>抽象类</strong>：包含抽象方法的类。</li></ul><h2 id="1-2-abstract使用格式"><a href="#1-2-abstract使用格式" class="headerlink" title="1.2 abstract使用格式"></a>1.2 abstract使用格式</h2><p><strong>abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。</strong></p><h3 id="1-2-1-抽象方法"><a href="#1-2-1-抽象方法" class="headerlink" title="1.2.1 抽象方法"></a>1.2.1 抽象方法</h3><p>使用<code>abstract</code> 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>定义格式：</p><pre><code class="java">修饰符 abstract 返回值类型 方法名 (参数列表)；</code></pre><p>代码举例：</p><pre><code class="java">public abstract void run()；</code></pre><h3 id="1-2-2-抽象类"><a href="#1-2-2-抽象类" class="headerlink" title="1.2.2 抽象类"></a>1.2.2 抽象类</h3><p>如果一个类包含抽象方法，那么该类必须是抽象类。<strong>注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。</strong></p><p>定义格式：</p><pre><code class="java">abstract class 类名字 &#123;   &#125;</code></pre><p>代码举例：</p><pre><code class="java">public abstract class Animal &#123;    public abstract void run()；&#125;</code></pre><h3 id="1-2-3-抽象类的使用"><a href="#1-2-3-抽象类的使用" class="headerlink" title="1.2.3 抽象类的使用"></a>1.2.3 抽象类的使用</h3><p><strong>要求</strong>：继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。否则，该子类也必须声明为抽象类。</p><p>代码举例：</p><pre><code class="java">// 父类,抽象类abstract class Employee &#123;    private String id;    private String name;    private double salary;        public Employee() &#123;    &#125;        public Employee(String id, String name, double salary) &#123;        this.id = id;        this.name = name;        this.salary = salary;    &#125;        // 抽象方法    // 抽象方法必须要放在抽象类中    abstract public void work();&#125;// 定义一个子类继承抽象类class Manager extends Employee &#123;    public Manager() &#123;    &#125;    public Manager(String id, String name, double salary) &#123;        super(id, name, salary);    &#125;    // 2.重写父类的抽象方法    @Override    public void work() &#123;        System.out.println(&quot;管理其他人&quot;);    &#125;&#125;// 定义一个子类继承抽象类class Cook extends Employee &#123;    public Cook() &#123;    &#125;    public Cook(String id, String name, double salary) &#123;        super(id, name, salary);    &#125;    @Override    public void work() &#123;        System.out.println(&quot;厨师炒菜多加点盐...&quot;);    &#125;&#125;// 测试类public class Demo10 &#123;    public static void main(String[] args) &#123;        // 创建抽象类,抽象类不能创建对象        // 假设抽象类让我们创建对象,里面的抽象方法没有方法体,无法执行.所以不让我们创建对象//        Employee e = new Employee();//        e.work();                // 3.创建子类        Manager m = new Manager();        m.work();                Cook c = new Cook(&quot;ap002&quot;, &quot;库克&quot;, 1);        c.work();    &#125;&#125;</code></pre><p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p><h2 id="1-3-抽象类的特征"><a href="#1-3-抽象类的特征" class="headerlink" title="1.3 抽象类的特征"></a>1.3 抽象类的特征</h2><p>抽象类的特征总结起来可以说是 <strong>有得有失</strong></p><p><strong>有得：抽象类得到了拥有抽象方法的能力。</strong></p><p><strong>有失：抽象类失去了创建对象的能力。</strong></p><p>其他成员（构造器，实例方法，静态方法等）抽象类都是具备的。</p><h2 id="1-4-抽象类的注意事项"><a href="#1-4-抽象类的注意事项" class="headerlink" title="1.4 抽象类的注意事项"></a>1.4 抽象类的注意事项</h2><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p><ol><li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p><blockquote><p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></blockquote></li><li><p>抽象类中，可以有构造器，是供子类创建对象时，初始化父类成员使用的。</p><blockquote><p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p></blockquote></li><li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><blockquote><p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p></blockquote></li><li><p>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。 </p><blockquote><p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p></blockquote></li><li><p>抽象类存在的意义是为了被子类继承，抽象类体现的是模板思想。</p><blockquote><p>理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。</p></blockquote></li></ol><h2 id="1-5-抽象类存在的意义"><a href="#1-5-抽象类存在的意义" class="headerlink" title="1.5 抽象类存在的意义"></a>1.5 抽象类存在的意义</h2><p>抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义，<strong>抽象类体现的是模板思想</strong>，模板是通用的东西抽象类中已经是具体的实现（抽象类中可以有成员变量和实现方法），而模板中不能决定的东西定义成抽象方法，让使用模板（继承抽象类的类）的类去重写抽象方法实现需求，这是典型的模板思想。</p><h2 id="1-6-第一个设计模式：模板模式"><a href="#1-6-第一个设计模式：模板模式" class="headerlink" title="1.6 第一个设计模式：模板模式"></a>1.6 第一个设计模式：模板模式</h2><p>我们现在使用抽象类设计一个模板模式的应用，例如在小学的时候，我们经常写作文，通常都是有模板可以套用的。假如我现在需要定义新司机和老司机类，新司机和老司机都有开车功能，开车的步骤都一样，只是驾驶时的姿势有点不同，<code>新司机:开门,点火,双手紧握方向盘,刹车,熄火</code>，<code>老司机:开门,点火,右手握方向盘左手抽烟,刹车,熄火</code>。我们可以将固定流程写到父类中，不同的地方就定义成抽象方法，让不同的子类去重写，代码如下:</p><pre><code class="java">// 司机开车的模板类public abstract class Driver &#123;    public void go() &#123;        System.out.println(&quot;开门&quot;);        System.out.println(&quot;点火&quot;);        // 开车姿势不确定?定义为抽象方法        ziShi();        System.out.println(&quot;刹车&quot;);        System.out.println(&quot;熄火&quot;);    &#125;    public abstract void ziShi();&#125;</code></pre><p>现在定义两个使用模板的司机：</p><pre><code class="java">public class NewDriver extends Driver &#123;    @Override    public void ziShi() &#123;        System.out.println(&quot;新司机双手紧握方向盘&quot;);    &#125;&#125;public class OldDriver extends Driver &#123;    @Override    public void ziShi() &#123;        System.out.println(&quot;老司机右手握方向盘左手抽烟...&quot;);    &#125;&#125;</code></pre><p>编写测试类</p><pre><code class="java">public class Demo02 &#123;    public static void main(String[] args) &#123;        NewDriver nd = new NewDriver();        nd.go();        OldDriver od = new OldDriver();        od.go();    &#125;&#125;</code></pre><p>运行效果</p><p><img src="assets/1560747035458.png" alt="1560747035458"></p><p><strong>可以看出，模板模式的优势是，模板已经定义了通用架构，使用者只需要关心自己需要实现的功能即可！非常的强大！</strong></p><h1 id="第二章-接口"><a href="#第二章-接口" class="headerlink" title="第二章 接口"></a>第二章 接口</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>我们已经学完了抽象类，抽象类中可以用抽象方法，也可以有普通方法，已经构造器，成员变量等。那么什么是接口呢？<strong>接口是更加彻底的抽象，接口中全部是抽象方法。（JDK8之前），接口同样是不能创建对象的</strong>。</p><h2 id="2-2-定义格式"><a href="#2-2-定义格式" class="headerlink" title="2.2 定义格式"></a>2.2 定义格式</h2><pre><code class="java">//接口的定义格式：修饰符 interface 接口名称&#123;    // 抽象方法&#125;// 修饰符：public|缺省// 接口的声明：interface// 接口名称：首字母大写，满足“驼峰模式”</code></pre><h2 id="2-3-接口成分的特点"><a href="#2-3-接口成分的特点" class="headerlink" title="2.3 接口成分的特点"></a>2.3 接口成分的特点</h2><p>  在JDK8之前，接口中的成分包含：抽象方法和常量</p><h3 id="2-3-1-抽象方法"><a href="#2-3-1-抽象方法" class="headerlink" title="2.3.1.抽象方法"></a>2.3.1.抽象方法</h3><p>​       注意：接口中的抽象方法默认会自动加上public abstract修饰程序员无需自己手写！！<br>​       按照规范：以后接口中的抽象方法建议不要写上public abstract。因为没有必要啊，默认会加上。</p><h3 id="2-3-2-常量"><a href="#2-3-2-常量" class="headerlink" title="2.3.2 常量"></a>2.3.2 常量</h3><p> 在接口中定义的成员变量默认会加上： public static final修饰。也就是说在接口中定义的成员变量实际上是一个常量。这里是使用public static final修饰后，变量值就不可被修改，并且是静态化的变量可以直接用接口名访问，所以也叫常量。常量必须要给初始值。常量命名规范建议字母全部大写，多个单词用下划线连接。</p><h3 id="2-3-3-案例演示"><a href="#2-3-3-案例演示" class="headerlink" title="2.3.3 案例演示"></a>2.3.3 案例演示</h3><pre><code class="java">public interface InterF &#123;    // 抽象方法！    //    public abstract void run();    void run();    //    public abstract String getName();    String getName();    //    public abstract int add(int a , int b);    int add(int a , int b);    // 它的最终写法是：    // public static final int AGE = 12 ;    int AGE  = 12; //常量    String SCHOOL_NAME = &quot;黑马程序员&quot;;&#125;</code></pre><h2 id="2-4-基本的实现"><a href="#2-4-基本的实现" class="headerlink" title="2.4 基本的实现"></a>2.4 基本的实现</h2><h3 id="2-4-1-实现接口的概述"><a href="#2-4-1-实现接口的概述" class="headerlink" title="2.4.1 实现接口的概述"></a>2.4.1 实现接口的概述</h3><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code> implements</code>关键字。</p><h3 id="2-4-2-实现接口的格式"><a href="#2-4-2-实现接口的格式" class="headerlink" title="2.4.2 实现接口的格式"></a>2.4.2 实现接口的格式</h3><pre><code class="java">/**接口的实现：    在Java中接口是被实现的，实现接口的类称为实现类。    实现类的格式:*/[修饰符] class 类名 implements 接口1,接口2,接口3...&#123;&#125;</code></pre><p>从上面格式可以看出，接口是可以被多实现的。大家可以想一想为什么呢？</p><h3 id="2-4-3-类实现接口的要求和意义"><a href="#2-4-3-类实现接口的要求和意义" class="headerlink" title="2.4.3 类实现接口的要求和意义"></a>2.4.3 类实现接口的要求和意义</h3><ol><li>必须重写实现的全部接口中所有抽象方法。</li><li>如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。</li><li><strong>意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。</strong></li></ol><h3 id="2-4-4-类与接口基本实现案例"><a href="#2-4-4-类与接口基本实现案例" class="headerlink" title="2.4.4  类与接口基本实现案例"></a>2.4.4  类与接口基本实现案例</h3><p>假如我们定义一个运动员的<strong>接口</strong>（规范），代码如下：</p><pre><code class="java">/**   接口：接口体现的是规范。 * */public interface SportMan &#123;    void run(); // 抽象方法，跑步。    void law(); // 抽象方法，遵守法律。    String compittion(String project);  // 抽象方法，比赛。&#125;</code></pre><p>接下来定义一个乒乓球运动员类，实现接口，实现接口的<strong>实现类</strong>代码如下：</p><pre><code class="java">package com.itheima._03接口的实现;/** * 接口的实现： *    在Java中接口是被实现的，实现接口的类称为实现类。 *    实现类的格式: *      [修饰符] class 类名 implements 接口1,接口2,接口3...&#123; * * *      &#125; * */public class PingPongMan  implements SportMan &#123;    @Override    public void run() &#123;        System.out.println(&quot;乒乓球运动员稍微跑一下！！&quot;);    &#125;    @Override    public void law() &#123;        System.out.println(&quot;乒乓球运动员守法！&quot;);    &#125;    @Override    public String compittion(String project) &#123;        return &quot;参加&quot;+project+&quot;得金牌！&quot;;    &#125;&#125;</code></pre><p><strong>测试代码</strong>：</p><pre><code class="java">public class TestMain &#123;    public static void main(String[] args) &#123;        // 创建实现类对象。        PingPongMan zjk = new PingPongMan();        zjk.run();        zjk.law();        System.out.println(zjk.compittion(&quot;全球乒乓球比赛&quot;));    &#125;&#125;</code></pre><h3 id="1-4-5-类与接口的多实现案例"><a href="#1-4-5-类与接口的多实现案例" class="headerlink" title="1.4.5 类与接口的多实现案例"></a>1.4.5 类与接口的多实现案例</h3><p><strong>类与接口之间的关系是多实现的，一个类可以同时实现多个接口。</strong></p><p>首先我们先定义两个接口，代码如下：</p><pre><code class="java">/** 法律规范：接口*/public interface Law &#123;    void rule();&#125;/** 这一个运动员的规范：接口*/public interface SportMan &#123;    void run();&#125;</code></pre><p>然后定义一个实现类：</p><pre><code class="java">/** * Java中接口是可以被多实现的： *    一个类可以实现多个接口: Law ,SportMan * * */public class JumpMan implements Law ,SportMan &#123;    @Override    public void rule() &#123;        System.out.println(&quot;尊长守法&quot;);    &#125;    @Override    public void run() &#123;        System.out.println(&quot;训练跑步！&quot;);    &#125;&#125;</code></pre><p>从上面可以看出类与接口之间是可以多实现的，我们可以理解成实现多个规范，这是合理的。</p><h2 id="2-5-接口与接口的多继承"><a href="#2-5-接口与接口的多继承" class="headerlink" title="2.5 接口与接口的多继承"></a>2.5 接口与接口的多继承</h2><p>Java中，接口与接口之间是可以多继承的：也就是一个接口可以同时继承多个接口。大家一定要注意：</p><p><strong>类与接口是实现关系</strong></p><p><strong>接口与接口是继承关系</strong></p><p>接口继承接口就是把其他接口的抽象方法与本接口进行了合并。</p><p>案例演示：</p><pre><code class="java">public interface Abc &#123;    void go();    void test();&#125;/** 法律规范：接口*/public interface Law &#123;    void rule();    void test();&#125; * *  总结： *     接口与类之间是多实现的。 *     接口与接口之间是多继承的。 * */public interface SportMan extends Law , Abc &#123;    void run();&#125;</code></pre><h2 id="2-6-JDK-8之后的接口新增方法"><a href="#2-6-JDK-8之后的接口新增方法" class="headerlink" title="2.6 JDK 8之后的接口新增方法"></a>2.6 JDK 8之后的接口新增方法</h2><p>从JDK 8开始之后，接口不再纯洁了，接口中不再只是抽象方法，接口还可以有<strong>默认方法</strong>（也就是实例方法），和<strong>静态方法</strong>了，还包含了私有实例方法和私有静态方法</p><h3 id="2-6-1-含有默认方法和静态方法"><a href="#2-6-1-含有默认方法和静态方法" class="headerlink" title="2.6.1 含有默认方法和静态方法"></a>2.6.1 含有默认方法和静态方法</h3><p><strong>默认方法：使用 <code>default</code> 修饰，不可省略，供子类调用或者子类重写。</strong></p><p><strong>静态方法：使用 <code>static</code> 修饰，供接口直接调用。</strong></p><p>代码如下：</p><pre><code class="java">public interface InterFaceName &#123;    public default void method() &#123;        // 执行语句    &#125;    public static void method2() &#123;        // 执行语句        &#125;&#125;</code></pre><h3 id="2-6-2-含有私有方法和私有静态方法"><a href="#2-6-2-含有私有方法和私有静态方法" class="headerlink" title="2.6.2 含有私有方法和私有静态方法"></a>2.6.2 含有私有方法和私有静态方法</h3><p>私有方法：使用 <code>private</code> 修饰，供接口中的默认方法或者静态方法调用。</p><p>代码如下：</p><pre><code class="java">public interface InterFaceName &#123;    private void method() &#123;        // 执行语句    &#125;&#125;</code></pre><h3 id="2-6-3-新增方法的使用"><a href="#2-6-3-新增方法的使用" class="headerlink" title="2.6.3 新增方法的使用"></a>2.6.3 新增方法的使用</h3><p><strong>默认方法和静态方法以及私有方法和私有静态方法</strong>，<strong>遵循面向对象的继承关系使用原则，实现类依然可以访问接口的非私有方法，对于接口中的非私有静态方法，可以直接通过接口名进行访问。</strong></p><p>重写默认方法注意（了解）:</p><ul><li><p>子接口重写默认方法时，default关键字可以保留。</p></li><li><p>实现类重写默认方法时，default关键字不可以保留。</p></li></ul><h2 id="2-7-实现多个接口使用注意事项"><a href="#2-7-实现多个接口使用注意事项" class="headerlink" title="2.7 实现多个接口使用注意事项"></a>2.7 实现多个接口使用注意事项</h2><h3 id="2-7-1-多个接口同名静态方法"><a href="#2-7-1-多个接口同名静态方法" class="headerlink" title="2.7.1 多个接口同名静态方法"></a>2.7.1 多个接口同名静态方法</h3><p>如果实现了多个接口，多个接口中存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。</p><pre><code class="java">public interface A &#123;  public static void test()&#123;  &#125;&#125; interface B &#123;    public static void test()&#123;    &#125;&#125;class C implements  A , B&#123;    public static void main(String[] args) &#123;        People.test();        B.test();       // C.test(); // 编译出错    &#125;&#125;</code></pre><h3 id="2-7-2-优先级的问题"><a href="#2-7-2-优先级的问题" class="headerlink" title="2.7.2 优先级的问题"></a>2.7.2 优先级的问题</h3><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。代码如下：</p><p>定义接口：</p><pre><code class="java">interface A &#123;    public default void methodA()&#123;        System.out.println(&quot;AAAAAAAAAAAA&quot;);    &#125;&#125;</code></pre><p>定义父类：</p><pre><code class="java">class D &#123;    public void methodA()&#123;        System.out.println(&quot;DDDDDDDDDDDD&quot;);    &#125;&#125;</code></pre><p>定义子类：</p><pre><code class="java">class C extends D implements A &#123;      // 未重写methodA方法&#125;</code></pre><p>定义测试类：</p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        C c = new C();        c.methodA();     &#125;&#125;输出结果:DDDDDDDDDDDD</code></pre><h2 id="2-8-接口小结"><a href="#2-8-接口小结" class="headerlink" title="2.8 接口小结"></a>2.8 接口小结</h2><ul><li>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。</li><li>接口中的方法全是抽象方法，默认会自动加上public abstract修饰</li><li>JDK 8开始，接口不再纯洁，支持静态方法，默认方法，私有方法。</li><li>接口中，没有构造器，<strong>不能创建对象</strong>。</li><li>类与接口是多实现的</li><li>接口与接口是多继承的</li><li>接口体现的规范。</li></ul><h1 id="第三章-代码块"><a href="#第三章-代码块" class="headerlink" title="第三章 代码块"></a>第三章 代码块</h1><h2 id="3-1-引入"><a href="#3-1-引入" class="headerlink" title="3.1 引入"></a>3.1 引入</h2><p>类的成分：<br>​    1.成员变量<br>​    2.构造器<br>​    3.成员方法<br>​    4.代码块<br>​    5.内部类</p><p>我们已经学完了成员变量，构造器，成员方法，接下来我们来介绍以下代码快，代码块按照有无static可以分为静态代码块和实例代码块。</p><h2 id="3-2-静态代码块"><a href="#3-2-静态代码块" class="headerlink" title="3.2 静态代码块"></a>3.2 静态代码块</h2><p><strong>静态代码块</strong><br>​         必须有static修饰，必须放在类下。与类一起加载执行。</p><p><strong>格式</strong></p><pre><code class="java">static&#123;     // 执行代码&#125;</code></pre><p><strong>特点</strong>：</p><ul><li>每次执行类，加载类的时候都会先执行静态代码块一次。</li><li>静态代码块是自动触发执行的，只要程序启动静态代码块就会先执行一次。</li><li>作用：在启动程序之前可以做资源的初始化，一般用于初始化静态资源。</li></ul><p><strong>案例演示</strong></p><pre><code class="java">public class DaimaKuaiDemo01 &#123;    public static String sc_name ;    // 1.静态代码块    static &#123;        // 初始化静态资源        sc_name = &quot;黑马程序员！&quot;;        System.out.println(&quot;静态代码块执行！&quot;);    &#125;    public static void main(String[] args) &#123;        System.out.println(&quot;main方法执行&quot;);        System.out.println(sc_name);    &#125;&#125;</code></pre><h2 id="3-3-实例代码块"><a href="#3-3-实例代码块" class="headerlink" title="3.3 实例代码块"></a>3.3 实例代码块</h2><p><strong>实例代码块</strong><br>​         没有static修饰，必须放在类下。与对象初始化一起加载。</p><p><strong>格式</strong></p><pre><code class="java">&#123;     // 执行代码&#125;</code></pre><p><strong>特点</strong>：</p><ul><li>无static修饰。属于对象，与对象的创建一起执行的。</li><li>每次调用构造器初始化对象，实例代码块都要自动触发执行一次。</li><li>实例代码块实际上是提取到每一个构造器中去执行的。</li><li>作用：实例代码块用于初始化对象的资源。</li></ul><p><strong>案例演示</strong></p><pre><code class="java">public class DaimaKuaiDemo02 &#123;       private String name ;    // 实例代码块。 无static修饰。    &#123;        System.out.println(&quot;实例代码块执行&quot;);        name = &quot;dl&quot;;    &#125;    // 构造器    public DaimaKuaiDemo02()&#123;        //System.out.println(&quot;实例代码块执行&quot;);    &#125;    // 有参数构造器    public DaimaKuaiDemo02(String name)&#123;        //System.out.println(&quot;实例代码块执行&quot;);    &#125;    public static void main(String[] args) &#123;        // 匿名对象，创建出来没有给变量。        new DaimaKuaiDemo02();        new DaimaKuaiDemo02();        new DaimaKuaiDemo02(&quot;xulei&quot;);    &#125;&#125;// 输出三次：实例代码块执行</code></pre><p>常用API</p><h1 id="第四章-final关键字"><a href="#第四章-final关键字" class="headerlink" title="第四章 final关键字"></a>第四章 final关键字</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了<code>final</code> 关键字，用于修饰<strong>不可改变</strong>内容。</p><ul><li><strong>final</strong>：  不可改变，最终的含义。可以用于修饰类、方法和变量。<ul><li>类：被修饰的类，不能被继承。</li><li>方法：被修饰的方法，不能被重写。</li><li>变量：被修饰的变量，有且仅能被赋值一次。</li></ul></li></ul><h2 id="4-2-使用方式"><a href="#4-2-使用方式" class="headerlink" title="4.2 使用方式"></a>4.2 使用方式</h2><h3 id="4-2-1-修饰类"><a href="#4-2-1-修饰类" class="headerlink" title="4.2.1 修饰类"></a>4.2.1 修饰类</h3><p>final修饰的类，不能被继承。</p><p>格式如下：</p><pre><code class="java">final class 类名 &#123;&#125;</code></pre><p>代码:</p><pre><code class="java">final class Fu &#123;&#125;// class Zi extends Fu &#123;&#125; // 报错,不能继承final的类</code></pre><p>查询API发现像 <code>public final class String</code> 、<code>public final class Math</code> 、<code>public final class Scanner</code> 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。</p><h3 id="4-2-2-修饰方法"><a href="#4-2-2-修饰方法" class="headerlink" title="4.2.2 修饰方法"></a>4.2.2 修饰方法</h3><p>final修饰的方法，不能被重写。<br>格式如下：</p><pre><code class="java">修饰符 final 返回值类型 方法名(参数列表)&#123;    //方法体&#125;</code></pre><p>代码: </p><pre><code class="java">class Fu2 &#123;    final public void show1() &#123;        System.out.println(&quot;Fu2 show1&quot;);    &#125;    public void show2() &#123;        System.out.println(&quot;Fu2 show2&quot;);    &#125;&#125;class Zi2 extends Fu2 &#123;//    @Override//    public void show1() &#123;//        System.out.println(&quot;Zi2 show1&quot;);//    &#125;    @Override    public void show2() &#123;        System.out.println(&quot;Zi2 show2&quot;);    &#125;&#125;</code></pre><h3 id="4-2-3-修饰变量-局部变量"><a href="#4-2-3-修饰变量-局部变量" class="headerlink" title="4.2.3 修饰变量-局部变量"></a>4.2.3 修饰变量-局部变量</h3><ol><li><strong>局部变量——基本类型</strong><br>基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下：</li></ol><pre><code class="java">public class FinalDemo1 &#123;    public static void main(String[] args) &#123;        // 声明变量，使用final修饰        final int a;        // 第一次赋值         a = 10;        // 第二次赋值        a = 20; // 报错,不可重新赋值        // 声明变量，直接赋值，使用final修饰        final int b = 10;        // 第二次赋值        b = 20; // 报错,不可重新赋值    &#125;&#125;</code></pre><p>思考，如下两种写法，哪种可以通过编译？</p><p>写法1：</p><pre><code class="java">final int c = 0;for (int i = 0; i &lt; 10; i++) &#123;    c = i;    System.out.println(c);&#125;</code></pre><p>写法2：</p><pre><code class="java">for (int i = 0; i &lt; 10; i++) &#123;    final int c = i;    System.out.println(c);&#125;</code></pre><p>根据 <code>final</code> 的定义，写法1报错！写法2，为什么通过编译呢？因为每次循环，都是一次新的变量c。这也是大家需要注意的地方。</p><h3 id="4-2-4-修饰变量-实例成员变量"><a href="#4-2-4-修饰变量-实例成员变量" class="headerlink" title="4.2.4 修饰变量-实例成员变量"></a>4.2.4 修饰变量-实例成员变量</h3><p>成员变量涉及到初始化的问题，初始化方式有显示初始化和构造器初始化，只能选择其中一个：</p><ul><li>显示初始化(在定义成员变量的时候立马赋值)；</li></ul><pre><code class="java">public class Student &#123;    final int num = 10;&#125;</code></pre><ul><li><p>构造器初始化(在构造器中赋值一次)。</p><p><strong>注意：每个构造器中都要赋值一次！</strong></p></li></ul><pre><code class="java">public class Student &#123;    final int num = 10;    final int num2;    public Student() &#123;        this.num2 = 20;//     this.num2 = 20;    &#125;         public Student(String name) &#123;        this.num2 = 20;//     this.num2 = 20;    &#125;&#125;</code></pre><blockquote><p>被final修饰的常量名称，一般都有书写规范，所有字母都<strong>大写</strong>。</p></blockquote><h1 id="第五章-单例设计模式"><a href="#第五章-单例设计模式" class="headerlink" title="第五章 单例设计模式"></a>第五章 单例设计模式</h1><p>正常情况下一个类可以创建多个对象</p><pre><code class="java">public static void main(String[] args) &#123;    // 正常情况下一个类可以创建多个对象    Person p1 = new Person();    Person p2 = new Person();    Person p3 = new Person();&#125;</code></pre><h2 id="5-1-单例设计模式的作用"><a href="#5-1-单例设计模式的作用" class="headerlink" title="5.1 单例设计模式的作用"></a>5.1 单例设计模式的作用</h2><p>单例模式，是一种常用的软件设计模式。通过单例模式可以保证系统中，应用该模式的这个类只有一个实例。即一个类只有一个对象实例。</p><h2 id="5-2-单例设计模式实现步骤"><a href="#5-2-单例设计模式实现步骤" class="headerlink" title="5.2 单例设计模式实现步骤"></a>5.2 单例设计模式实现步骤</h2><ol><li><p>将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。</p></li><li><p>在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。</p></li><li><p>定义一个静态方法返回这个唯一对象。</p></li></ol><h2 id="5-3-单例设计模式的类型"><a href="#5-3-单例设计模式的类型" class="headerlink" title="5.3 单例设计模式的类型"></a>5.3 单例设计模式的类型</h2><p>根据实例化对象的时机单例设计模式又分为以下两种:</p><ol><li><p>饿汉单例设计模式</p></li><li><p>懒汉单例设计模式</p></li></ol><h2 id="5-4-饿汉单例设计模式"><a href="#5-4-饿汉单例设计模式" class="headerlink" title="5.4 饿汉单例设计模式"></a>5.4 饿汉单例设计模式</h2><p>饿汉单例设计模式就是使用类的时候已经将对象创建完毕，不管以后会不会使用到该实例化对象，先创建了再说。很着急的样子，故被称为“饿汉模式”。</p><p>代码如下：</p><pre><code class="java">public class Singleton &#123;    // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。    private Singleton() &#123;&#125;    // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。    private static final Singleton instance = new Singleton();        // 3.定义一个静态方法返回这个唯一对象。    public static Singleton getInstance() &#123;        return instance;    &#125;&#125;</code></pre><h2 id="5-5-懒汉单例设计模式"><a href="#5-5-懒汉单例设计模式" class="headerlink" title="5.5 懒汉单例设计模式"></a>5.5 懒汉单例设计模式</h2><p>懒汉单例设计模式就是调用getInstance()方法时实例才被创建，先不急着实例化出对象，等要用的时候才例化出对象。不着急，故称为“懒汉模式”。</p><p>代码如下：</p><pre><code class="java">public class Singleton &#123;    // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。    private static Singleton instance;        // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。    private Singleton() &#123;&#125;        // 3.定义一个静态方法返回这个唯一对象。要用的时候才例化出对象    public static Singleton getInstance() &#123;        if(instance == null) &#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;</code></pre><blockquote><p>注意：懒汉单例设计模式在多线程环境下可能会实例化出多个对象，不能保证单例的状态。我们在学习完多线程的时候还会再讲解如何解决这个问题。</p></blockquote><h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h2><p>单例模式可以保证系统中一个类只有一个对象实例。</p><p>实现单例模式的步骤：</p><ol><li>将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。</li><li>在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。</li><li>定义一个静态方法返回这个唯一对象。</li></ol><h1 id="第六章-枚举"><a href="#第六章-枚举" class="headerlink" title="第六章 枚举"></a>第六章 枚举</h1><h2 id="6-1-不使用枚举存在的问题"><a href="#6-1-不使用枚举存在的问题" class="headerlink" title="6.1 不使用枚举存在的问题"></a>6.1 不使用枚举存在的问题</h2><p>假设我们要定义一个人类，人类中包含姓名和性别。通常会将性别定义成字符串类型，效果如下：</p><pre><code class="java">public class Person &#123;    private String name;    private String sex;    public Person() &#123;    &#125;    public Person(String name, String sex) &#123;        this.name = name;        this.sex = sex;    &#125;        // 省略get/set/toString方法&#125;</code></pre><pre><code class="java">public class Demo01 &#123;    public static void main(String[] args) &#123;        Person p1 = new Person(&quot;张三&quot;, &quot;男&quot;);        Person p2 = new Person(&quot;张三&quot;, &quot;abc&quot;); // 因为性别是字符串,所以我们可以传入任意字符串    &#125;&#125;</code></pre><p>不使用枚举存在的问题：可以给性别传入任意的字符串，导致性别是非法的数据，不安全。</p><h2 id="6-2-枚举的作用与应用场景"><a href="#6-2-枚举的作用与应用场景" class="headerlink" title="6.2 枚举的作用与应用场景"></a>6.2 枚举的作用与应用场景</h2><p>枚举的作用：一个方法接收的参数是固定范围之内的时候，那么即可使用枚举。</p><h2 id="6-3-枚举的基本语法"><a href="#6-3-枚举的基本语法" class="headerlink" title="6.3 枚举的基本语法"></a>6.3 枚举的基本语法</h2><h3 id="6-3-1-枚举的概念"><a href="#6-3-1-枚举的概念" class="headerlink" title="6.3.1 枚举的概念"></a>6.3.1 枚举的概念</h3><p>枚举是一种特殊类。枚举是有固定实例个数的类型，我们可以把枚举理解成有固定个数实例的多例模式。</p><h3 id="6-3-2-定义枚举的格式"><a href="#6-3-2-定义枚举的格式" class="headerlink" title="6.3.2 定义枚举的格式"></a>6.3.2 定义枚举的格式</h3><pre><code class="java">enum 枚举名 &#123;    第一行都是罗列枚举实例,这些枚举实例直接写大写名字即可。&#125;</code></pre><h3 id="6-3-3-入门案例"><a href="#6-3-3-入门案例" class="headerlink" title="6.3.3 入门案例"></a>6.3.3 入门案例</h3><ol><li>定义枚举：BOY表示男，GIRL表示女</li></ol><pre><code class="java">enum Sex &#123;    BOY, GIRL; // 男，女&#125;</code></pre><ol start="2"><li>Perosn中的性别有String类型改为Sex枚举类型</li></ol><pre><code class="java">public class Person &#123;    private String name;    private Sex sex;    public Person() &#123;    &#125;    public Person(String name, Sex sex) &#123;        this.name = name;        this.sex = sex;    &#125;    // 省略get/set/toString方法&#125;</code></pre><ol start="3"><li>使用是只能传入枚举中的固定值</li></ol><pre><code class="java">public class Demo02 &#123;    public static void main(String[] args) &#123;        Person p1 = new Person(&quot;张三&quot;, Sex.BOY);        Person p2 = new Person(&quot;张三&quot;, Sex.GIRL);        Person p3 = new Person(&quot;张三&quot;, &quot;abc&quot;);    &#125;&#125;</code></pre><h3 id="5-3-4-枚举的其他内容"><a href="#5-3-4-枚举的其他内容" class="headerlink" title="5.3.4 枚举的其他内容"></a>5.3.4 枚举的其他内容</h3><p>枚举的本质是一个类，我们刚才定义的Sex枚举最终效果如下：</p><pre><code class="java">enum Sex &#123;    BOY, GIRL; // 男，女&#125;// 枚举的本质是一个类，我们刚才定义的Sex枚举相当于下面的类final class SEX extends java.lang.Enum&lt;SEX&gt; &#123;    public static final SEX BOY = new SEX();    public static final SEX GIRL = new SEX();    public static SEX[] values();    public static SEX valueOf(java.lang.String);    static &#123;&#125;;&#125;</code></pre><p>枚举的本质是一个类，所以枚举中还可以有成员变量，成员方法等。</p><pre><code class="java">public enum Sex &#123;    BOY(18), GIRL(16);    public int age;    Sex(int age) &#123;        this.age = age;    &#125;    public void showAge() &#123;        System.out.println(&quot;年龄是: &quot; + age);    &#125;&#125;</code></pre><pre><code class="java">public class Demo03 &#123;    public static void main(String[] args) &#123;        Person p1 = new Person(&quot;张三&quot;, Sex.BOY);        Person p2 = new Person(&quot;张三&quot;, Sex.GIRL);        Sex.BOY.showAge();        Sex.GIRL.showAge();    &#125;&#125;</code></pre><p>运行效果：</p><p><img src="C:\Users\13666\AppData\Roaming\Typora\typora-user-images\1560502240126.png" alt="1560502240126"></p><h2 id="6-4-应用场景"><a href="#6-4-应用场景" class="headerlink" title="6.4 应用场景"></a>6.4 应用场景</h2><h2 id="6-5-枚举的应用"><a href="#6-5-枚举的应用" class="headerlink" title="6.5 枚举的应用"></a>6.5 枚举的应用</h2><p><strong>枚举的作用：枚举通常可以用于做信息的分类，如性别，方向，季度等。</strong></p><p>枚举表示性别：</p><pre><code class="java">public enum Sex &#123;    MAIL, FEMAIL;&#125;</code></pre><p>枚举表示方向：</p><pre><code class="java">public enum Orientation &#123;    UP, RIGHT, DOWN, LEFT;&#125;</code></pre><p>枚举表示季度</p><pre><code class="java">public enum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER;&#125;</code></pre><h2 id="6-6-小结"><a href="#6-6-小结" class="headerlink" title="6.6 小结"></a>6.6 小结</h2><ul><li>枚举类在第一行罗列若干个枚举对象。（多例）</li><li>第一行都是常量，存储的是枚举类的对象。</li><li>枚举是不能在外部创建对象的，枚举的构造器默认是私有的。</li><li>枚举通常用于做信息的标志和分类。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day02【抽象类，接口、代码块、final、单例、枚举】&quot;&gt;&lt;a href=&quot;#day02【抽象类，接口、代码块、final、单例、枚举】&quot; class=&quot;headerlink&quot; title=&quot;day02【抽象类，接口、代码块、final、单例、枚举】&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java进阶13天资料" scheme="http://example.com/tags/java%E8%BF%9B%E9%98%B613%E5%A4%A9%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Day01</title>
    <link href="http://example.com/2021/09/05/JAVA/day01-%E5%A4%8D%E4%B9%A0%E5%9B%9E%E9%A1%BE%E3%80%81%E9%9D%99%E6%80%81%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/09/05/JAVA/day01-%E5%A4%8D%E4%B9%A0%E5%9B%9E%E9%A1%BE%E3%80%81%E9%9D%99%E6%80%81%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/</id>
    <published>2021-09-05T02:30:46.000Z</published>
    <updated>2021-09-05T03:00:14.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day01【复习回顾、静态、继承、引用类型使用】"><a href="#day01【复习回顾、静态、继承、引用类型使用】" class="headerlink" title="day01【复习回顾、静态、继承、引用类型使用】"></a>day01【复习回顾、静态、继承、引用类型使用】</h1><h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><ul><li>复习回顾<ul><li>定义类。一个Java文件可以定义多个类。但是只有一个类是用public修饰，public修饰的类名必须称为Java文件名。</li><li>类中有且仅有5大成分（五大金刚）<ul><li>成员变量Field：描述类或者对象的属性信息的。</li><li>成员方法Method：描述类或者对象的行为的。</li><li>构造器（构造方法,Constructor）: 初始化类的一个对象返回。</li><li>代码块：还没有学。</li><li>内部类：还没有学。 </li></ul></li><li>封装<ul><li>面向对象的三大<strong>特征</strong>之一：<strong>封装，继承，多态</strong>。 </li><li>形成了规范，即使毫无意义还是会这样写代码！</li><li>合理隐藏，合理暴露。</li><li>封装的规范：成员变量私有，方法一般公开，提供成套的getter和setter方法暴露成员变量的取值和赋值。</li><li>封装的作用：提高安全性，提高代码的组件化思想。</li><li>封装已经成为Java代码的规范，即使毫无意义，我们也要这样写代码（成员变量私有，方法公开）</li></ul></li><li>this关键字<ul><li>this代表了当前对象的引用。</li><li>this可以出现在构造器和方法中。</li><li>this出现在构造器中代表构造器正在初始化的对象。</li><li>this出现在方法中，哪个对象调用方法，this就代表哪个对象。</li><li>this可以访问对象的成员变量，区分成员变量是局部的还是对象中的成员变量。</li></ul></li></ul></li><li>static关键字. <ul><li>静态。 </li><li>修饰方法和变量都是属于类的。没有static修饰的方法和变量是属于每个对象的。</li></ul></li><li>继承<ul><li>是面向对象的三大特征：封装，<strong>继承</strong>，多态。</li></ul></li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled="" type="checkbox"> 能够写出类的继承格式<ul><li><input disabled="" type="checkbox"> 子类 extends 父类{</li><li><input disabled="" type="checkbox"> }</li></ul></li><li><input disabled="" type="checkbox"> 能够说出继承的特点<ul><li><input disabled="" type="checkbox"> 类是单继承的，可以多层继承，可以有多个子类。</li></ul></li><li><input disabled="" type="checkbox"> 能够区分this和super的作用<ul><li><input disabled="" type="checkbox"> this代表本类对象引用<ul><li><input disabled="" type="checkbox"> this.本类成员变量</li><li><input disabled="" type="checkbox"> this.本类方法</li><li><input disabled="" type="checkbox"> this(…):访问兄弟构造器</li></ul></li><li><input disabled="" type="checkbox"> super代表父类对象引用。<ul><li><input disabled="" type="checkbox"> super.父类变量</li><li><input disabled="" type="checkbox"> super.父类方法</li><li><input disabled="" type="checkbox"> super(…):访问父类构造器</li></ul></li></ul></li><li><input disabled="" type="checkbox"> 能够说出方法重写的概念<ul><li><input disabled="" type="checkbox"> 方法重写：子类写一个方法覆盖父类的方法，子类以后用自己重写的方法。</li></ul></li><li><input disabled="" type="checkbox"> 能够说出方法重写的注意事项<ul><li><input disabled="" type="checkbox"> 1.重写方法的名称和形参列表要与父类被重写方法一致。</li><li><input disabled="" type="checkbox"> 2.重写方法的权限要与父类一样或者更大。 public &gt; protected &gt; 缺省 &gt; private</li></ul></li><li><input disabled="" type="checkbox"> 能够掌握static关键字修饰的变量调用方式<ul><li><input disabled="" type="checkbox"> 类名.静态变量</li><li><input disabled="" type="checkbox"> 对象.静态变量 （不推荐使用）</li></ul></li><li><input disabled="" type="checkbox"> 能够掌握static关键字修饰的方法调用方式<ul><li><input disabled="" type="checkbox"> 类名.静态方法</li><li><input disabled="" type="checkbox"> 对象.静态方法（不推荐使用）</li></ul></li></ul><h1 id="第一章-复习回顾"><a href="#第一章-复习回顾" class="headerlink" title="第一章 复习回顾"></a>第一章 复习回顾</h1><h2 id="1-1-如何定义类"><a href="#1-1-如何定义类" class="headerlink" title="1.1 如何定义类"></a>1.1 如何定义类</h2><p>类的定义格式如下:</p><pre><code class="java">修饰符 class 类名&#123;    // 类中的五大成分。    // 1.成员变量（属性）    // 2.成员方法 (行为)     // 3.构造器 （初始化类的对象数据的）    // 4.内部类    // 5.代码块&#125;</code></pre><p>例如:</p><pre><code class="java">public class Student &#123;    // 1.成员变量    public String name ;    public char sex ; // &#39;男&#39;  &#39;女&#39;    public int age;&#125;</code></pre><h2 id="1-2-如何通过类创建对象"><a href="#1-2-如何通过类创建对象" class="headerlink" title="1.2 如何通过类创建对象"></a>1.2 如何通过类创建对象</h2><pre><code class="java">类名 对象名称 = new 类名();</code></pre><p>例如:</p><pre><code class="java">Student stu = new Student();</code></pre><h2 id="1-3-封装"><a href="#1-3-封装" class="headerlink" title="1.3 封装"></a>1.3 封装</h2><h4 id="1-3-1-封装的步骤"><a href="#1-3-1-封装的步骤" class="headerlink" title="1.3.1 封装的步骤"></a>1.3.1 封装的步骤</h4><p>1.使用 <code>private</code> 关键字来修饰成员变量。</p><p>2.使用<code>public</code>修饰getter和setter方法。</p><h4 id="1-3-2-封装的步骤实现"><a href="#1-3-2-封装的步骤实现" class="headerlink" title="1.3.2 封装的步骤实现"></a>1.3.2 封装的步骤实现</h4><ol><li>private修饰成员变量</li></ol><pre><code class="java">public class Student &#123;    private String name;    private int age;&#125;</code></pre><ol start="2"><li>public修饰getter和setter方法</li></ol><pre><code class="java">public class Student &#123;    private String name;    private int age;    public void setName(String n) &#123;          name = n;    &#125;    public String getName() &#123;          return name;    &#125;    public void setAge(int a) &#123;        if (a &gt; 0 &amp;&amp; a &lt;200) &#123;            age = a;        &#125; else &#123;            System.out.println(&quot;年龄非法！&quot;);        &#125;    &#125;    public int getAge() &#123;          return age;    &#125;&#125;</code></pre><h2 id="1-4-构造器"><a href="#1-4-构造器" class="headerlink" title="1.4 构造器"></a>1.4 构造器</h2><h3 id="1-4-1-构造器的作用"><a href="#1-4-1-构造器的作用" class="headerlink" title="1.4.1 构造器的作用"></a>1.4.1 构造器的作用</h3><p>通过调用构造器可以返回一个类的对象，构造器同时负责帮我们把对象的数据（属性和行为等信息）初始化好。</p><h3 id="1-4-2-构造器的格式"><a href="#1-4-2-构造器的格式" class="headerlink" title="1.4.2 构造器的格式"></a>1.4.2 构造器的格式</h3><pre><code class="java">修饰符 类名(形参列表) &#123;    // 构造体代码，执行代码&#125;</code></pre><h3 id="1-4-3-构造器的应用"><a href="#1-4-3-构造器的应用" class="headerlink" title="1.4.3 构造器的应用"></a>1.4.3 构造器的应用</h3><p>首先定义一个学生类，代码如下：</p><pre><code class="java">public class Student &#123;    // 1.成员变量    public String name;    public int age;    // 2.构造器    public Student() &#123;        System.out.println(&quot;无参数构造器被调用&quot;)；    &#125;&#125;</code></pre><p>接下来通过调用构造器得到两个学生对象。</p><pre><code class="java">public class CreateStu02 &#123;    public static void main(String[] args) &#123;        // 创建一个学生对象        // 类名 变量名称 = new 类名();        Student s1 = new Student();        // 使用对象访问成员变量，赋值        s1.name = &quot;张三&quot;;        s1.age = 20 ;        // 使用对象访问成员变量 输出值        System.out.println(s1.name);        System.out.println(s1.age);         Student s2 = new Student();        // 使用对象访问成员变量 赋值        s2.name = &quot;李四&quot;;        s2.age = 18 ;        System.out.println(s2.name);        System.out.println(s2.age);    &#125;&#125;</code></pre><h2 id="1-5-this关键字的作用"><a href="#1-5-this关键字的作用" class="headerlink" title="1.5 this关键字的作用"></a>1.5 this关键字的作用</h2><h3 id="1-5-1-this关键字的作用"><a href="#1-5-1-this关键字的作用" class="headerlink" title="1.5.1 this关键字的作用"></a>1.5.1 this关键字的作用</h3><p>this代表所在类的当前对象的引用（地址值），即代表当前对象。</p><h3 id="1-5-2-this关键字的应用"><a href="#1-5-2-this关键字的应用" class="headerlink" title="1.5.2 this关键字的应用"></a>1.5.2 this关键字的应用</h3><h4 id="1-5-2-1-用于普通的gettter与setter方法"><a href="#1-5-2-1-用于普通的gettter与setter方法" class="headerlink" title="1.5.2.1 用于普通的gettter与setter方法"></a>1.5.2.1 用于普通的gettter与setter方法</h4><p>this出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。</p><pre><code class="java">public class Student &#123;    private String name;    private int age;    public void setName(String name) &#123;          this.name = name;    &#125;    public String getName() &#123;          return name;    &#125;    public void setAge(int age) &#123;        if (age &gt; 0 &amp;&amp; age &lt; 200) &#123;            this.age = age;        &#125; else &#123;            System.out.println(&quot;年龄非法！&quot;);        &#125;    &#125;    public int getAge() &#123;          return age;    &#125;&#125;</code></pre><h4 id="1-5-2-2-用于构造器中"><a href="#1-5-2-2-用于构造器中" class="headerlink" title="1.5.2.2 用于构造器中"></a>1.5.2.2 用于构造器中</h4><p>this出现在构造器中，代表构造器正在初始化的那个对象。</p><pre><code class="java">public class Student &#123;    private String name;    private int age;        // 无参数构造方法    public Student() &#123;&#125;         // 有参数构造方法    public Student(String name,int age) &#123;        this.name = name;        this.age = age;     &#125;&#125;</code></pre><h1 id="第二章-static关键字"><a href="#第二章-static关键字" class="headerlink" title="第二章 static关键字"></a>第二章 static关键字</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>以前我们定义过如下类：</p><pre><code class="java">public class Student &#123;    // 成员变量    public String name;    public char sex; // &#39;男&#39;  &#39;女&#39;    public int age;    // 无参数构造器    public Student() &#123;    &#125;        // 有参数构造器    public Student(String  a) &#123;    &#125;&#125;</code></pre><p>我们已经知道面向对象中，存在类和对象的概念，我们在类中定义了一些成员变量，例如name,age,sex ,结果发现这些成员变量，每个对象都存在（因为每个对象都可以访问）。</p><p>而像name ,age , sex确实是每个学生对象都应该有的属性，应该属于每个对象。</p><p>所以Java中成员（<strong>变量和方法</strong>）等是存在所属性的，Java是通过static关键字来区分的。<strong>static关键字在Java开发非常的重要，对于理解面向对象非常关键。</strong></p><p>关于 <code>static</code> 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是<strong>属于类</strong>的是放在静态区中，没有static修饰的成员变量和方法则是<strong>属于对象</strong>的。我们上面案例中的成员变量都是没有static修饰的，所以属于每个对象。</p><h2 id="2-2-定义格式和使用"><a href="#2-2-定义格式和使用" class="headerlink" title="2.2 定义格式和使用"></a>2.2 定义格式和使用</h2><p>static是静态的意思。 static可以修饰成员变量或者修饰方法。</p><h3 id="2-2-1-静态变量及其访问"><a href="#2-2-1-静态变量及其访问" class="headerlink" title="2.2.1 静态变量及其访问"></a>2.2.1 静态变量及其访问</h3><p>有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为<strong>类变量</strong>或者<strong>静态成员变量</strong>。 直接用  类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。</p><p><strong>如何使用呢</strong></p><p>例如现在我们需要定义传智全部的学生类，那么这些学生类的对象的学校属性应该都是“传智”，这个时候我们可以把这个属性定义成static修饰的静态成员变量。</p><p><strong>定义格式</strong></p><pre><code class="java">修饰符 static 数据类型 变量名 = 初始值；    </code></pre><p><strong>举例</strong></p><pre><code class="java">public class Student &#123;    public static String schoolName = &quot;传智播客&quot;； // 属于类，只有一份。    // .....&#125;</code></pre><p><strong>静态成员变量的访问:</strong></p><p><strong>格式：类名.静态变量</strong></p><pre><code class="java">public static void  main(String[] args)&#123;    System.out.println(Student.schoolName); // 传智播客    Student.schoolName = &quot;黑马程序员&quot;;    System.out.println(Student.schoolName); // 黑马程序员&#125;</code></pre><h3 id="2-2-2-实例变量及其访问"><a href="#2-2-2-实例变量及其访问" class="headerlink" title="2.2.2 实例变量及其访问"></a>2.2.2 实例变量及其访问</h3><p>无static修饰的成员变量属于每个对象的，  这个成员变量叫<strong>实例变量</strong>，之前我们写成员变量就是实例成员变量。</p><p><strong>需要注意的是</strong>：实例成员变量属于每个对象，必须创建类的对象才可以访问。   </p><p><strong>格式：对象.实例成员变量</strong></p><h3 id="2-2-3-静态方法及其访问"><a href="#2-2-3-静态方法及其访问" class="headerlink" title="2.2.3 静态方法及其访问"></a>2.2.3 静态方法及其访问</h3><p>有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为<strong>类方法或者</strong>静态方法**。 直接用  类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。</p><p>与静态成员变量一样，静态方法也是直接通过<strong>类名.方法名称</strong>即可访问。</p><p><strong>举例</strong></p><pre><code class="java">public class Student&#123;    public static String schoolName = &quot;传智播客&quot;； // 属于类，只有一份。    // .....    public static void study()&#123;        System.out.println(&quot;我们都在黑马程序员学习&quot;);       &#125;&#125;</code></pre><p><strong>静态成员变量的访问:</strong></p><p><strong>格式：类名.静态方法</strong></p><pre><code class="java">public static void  main(String[] args)&#123;    Student.study();&#125;</code></pre><h3 id="2-2-4-实例方法及其访问"><a href="#2-2-4-实例方法及其访问" class="headerlink" title="2.2.4 实例方法及其访问"></a>2.2.4 实例方法及其访问</h3><p>无static修饰的成员方法属于每个对象的，  这个成员方法叫<strong>实例方法</strong>。</p><p><strong>需要注意的是</strong>：实例方法是属于每个对象，必须创建类的对象才可以访问。  </p><p><strong>格式：对象.实例方法</strong></p><p><strong>示例</strong>：</p><pre><code class="java">public class Student &#123;    // 实例变量    private String name ;    // 2.方法：行为    // 无 static修饰，实例方法。属于每个对象，必须创建对象调用    public void run()&#123;        System.out.println(&quot;学生可以跑步&quot;);    &#125;    // 无 static修饰，实例方法    public  void sleep()&#123;        System.out.println(&quot;学生睡觉&quot;);    &#125;    public static void study()&#123;            &#125;&#125;</code></pre><pre><code class="java">public static void main(String[] args)&#123;    // 创建对象     Student stu = new Student ;    stu.name = &quot;徐干&quot;;    // Student.sleep();// 报错，必须用对象访问。    stu.sleep();    stu.run();&#125;</code></pre><h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h2><p>1.当 <code>static</code> 修饰成员变量或者成员方法时，该变量称为<strong>静态变量</strong>，该方法称为<strong>静态方法</strong>。该类的每个对象都<strong>共享</strong>同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。</p><p>2.无static修饰的成员变量或者成员方法，称为<strong>实例变量，实例方法</strong>，实例变量和实例方法必须创建类的对象，然后通过对象来访问。</p><p>3.static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。</p><p>4.无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。</p><h1 id="第三章-继承"><a href="#第三章-继承" class="headerlink" title="第三章 继承"></a>第三章 继承</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><h3 id="3-1-1-引入"><a href="#3-1-1-引入" class="headerlink" title="3.1.1 引入"></a>3.1.1 引入</h3><p>假如我们要定义如下类:<br>学生类,老师类和工人类，分析如下。</p><ol><li><p>学生类<br>属性:姓名,年龄<br>行为:吃饭,睡觉</p></li><li><p>老师类<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，教书</p></li><li><p>班主任<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，管理</p></li></ol><p>如果我们定义了这三个类去开发一个系统，那么这三个类中就存在大量重复的信息（属性:姓名，年龄。行为：吃饭，睡觉）。这样就导致了相同代码大量重复，代码显得很臃肿和冗余，那么如何解决呢？</p><p>假如多个类中存在相同属性和行为时，我们可以将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要<strong>继承</strong>那一个类即可。如图所示：<br><img src="/img/java/imgs1/1.jpg"></p><p>其中，多个类可以称为<strong>子类</strong>，单独被继承的那一个类称为<strong>父类</strong>、<strong>超类（superclass）</strong>或者<strong>基类</strong>。</p><h3 id="3-1-2-继承的含义"><a href="#3-1-2-继承的含义" class="headerlink" title="3.1.2 继承的含义"></a>3.1.2 继承的含义</h3><p>继承描述的是事物之间的所属关系，这种关系是：<code>is-a</code> 的关系。例如，兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。</p><p><strong>继承</strong>：就是子类继承父类的<strong>属性</strong>和<strong>行为</strong>，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的<strong>非私有</strong>的属性和行为。</p><h3 id="3-1-3-继承的好处"><a href="#3-1-3-继承的好处" class="headerlink" title="3.1.3 继承的好处"></a>3.1.3 继承的好处</h3><ol><li>提高<strong>代码的复用性</strong>（减少代码冗余，相同代码重复利用）。</li><li>使类与类之间产生了关系。</li></ol><h2 id="3-2-继承的格式"><a href="#3-2-继承的格式" class="headerlink" title="3.2 继承的格式"></a>3.2 继承的格式</h2><p>通过 <code>extends</code> 关键字，可以声明一个子类继承另外一个父类，定义格式如下：</p><pre><code class="java">class 父类 &#123;    ...&#125;class 子类 extends 父类 &#123;    ...&#125;</code></pre><p><strong>需要注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。</strong></p><h2 id="3-3-继承案例"><a href="#3-3-继承案例" class="headerlink" title="3.3 继承案例"></a>3.3 继承案例</h2><h3 id="3-3-1-案例"><a href="#3-3-1-案例" class="headerlink" title="3.3.1 案例"></a>3.3.1 案例</h3><p>请使用继承定义以下类:</p><ol><li>学生类<br>属性:姓名,年龄<br>行为:吃饭,睡觉</li><li>老师类<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，教书</li><li>班主任<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，管理</li></ol><h3 id="3-3-2-案例图解分析"><a href="#3-3-2-案例图解分析" class="headerlink" title="3.3.2 案例图解分析"></a>3.3.2 案例图解分析</h3><p>老师类，学生类，还有班主任类，实际上都是属于人类的，我们可以定义一个人类，把他们相同的属性和行为都定义在人类中，然后继承人类即可，子类特有的属性和行为就定义在子类中了。</p><p>如下图所示。</p><p><img src="/img/java/imgs1/360%E6%88%AA%E5%9B%BE20181202211331250.jpg"></p><h3 id="3-3-3-案例代码实现"><a href="#3-3-3-案例代码实现" class="headerlink" title="3.3.3 案例代码实现"></a>3.3.3 案例代码实现</h3><p><strong>1.父类Human类</strong></p><pre><code class="java"> public class Human &#123;  // 合理隐藏  private String name ;  private int age ;    // 合理暴露  public String getName() &#123;      return name;  &#125;  public void setName(String name) &#123;      this.name = name;  &#125;  public int getAge() &#123;      return age;  &#125;  public void setAge(int age) &#123;      this.age = age;  &#125; &#125;</code></pre><p><strong>2.子类Teacher类</strong></p><pre><code class="java">public class Teacher extends Human &#123;  // 工资  private double salary ;    // 特有方法  public void teach()&#123;      System.out.println(&quot;老师在认真教技术！&quot;)；  &#125;  public double getSalary() &#123;      return salary;  &#125;  public void setSalary(double salary) &#123;      this.salary = salary;  &#125;&#125;</code></pre><p><strong>3.子类Student类</strong></p><pre><code class="java">public class Student extends Human&#123; &#125;</code></pre><p><strong>4.子类BanZhuren类</strong></p><pre><code class="java">public class Teacher extends Human &#123;    // 工资    private double salary ;           // 特有方法    public void admin()&#123;        System.out.println(&quot;班主任强调纪律问题！&quot;)；    &#125;        public double getSalary() &#123;        return salary;    &#125;    public void setSalary(double salary) &#123;        this.salary = salary;    &#125;&#125;</code></pre><p><strong>5.测试类</strong></p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        Teacher dlei = new Teacher();        dlei.setName(&quot;播仔&quot;);        dlei.setAge(&quot;31&quot;);        dlei.setSalary(1000.99);        System.out.println(dlei.getName());        System.out.println(dlei.getAge());        System.out.println(dlei.getSalary());        dlei.teach();                BanZhuRen linTao = new BanZhuRen();        linTao.setName(&quot;灵涛&quot;);        linTao.setAge(&quot;28&quot;);        linTao.setSalary(1000.99);        System.out.println(linTao.getName());        System.out.println(linTao.getAge());        System.out.println(linTao.getSalary());        linTao.admin();        Student xugan = new Student();        xugan.setName(&quot;播仔&quot;);        xugan.setAge(&quot;31&quot;);        //xugan.setSalary(1000.99); // xugan没有薪水属性，报错！        System.out.println(xugan.getName());        System.out.println(xugan.getAge());    &#125;&#125;</code></pre><h3 id="3-3-4-小结"><a href="#3-3-4-小结" class="headerlink" title="3.3.4 小结"></a>3.3.4 小结</h3><p>1.继承实际上是子类相同的属性和行为可以定义在父类中，子类特有的属性和行为由自己定义，这样就实现了相同属性和行为的重复利用，从而提高了代码复用。</p><p>2.子类继承父类，就可以直接得到父类的成员变量和方法。是否可以继承所有成分呢？请看下节！</p><h2 id="3-4-子类不能继承的内容"><a href="#3-4-子类不能继承的内容" class="headerlink" title="3.4 子类不能继承的内容"></a>3.4 子类不能继承的内容</h2><h3 id="3-4-1-引入"><a href="#3-4-1-引入" class="headerlink" title="3.4.1 引入"></a>3.4.1 引入</h3><p>并不是父类的所有内容都可以给子类继承的：</p><p><strong>子类不能继承父类的构造器，因为子类有自己的构造器。</strong></p><p><strong>值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。</strong></p><h3 id="3-4-1-演示代码"><a href="#3-4-1-演示代码" class="headerlink" title="3.4.1 演示代码"></a>3.4.1 演示代码</h3><pre><code class="java">public class Demo03 &#123;    public static void main(String[] args) &#123;        Zi z = new Zi();        System.out.println(z.num1);//        System.out.println(z.num2); // 私有的子类无法使用        // 通过getter/setter方法访问父类的private成员变量        System.out.println(z.getNum2());        z.show1();        // z.show2(); // 私有的子类无法使用    &#125;&#125;class Fu &#123;    public int num1 = 10;    private int num2 = 20;    public void show1() &#123;        System.out.println(&quot;show1&quot;);    &#125;    private void show2() &#123;        System.out.println(&quot;show2&quot;);    &#125;    public int getNum2() &#123;        return num2;    &#125;    public void setNum2(int num2) &#123;        this.num2 = num2;    &#125;&#125;class Zi extends Fu &#123;&#125;</code></pre><h2 id="3-5-继承后的特点—成员变量"><a href="#3-5-继承后的特点—成员变量" class="headerlink" title="3.5 继承后的特点—成员变量"></a>3.5 继承后的特点—成员变量</h2><p>当类之间产生了继承关系后，其中各类中的成员变量，又产生了哪些影响呢？</p><h3 id="3-5-1-成员变量不重名"><a href="#3-5-1-成员变量不重名" class="headerlink" title="3.5.1 成员变量不重名"></a>3.5.1 成员变量不重名</h3><p>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<strong>没有影响的</strong>。代码如下：</p><pre><code class="java">class Fu &#123;    // Fu中的成员变量    int num = 5;&#125;class Zi extends Fu &#123;    // Zi中的成员变量    int num2 = 6;      // Zi中的成员方法    public void show() &#123;        // 访问父类中的num        System.out.println(&quot;Fu num=&quot;+num); // 继承而来，所以直接访问。        // 访问子类中的num2        System.out.println(&quot;Zi num2=&quot;+num2);    &#125;&#125;class Demo04 &#123;    public static void main(String[] args) &#123;        // 创建子类对象        Zi z = new Zi();           // 调用子类中的show方法        z.show();      &#125;&#125;演示结果：Fu num = 5Zi num2 = 6</code></pre><h3 id="3-5-2-成员变量重名"><a href="#3-5-2-成员变量重名" class="headerlink" title="3.5.2 成员变量重名"></a>3.5.2 成员变量重名</h3><p>如果子类父类中出现<strong>重名</strong>的成员变量，这时的访问是<strong>有影响的</strong>。代码如下：</p><pre><code class="java">class Fu1 &#123;    // Fu中的成员变量。    int num = 5;&#125;class Zi1 extends Fu1 &#123;    // Zi中的成员变量    int num = 6;      public void show() &#123;        // 访问父类中的num        System.out.println(&quot;Fu num=&quot; + num);        // 访问子类中的num        System.out.println(&quot;Zi num=&quot; + num);    &#125;&#125;class Demo04 &#123;    public static void main(String[] args) &#123;          // 创建子类对象        Zi1 z = new Zi1();           // 调用子类中的show方法        z1.show();     &#125;&#125;演示结果：Fu num = 6Zi num = 6</code></pre><p>子父类中出现了同名的成员变量时，子类会优先访问自己对象中的成员变量。如果此时想访问父类成员变量如何解决呢？我们可以使用super关键字。</p><h3 id="3-5-3-super访问父类成员变量"><a href="#3-5-3-super访问父类成员变量" class="headerlink" title="3.5.3  super访问父类成员变量"></a>3.5.3  super访问父类成员变量</h3><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用<code>super</code> 关键字，修饰父类成员变量，类似于之前学过的 <code>this</code> 。</p><p>需要注意的是：<strong>super代表的是父类对象的引用，this代表的是当前对象的引用。</strong></p><p><strong>使用格式：</strong></p><pre><code class="java">super.父类成员变量名</code></pre><p>子类方法需要修改，代码如下：</p><pre><code class="java">class Fu &#123;    // Fu中的成员变量。    int num = 5;&#125;class Zi extends Fu &#123;    // Zi中的成员变量    int num = 6;      public void show() &#123;        int num = 1;              // 访问方法中的num        System.out.println(&quot;method num=&quot; + num);        // 访问子类中的num        System.out.println(&quot;Zi num=&quot; + this.num);        // 访问父类中的num        System.out.println(&quot;Fu num=&quot; + super.num);    &#125;&#125;class Demo04 &#123;    public static void main(String[] args) &#123;          // 创建子类对象        Zi1 z = new Zi1();           // 调用子类中的show方法        z1.show();     &#125;&#125;演示结果：method num=1Zi num=6Fu num=5</code></pre><blockquote><p>小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。</p></blockquote><h2 id="3-6-继承后的特点—成员方法"><a href="#3-6-继承后的特点—成员方法" class="headerlink" title="3.6 继承后的特点—成员方法"></a>3.6 继承后的特点—成员方法</h2><p>当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？</p><h3 id="3-6-1-成员方法不重名"><a href="#3-6-1-成员方法不重名" class="headerlink" title="3.6.1 成员方法不重名"></a>3.6.1 成员方法不重名</h3><p>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响的</strong>。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下：</p><pre><code class="java">class Fu &#123;    public void show() &#123;        System.out.println(&quot;Fu类中的show方法执行&quot;);    &#125;&#125;class Zi extends Fu &#123;    public void show2() &#123;        System.out.println(&quot;Zi类中的show2方法执行&quot;);    &#125;&#125;public  class Demo05 &#123;    public static void main(String[] args) &#123;        Zi z = new Zi();         //子类中没有show方法，但是可以找到父类方法去执行        z.show();         z.show2();    &#125;&#125;</code></pre><h3 id="3-6-2-成员方法重名"><a href="#3-6-2-成员方法重名" class="headerlink" title="3.6.2 成员方法重名"></a>3.6.2 成员方法重名</h3><p>如果子类父类中出现<strong>重名</strong>的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法。</p><p>代码如下：</p><pre><code class="java">class Fu &#123;    public void show() &#123;        System.out.println(&quot;Fu show&quot;);    &#125;&#125;class Zi extends Fu &#123;    //子类重写了父类的show方法    public void show() &#123;        System.out.println(&quot;Zi show&quot;);    &#125;&#125;public class ExtendsDemo05&#123;    public static void main(String[] args) &#123;        Zi z = new Zi();         // 子类中有show方法，只执行重写后的show方法        z.show();  // Zi show    &#125;&#125;</code></pre><h2 id="3-7-方法重写"><a href="#3-7-方法重写" class="headerlink" title="3.7 方法重写"></a>3.7 方法重写</h2><h3 id="3-7-1-概念"><a href="#3-7-1-概念" class="headerlink" title="3.7.1 概念"></a>3.7.1 概念</h3><p><strong>方法重写</strong> ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现</strong>。</p><h3 id="3-7-2-使用场景与案例"><a href="#3-7-2-使用场景与案例" class="headerlink" title="3.7.2 使用场景与案例"></a>3.7.2 使用场景与案例</h3><p>发生在子父类之间的关系。<br>子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方 法。</p><p>例如：我们定义了一个动物类代码如下：</p><pre><code class="java">public class Animal  &#123;    public void run()&#123;        System.out.println(&quot;动物跑的很快！&quot;);    &#125;    public void cry()&#123;        System.out.println(&quot;动物都可以叫~~~&quot;);    &#125;&#125;</code></pre><p>然后定义一个猫类，猫可能认为父类cry()方法不能满足自己的需求</p><p>代码如下：</p><pre><code class="java">public class Cat extends Animal &#123;    public void cry()&#123;        System.out.println(&quot;我们一起学猫叫，喵喵喵！喵的非常好听！&quot;);    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;          // 创建子类对象          Cat ddm = new Cat()；        // 调用父类继承而来的方法        ddm.run();          // 调用子类重写的方法          ddm.cry();    &#125;&#125;</code></pre><h3 id="3-7-2-Override重写注解"><a href="#3-7-2-Override重写注解" class="headerlink" title="3.7.2 @Override重写注解"></a>3.7.2 @Override重写注解</h3><ul><li><p>@Override:注解，重写注解校验！</p></li><li><p>这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。</p></li><li><p>建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！</p><p>加上后的子类代码形式如下：</p><pre><code class="java">public class Cat extends Animal &#123;     // 声明不变，重新实现    // 方法名称与父类全部一样，只是方法体中的功能重写写了！    @Override    public void cry()&#123;        System.out.println(&quot;我们一起学猫叫，喵喵喵！喵的非常好听！&quot;);    &#125;&#125;</code></pre></li></ul><h3 id="3-7-3-注意事项"><a href="#3-7-3-注意事项" class="headerlink" title="3.7.3 注意事项"></a>3.7.3 注意事项</h3><ol><li>方法重写是发生在子父类之间的关系。</li><li>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li><li>子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</li></ol><h2 id="3-8-继承后的特点—构造器"><a href="#3-8-继承后的特点—构造器" class="headerlink" title="3.8 继承后的特点—构造器"></a>3.8 继承后的特点—构造器</h2><h3 id="3-8-1-引入"><a href="#3-8-1-引入" class="headerlink" title="3.8.1 引入"></a>3.8.1 引入</h3><p>当类之间产生了关系，其中各类中的构造器，又产生了哪些影响呢？<br>首先我们要回忆两个事情，构造器的定义格式和作用。</p><ol><li>构造器的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li><li>构造器的作用是初始化对象成员变量数据的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个<code>super()</code> ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。（<strong>先有爸爸，才能有儿子</strong>）</li></ol><p><strong>继承后子类构造器特点:子类所有构造器的第一行都会先调用父类的无参构造器，再执行自己</strong></p><h3 id="3-8-2-案例演示"><a href="#3-8-2-案例演示" class="headerlink" title="3.8.2 案例演示"></a>3.8.2 案例演示</h3><p>按如下需求定义类:</p><ol><li>人类<br>成员变量: 姓名,年龄<br>成员方法: 吃饭</li><li>学生类<br>成员变量: 姓名,年龄,成绩<br>成员方法: 吃饭</li></ol><p>代码如下：</p><pre><code class="java">class Person &#123;    private String name;    private int age;    public Person() &#123;        System.out.println(&quot;父类无参&quot;);    &#125;    // getter/setter省略&#125;class Student extends Person &#123;    private double score;    public Student() &#123;        //super(); // 调用父类无参,默认就存在，可以不写，必须再第一行        System.out.println(&quot;子类无参&quot;);    &#125;         public Student(double score) &#123;        //super();  // 调用父类无参,默认就存在，可以不写，必须再第一行        this.score = score;            System.out.println(&quot;子类有参&quot;);     &#125;&#125;public class Demo07 &#123;    public static void main(String[] args) &#123;        Student s1 = new Student();        System.out.println(&quot;----------&quot;);        Student s2 = new Student(99.9);    &#125;&#125;输出结果：父类无参子类无参----------父类无参子类有参</code></pre><h3 id="3-8-3-小结"><a href="#3-8-3-小结" class="headerlink" title="3.8.3 小结"></a>3.8.3 小结</h3><ul><li>子类构造器执行的时候，都会在第一行默认先调用父类无参数构造器一次。</li><li>子类构造器的第一行都隐含了一个**super()<strong>去调用父类无参数构造器，</strong>super()**可以省略不写。</li></ul><h2 id="3-9-super-…-和this-…"><a href="#3-9-super-…-和this-…" class="headerlink" title="3.9 super(…)和this(…)"></a>3.9 super(…)和this(…)</h2><h3 id="3-9-1-引入"><a href="#3-9-1-引入" class="headerlink" title="3.9.1  引入"></a>3.9.1  引入</h3><p>请看上节中的如下案例：</p><pre><code class="java">class Person &#123;    private String name;    private int age;    public Person() &#123;        System.out.println(&quot;父类无参&quot;);    &#125;    // getter/setter省略&#125;class Student extends Person &#123;    private double score;    public Student() &#123;        //super(); // 调用父类无参构造器,默认就存在，可以不写，必须再第一行        System.out.println(&quot;子类无参&quot;);    &#125;         public Student(double score) &#123;        //super();  // 调用父类无参构造器,默认就存在，可以不写，必须再第一行        this.score = score;            System.out.println(&quot;子类有参&quot;);     &#125;      // getter/setter省略&#125;public class Demo07 &#123;    public static void main(String[] args) &#123;        // 调用子类有参数构造器        Student s2 = new Student(99.9);        System.out.println(s2.getScore()); // 99.9        System.out.println(s2.getName()); // 输出 null        System.out.println(s2.getAge()); // 输出 0    &#125;&#125;</code></pre><p>我们发现，子类有参数构造器只是初始化了自己对象中的成员变量score，而父类中的成员变量name和age依然是没有数据的，怎么解决这个问题呢，我们可以借助与super(…)去调用父类构造器，以便初始化继承自父类对象的name和age.</p><h3 id="3-9-2-super和this的用法格式"><a href="#3-9-2-super和this的用法格式" class="headerlink" title="3.9.2 super和this的用法格式"></a>3.9.2 super和this的用法格式</h3><p>super和this完整的用法如下，其中this，super访问成员我们已经接触过了。</p><pre><code class="java">this.成员变量        --    本类的super.成员变量        --    父类的this.成员方法名()      --    本类的    super.成员方法名()   --    父类的</code></pre><p>接下来我们使用调用构造器格式：</p><pre><code class="java">super(...) -- 调用父类的构造器，根据参数匹配确认this(...) -- 调用本类的其他构造器，根据参数匹配确认</code></pre><h3 id="3-9-3-super-…-用法演示"><a href="#3-9-3-super-…-用法演示" class="headerlink" title="3.9.3 super(….)用法演示"></a>3.9.3 super(….)用法演示</h3><p>代码如下：</p><pre><code class="java">class Person &#123;    private String name =&quot;凤姐&quot;;    private int age = 20;    public Person() &#123;        System.out.println(&quot;父类无参&quot;);    &#125;        public Person(String name , int age)&#123;        this.name = name ;        this.age = age ;    &#125;    // getter/setter省略&#125;class Student extends Person &#123;    private double score = 100;    public Student() &#123;        //super(); // 调用父类无参构造器,默认就存在，可以不写，必须再第一行        System.out.println(&quot;子类无参&quot;);    &#125;         public Student(String name ， int age，double score) &#123;        super(name ,age);// 调用父类有参构造器Person(String name , int age)初始化name和age        this.score = score;            System.out.println(&quot;子类有参&quot;);     &#125;      // getter/setter省略&#125;public class Demo07 &#123;    public static void main(String[] args) &#123;        // 调用子类有参数构造器        Student s2 = new Student(&quot;张三&quot;，20，99);        System.out.println(s2.getScore()); // 99        System.out.println(s2.getName()); // 输出 张三        System.out.println(s2.getAge()); // 输出 20    &#125;&#125;</code></pre><p><strong>注意：</strong></p><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p><p>super(..)是根据参数去确定调用父类哪个构造器的。</p><h3 id="3-9-4-super-…-案例图解"><a href="#3-9-4-super-…-案例图解" class="headerlink" title="3.9.4 super(…)案例图解"></a>3.9.4 super(…)案例图解</h3><p><strong>父类空间优先于子类对象产生</strong></p><p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造七调用时，一定先调用父类的构造器。理解图解如下：</p><p><img src="/img/java/imgs1/2.jpg"></p><h3 id="3-9-5-this-…-用法演示"><a href="#3-9-5-this-…-用法演示" class="headerlink" title="3.9.5 this(…)用法演示"></a>3.9.5 this(…)用法演示</h3><p>this(…)</p><ul><li>   默认是去找本类中的其他构造器，根据参数来确定具体调用哪一个构造器。</li><li>   为了借用其他构造器的功能。</li></ul><pre><code class="java">package com.itheima._08this和super调用构造器;/** * this(...): *    默认是去找本类中的其他构造器，根据参数来确定具体调用哪一个构造器。 *    为了借用其他构造器的功能。 * */public class ThisDemo01 &#123;    public static void main(String[] args) &#123;        Student xuGan = new Student();        System.out.println(xuGan.getName()); // 输出:徐干        System.out.println(xuGan.getAge());// 输出:21        System.out.println(xuGan.getSex());// 输出： 男    &#125;&#125;class Student&#123;    private String name ;    private int age ;    private char sex ;    public Student() &#123;  // 很弱，我的兄弟很牛逼啊，我可以调用其他构造器：Student(String name, int age, char sex)        this(&quot;徐干&quot;,21,&#39;男&#39;);    &#125;    public Student(String name, int age, char sex) &#123;        this.name = name ;        this.age = age   ;        this.sex = sex   ;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public char getSex() &#123;        return sex;    &#125;    public void setSex(char sex) &#123;        this.sex = sex;    &#125;&#125;</code></pre><h3 id="3-9-6-小结"><a href="#3-9-6-小结" class="headerlink" title="3.9.6 小结"></a>3.9.6 小结</h3><ul><li><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p></li><li><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p></li><li><p><strong>super(..)和this(…)是根据参数去确定调用父类哪个构造器的。</strong></p></li><li><p>super(..)可以调用父类构造器初始化继承自父类的成员变量的数据。</p></li><li><p>this(..)可以调用本类中的其他构造器。</p></li></ul><h2 id="3-10-继承的特点"><a href="#3-10-继承的特点" class="headerlink" title="3.10 继承的特点"></a>3.10 继承的特点</h2><ol><li><p>Java只支持单继承，不支持多继承。</p><pre><code class="java">// 一个类只能有一个父类，不可以有多个父类。class A &#123;&#125;class B &#123;&#125;class C1 extends A &#123;&#125; // ok// class C2 extends A, B &#123;&#125; // error</code></pre></li><li><p>一个类可以有多个子类。</p><pre><code class="java">// A可以有多个子类class A &#123;&#125;class C1 extends A &#123;&#125;class C2 extends  A &#123;&#125;</code></pre></li><li><p>可以多层继承。</p><pre><code class="java">class A &#123;&#125;class C1 extends A &#123;&#125;class D extends C1 &#123;&#125;</code></pre><blockquote><p>顶层父类是Object类。所有的类默认继承Object，作为父类。</p></blockquote></li></ol><h1 id="第四章-引用类型使用小结-重点"><a href="#第四章-引用类型使用小结-重点" class="headerlink" title="第四章 引用类型使用小结(重点)"></a>第四章 引用类型使用小结(重点)</h1><p>​        实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类型也是可以的。在这我们使用两个例子 , 来学习一下。</p><h2 id="4-1-引用类型作为方法参数和返回值"><a href="#4-1-引用类型作为方法参数和返回值" class="headerlink" title="4.1 引用类型作为方法参数和返回值"></a>4.1 引用类型作为方法参数和返回值</h2><pre><code class="java">public class Person&#123;  public void eat()&#123;    System.out.println(&quot;吃饭&quot;);  &#125;&#125;public class Test&#123;  public static void main(String[] args)&#123;        method(new Person());           Person p = createPerson();  &#125;      //引用类型作为方法参数,在前面笔记本案例中我们也使用了接口类型作为方法参数  pubic static void method(Person p)&#123;       p.eat();  &#125;      //引用类型作为返回值  public static Person createPerson()&#123;        return new Person();  &#125;&#125;</code></pre><h2 id="4-2-引用类型作为成员变量"><a href="#4-2-引用类型作为成员变量" class="headerlink" title="4.2 引用类型作为成员变量"></a>4.2 引用类型作为成员变量</h2><p>​    我们每个人(Person)都有一个身份证(IDCard) , 为了表示这种关系 , 就需要在Person中定义一个IDCard的成员变量。定义Person类时，代码如下：</p><pre><code class="java">class Person &#123;    String name;//姓名    int age;//年龄&#125;</code></pre><p>​    使用使用<code>String</code> 类型表示姓名 , <code>int</code> 类型表示年龄。其实，<code>String</code>本身就是引用类型，我们往往忽略了它是引用类型。如果我们继续丰富这个类的定义，给<code>Person</code> 增加身份证号 , 身份证签发机关等属性，我们将如何编写呢？这时候就需要编写一个IDCard类了</p><p>定义IDCard(身份证)类，添加身份证号 , 签发地等属性：</p><pre><code class="java">class IDCard &#123;    String idNum;//身份证号    String authority;//签发地        //getter和setter方法      //...            //toString方法      //...&#125;</code></pre><p>修改Person类：</p><pre><code class="java">public class Person &#123;    String name;//姓名    int age;//年龄    IDCard idCard;//表示自己的身份证信息    //name和age的getter、setter方法    //...    public IDCard getIdCard() &#123;        return idCard;    &#125;    public void setIdCard(IDCard idCard) &#123;        this.idCard = idCard;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &quot;, idCard=&quot; + idCard +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="java">public class TestDemo &#123;    public static void main(String[] args) &#123;        //创建IDCard对象        IDCard idCard = new IDCard();        //设置身份证号        idCard.setIdNum(&quot;110113201606066666&quot;);        //设置签发地        idCard.setAuthority(&quot;北京市顺义区公安局&quot;);        //创建Person对象        Person p = new Person();        //设置姓名        p.setName(&quot;小顺子&quot;);        //设置年龄        p.setAge(2);        //设置身份证信息        p.setIdCard(idCard);        //打印小顺子的信息        System.out.println(p);    &#125;&#125;输出结果:Person&#123;name=&#39;小顺子&#39;, age=2, idCard=IDCard&#123;idNum=&#39;110113201606066666&#39;, authority=&#39;北京市顺义区公安局&#39;&#125;&#125;</code></pre><blockquote><p>类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。同理 , 接口也是如此 , 例如我们笔记本案例中使用usb设备。在此我们只是通过小例子 , 让大家熟识下引用类型的用法 , 后续在咱们的就业班学习中 , 这种方式会使用的很多。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day01【复习回顾、静态、继承、引用类型使用】&quot;&gt;&lt;a href=&quot;#day01【复习回顾、静态、继承、引用类型使用】&quot; class=&quot;headerlink&quot; title=&quot;day01【复习回顾、静态、继承、引用类型使用】&quot;&gt;&lt;/a&gt;day01【复习回顾、静态、</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java进阶13天资料" scheme="http://example.com/tags/java%E8%BF%9B%E9%98%B613%E5%A4%A9%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>软件项目管理笔记</title>
    <link href="http://example.com/2021/09/03/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2021/09/03/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</id>
    <published>2021-09-03T09:30:46.000Z</published>
    <updated>2021-09-07T10:18:23.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件项目管理"><a href="#软件项目管理" class="headerlink" title="软件项目管理"></a>软件项目管理</h1><blockquote><p><a href=""><strong>持续更新~</strong></a></p></blockquote><h2 id="第-1-章-软件项目管理概述"><a href="#第-1-章-软件项目管理概述" class="headerlink" title="第 1 章 软件项目管理概述"></a><strong>第 1 章 软件项目管理概述</strong></h2><h3 id="1-1-项目与软件项目"><a href="#1-1-项目与软件项目" class="headerlink" title="1.1  项目与软件项目"></a>1.1  项目与软件项目</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>项目(Project)是为了创造一个唯一的产品或提供一 个唯一的服务而进行的临时性的努力。</p><h4 id="项目的目标"><a href="#项目的目标" class="headerlink" title="项目的目标"></a>项目的目标</h4><ul><li>成果性目标</li><li>约束性目标</li></ul><h4 id="项目的目标的特性"><a href="#项目的目标的特性" class="headerlink" title="项目的目标的特性"></a>项目的目标的特性</h4><details green="" open="" style="box-sizing: border-box; display: block; padding: 16px; margin: 1em 0px; border-radius: 4px; background: rgb(255, 255, 255); font-size: 14px; transition: all 0.28s ease 0s; border: 1px solid rgba(61, 197, 80, 0.3);"><summary style="box-sizing: border-box; display: list-item; cursor: pointer; padding: 16px; margin: -16px -16px 0px; border-radius: 4px 4px 0px 0px; color: rgb(68, 68, 68); font-weight: bold; position: relative; line-height: normal; font-size: 0.875rem !important; background: rgb(235, 249, 237); border-bottom: 1px solid rgba(61, 197, 80, 0.3);">不同优先级</summary><div class="content" style="box-sizing: border-box; padding: 16px; margin: 0px -16px -16px;"><ul style="box-sizing: border-box; margin-top: 0.4rem; margin-bottom: 0px; padding: 0px 0px 0px 0.8rem; list-style: none; counter-reset: li 0;">            <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">项目约束性目标包括进度、成本、范围和质量，简称为项目目标三角形。除了这4个制约因素之外，还加上了风险和资源，并且最终要让客户满意。在实际项目中，他们之间的优先顺序通常由管理层决定。 </li></ul></div></details><details green="" open="" style="box-sizing: border-box; display: block; padding: 16px; margin: 1em 0px; border-radius: 4px; background: rgb(255, 255, 255); font-size: 14px; transition: all 0.28s ease 0s; border: 1px solid rgba(61, 197, 80, 0.3);"><summary style="box-sizing: border-box; display: list-item; cursor: pointer; padding: 16px; margin: -16px -16px 0px; border-radius: 4px 4px 0px 0px; color: rgb(68, 68, 68); font-weight: bold; position: relative; line-height: normal; font-size: 0.875rem !important; background: rgb(235, 249, 237); border-bottom: 1px solid rgba(61, 197, 80, 0.3);">层次性</summary><div class="content" style="box-sizing: border-box; padding: 16px; margin: 0px -16px -16px;"><ul style="box-sizing: border-box; margin-top: 0.4rem; margin-bottom: 0px; padding: 0px 0px 0px 0.8rem; list-style: none; counter-reset: li 0;">            <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">明确定义的项目目标按其意义和内容表示为一个层次结构，而且越较低层次的目标应该描述越清晰具体。清晰界定的某一层次目标通常直接作为初步的项目范围基准。 </li></ul></div></details><h4 id="项目的特征"><a href="#项目的特征" class="headerlink" title="项目的特征"></a>项目的特征</h4><details green="" open="" style="box-sizing: border-box; display: block; padding: 16px; margin: 1em 0px; border-radius: 4px; background: rgb(255, 255, 255); font-size: 14px; transition: all 0.28s ease 0s; border: 1px solid rgba(61, 197, 80, 0.3);"><summary style="box-sizing: border-box; display: list-item; cursor: pointer; padding: 16px; margin: -16px -16px 0px; border-radius: 4px 4px 0px 0px; color: rgb(68, 68, 68); font-weight: bold; position: relative; line-height: normal; font-size: 0.875rem !important; background: rgb(235, 249, 237); border-bottom: 1px solid rgba(61, 197, 80, 0.3);">特征</summary><div class="content" style="box-sizing: border-box; padding: 16px; margin: 0px -16px -16px;"><ul style="box-sizing: border-box; margin-top: 0.4rem; margin-bottom: 0px; padding: 0px 0px 0px 0.8rem; list-style: none; counter-reset: li 0;">    <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">有明确的目标</li>    <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">项目之间的活动具有相关性 </li>    <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">限定的周期 </li>        <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">有独特性 </li>            <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">资源成本的约束性  </li>                <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">项目的不确定性 </li>    </ul></div></details>**项目的三大特点：临时性、独特性和渐进明细性。**<h4 id="软件项目"><a href="#软件项目" class="headerlink" title="软件项目"></a>软件项目</h4><p>软件是计算机系统中与硬件相互依存的部分,它是包括程序、数据及相关文档的完整集合.</p><h4 id="软件项目的特殊性"><a href="#软件项目的特殊性" class="headerlink" title="软件项目的特殊性"></a>软件项目的特殊性</h4><ul><li>逻辑实体,具有抽象性</li><li>相互作用系统</li><li>变更</li><li>渐进明细</li></ul><h4 id="软件项目和日常运作区别"><a href="#软件项目和日常运作区别" class="headerlink" title="软件项目和日常运作区别"></a>软件项目和日常运作区别</h4><ul><li>项目是一次性的，日常运作是重复进行的</li><li>项目是以目标为导向的，日常运作是通过效率和有效性体现的</li><li>项目是通过与项目经理及其团队工作完成的，而日常运作是职能式的线形管理</li><li>大量的变更管理，而日常运作则基本保持持续的连贯性的</li><li>软件是逻辑实体，不是具体的物理实体，具有抽象性</li><li>软件的开发受计算机系统的限制，对硬件系统有不同程度的依赖</li><li>软件具有复杂性特点，其开发成本昂贵，制约因素很多</li></ul><h4 id="实现项目目标的制约因素"><a href="#实现项目目标的制约因素" class="headerlink" title="实现项目目标的制约因素"></a>实现项目目标的制约因素</h4><ul><li>工作范围</li><li>成本</li><li>进度计划</li><li>客户满意度</li></ul><h4 id="项目组合管理-Portfolio-、项目集-Programs-与项目-Project"><a href="#项目组合管理-Portfolio-、项目集-Programs-与项目-Project" class="headerlink" title="项目组合管理(Portfolio)、项目集(Programs)与项目(Project)"></a>项目组合管理(Portfolio)、项目集(Programs)与项目(Project)</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/xiangmuguanxi.jpg" alt="xiangmuguanxi"></h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/xiangmuguanxi.jpg" alt="xiangmuguanxi"></p><h3 id="1-2项目管理与软件项目管理"><a href="#1-2项目管理与软件项目管理" class="headerlink" title="1.2项目管理与软件项目管理"></a>1.2项目管理与软件项目管理</h3><h4 id="项目管理的定义"><a href="#项目管理的定义" class="headerlink" title="项目管理的定义"></a>项目管理的定义</h4><p>项目管理是一系列的伴随着项目的进行而进 行的、目的是为了确保项目能够达到期望的 结果的一系列管理行为。</p><h4 id="项目管理的主要内容"><a href="#项目管理的主要内容" class="headerlink" title="项目管理的主要内容"></a>项目管理的主要内容</h4><p>管理职能角度：项目计划、组织、人事安排、控制顿号协调</p><h4 id="软件开发项目管理定义"><a href="#软件开发项目管理定义" class="headerlink" title="软件开发项目管理定义"></a>软件开发项目管理定义</h4><p>软件项目管理是为了使软件项目能够按照‘预定的成本、进度、质量顺利完成，而对成本、人员、进度、质量、风险等进行分析和管理的活动。</p><h4 id="软件开发项目管理"><a href="#软件开发项目管理" class="headerlink" title="软件开发项目管理"></a>软件开发项目管理</h4><h4 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h4><ul><li>软件生产能力和业务发展需求不相适应的现象</li><li>就是弱的软件生产能力和强的业务发展需求之间的矛盾</li></ul><h4 id="软件开发项目管理的必要性"><a href="#软件开发项目管理的必要性" class="headerlink" title="软件开发项目管理的必要性"></a>软件开发项目管理的必要性</h4><p>无规则、混乱的开发状态，进度滞后，费用超支等失败的例子很多<br>业务失败，合同纠纷，法律诉讼，客户投诉等困扰软件业。</p><h4 id="软件项目管理的核心约束"><a href="#软件项目管理的核心约束" class="headerlink" title="软件项目管理的核心约束"></a>软件项目管理的核心约束</h4><p>确保软件项目满足进度,成本等约束,提交高质量软件产品(范围)</p><h3 id="1-3PMBOK与软件项目管理体系"><a href="#1-3PMBOK与软件项目管理体系" class="headerlink" title="1.3PMBOK与软件项目管理体系"></a>1.3PMBOK与软件项目管理体系</h3><h4 id="五个标准化过程"><a href="#五个标准化过程" class="headerlink" title="五个标准化过程"></a>五个标准化过程</h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/guanliguocheng.png" alt="guanliguocheng"></p><h4 id="PMBOK-9个知识领域的关系"><a href="#PMBOK-9个知识领域的关系" class="headerlink" title="PMBOK 9个知识领域的关系"></a>PMBOK 9<strong>个知识领域的关系</strong></h4><h4 id="PMBOK-9个知识领域的关系-img-软件项目管理-PMBOK-9个知识领域的关系-png"><a href="#PMBOK-9个知识领域的关系-img-软件项目管理-PMBOK-9个知识领域的关系-png" class="headerlink" title="![PMBOK 9个知识领域的关系](/img/软件项目管理/PMBOK 9个知识领域的关系.png)"></a>![PMBOK 9个知识领域的关系](/img/软件项目管理/PMBOK 9个知识领域的关系.png)</h4><h4 id="PMBOK-9-大过程领域"><a href="#PMBOK-9-大过程领域" class="headerlink" title="PMBOK 9 大过程领域"></a>PMBOK 9 <strong>大过程领域</strong></h4><p>![PMBOK 9 大过程领域](/img/软件项目管理/PMBOK 9 大过程领域.png)</p><h4 id="PMBOK-5-大过程组"><a href="#PMBOK-5-大过程组" class="headerlink" title="PMBOK 5 大过程组"></a>PMBOK 5 <strong>大过程组</strong></h4><h4 id="PMBOK-5-大过程组-img-软件项目管理-PMBOK-5-大过程组-png"><a href="#PMBOK-5-大过程组-img-软件项目管理-PMBOK-5-大过程组-png" class="headerlink" title="![PMBOK 5 大过程组](/img/软件项目管理/PMBOK 5 大过程组.png)"></a><strong>![PMBOK 5 大过程组](/img/软件项目管理/PMBOK 5 大过程组.png)</strong></h4><h3 id="1-4-敏捷项目管理"><a href="#1-4-敏捷项目管理" class="headerlink" title="1.4 敏捷项目管理"></a>1.4 敏捷项目管理</h3><h4 id="敏捷模型"><a href="#敏捷模型" class="headerlink" title="敏捷模型"></a>敏捷模型</h4><h4 id="敏捷宣言-4-价值"><a href="#敏捷宣言-4-价值" class="headerlink" title="敏捷宣言 - 4 价值"></a>敏捷宣言 - 4 价值</h4><ul><li><p>个体和互动 高于 流程和工具</p></li><li><p>可工作的软件 高于详尽的文档</p></li><li><p>客户合作 高于 合同谈判 </p></li><li><p>响应变化 高于遵循计划</p></li></ul><h4 id="敏捷原则"><a href="#敏捷原则" class="headerlink" title="敏捷原则"></a>敏捷原则</h4><ol><li>我们最重要的目标，是通过持续不断地及早交付有价值的软件来使客户满意。</li><li>欣然面对需求变化，即使在开发后期也一样，为了客户的竞争优势，要通过敏捷过程来适应变化。</li><li>经常性地交付可以工作的饮件，比如间隔几个星期或一两个月就交付，交付的时间间隔越短越好。</li><li>业务人员和开发人员必须相互合作，项目中的每一天都不例外。</li><li>激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支持，辅以信任，从而达成目标。</li><li>不论团队内外，效果最好且效率最高的传递信息的方式，就是面对面的交流。</li><li>可以工作的软件是首要的进度度量标准。</li><li>敏捷过程提倡可持续的开发速度。责任人、开发者和用户要能够共同维持其不断稳定延续。</li><li>坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。</li><li>以简洁为本，它是极力减少不必要工作量的艺术。</li><li>最好的架构、需求和设计出自自组织团队。</li><li>团队定期地反思如何能提高成效，并依此调整自身的举止行为。</li></ol><h3 id="1-5-软件项目管理过程"><a href="#1-5-软件项目管理过程" class="headerlink" title="1.5 软件项目管理过程"></a>1.5 软件项目管理过程</h3><h4 id="项目初始"><a href="#项目初始" class="headerlink" title="项目初始"></a>项目初始</h4><ul><li>项目确立</li><li>生存期</li></ul><h4 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h4><ul><li>范圉计划</li><li>成本计划</li><li>进度计划</li><li>质量计划</li><li>配署管理计划</li><li>团队计划</li><li>风险计划</li><li>合同计划</li></ul><h4 id="项目执行控制"><a href="#项目执行控制" class="headerlink" title="项目执行控制"></a>项目执行控制</h4><ul><li>集成计划执行控制</li><li>核心计划执行控制</li><li>辅助计划执行控制</li></ul><h4 id="项目结束"><a href="#项目结束" class="headerlink" title="项目结束"></a>项目结束</h4><h3 id="1-6-软件项目生命期"><a href="#1-6-软件项目生命期" class="headerlink" title="1.6 软件项目生命期"></a>1.6 软件项目生命期</h3><h4 id="生命期"><a href="#生命期" class="headerlink" title="生命期"></a>生命期</h4><p>六个周期</p><ul><li>计划阶段   定义系统，确定用户的要求或总体研究目标，提出可行的方案，包括资源、成本、效益、进度等的实施计划。进行可行性分析并制定粗略计划。</li><li>需求分析阶段   确定软件的功能、性能、可靠性、接口标准等要求，根据功能要求进行数据流程分析，提出初步的系统逻辑模型，并据此修改项目实施计划。</li><li>软件设计阶段   它包括系统概要设计和详细设计。在概要设计中，要建立系统的整体结构，进行模块划分，根据要求确定接口。在详细设计中，要建立算法、数据结构和流程图。 </li><li>编码阶段   把流程图翻译成程序，并对程序进行调试。</li><li>测试阶段   通过单元测试，检验模块内部的结构和功能；通过集成测试，把模块连接成系统，重点寻找接口上可能存在的问题；确认测试，即按照需求的内容逐项进行测试；系统测试，就是到实际的使用环境中进行测试。单元测试和集成测试由开发者自己完成，确认测试和系统测试则由用户参与完成。</li><li>运行维护阶段   它一般包括三类工作，为了修改错误而做的改正性维护；为了适应环境变化而做的适应性维护；为了适应用户新的需求而做的完善性维护，有时会成为二次开发，进入一个新的生命期，再从计划阶段开始。 </li></ul><blockquote><p>简述:</p><p>概念（Concept）<br>开发（Development）<br>实施（Implementation）<br>结束（Termination）</p></blockquote><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>检查点(Check Point) 它指在规定的时间间隔内对项目进行检查，比较实际现状与计划之间的差异，并根据差异进行调整</li><li>里程碑(Mile Stone)  它是完成阶段性工作的标志，不同类型的项目里程碑不同 </li><li>基线(Base Line)  它指一个(或一组)配置项在项目生命期的不同时间点上，通过正式评审而进入正式受控的一种状态</li></ul><h2 id="第-2-章-软件项确立"><a href="#第-2-章-软件项确立" class="headerlink" title="第 2 章 软件项确立"></a><strong>第 2 章 软件项确立</strong></h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><blockquote><p>合同是使卖方负有提供具体产品和服务的责任，买方负有为该产品和产品服务付款的责任的一种双方相互负有义务的协议。</p></blockquote><ul><li>合同定义了合同签署方的权利与义务，以及违背协议会造成的相应法律后果；</li><li>合同监督项目执行的各方履行其权利和义务，它是具有法律效力的文件；围绕合同，存在合同签署之前和合同签署之后的一系列工作。 </li></ul><h4 id="2-技术合同"><a href="#2-技术合同" class="headerlink" title="2. 技术合同"></a>2. 技术合同</h4><p><strong>软件项目合同主要是技术合同</strong></p><blockquote><p>技术合同是法人之间、法人和公民之间、公民之间以技术开发、技术转让、技术咨询和技术服务为内容，明确相互权利义务关系所达成的协议；</p><p>技术合同有三种环境：需（甲）方环境、供（乙）方环境和内部环境；<br>技术合同一般包括主合同和合同附件。 </p></blockquote><h4 id="3-技术合同内容"><a href="#3-技术合同内容" class="headerlink" title="3. 技术合同内容"></a>3. 技术合同内容</h4><ul><li>项目名称；</li><li>项目的技术内容、范围、形式和要求；</li><li>项目实施计划、进度、期限、地点和方式；</li><li>项目合同价款、报酬及其支付方式；</li><li>项目验收标准和方法；</li><li>各方当事人义务或协作责任；</li><li>技术成果归属和分享及后续改进的提供与分享规定；</li><li>技术保密事项；</li><li>风险责任的承担；</li><li>违约金或者损失赔偿额的计算方法、仲裁及其它。 </li></ul><h4 id="4-技术合同附件"><a href="#4-技术合同附件" class="headerlink" title="4. 技术合同附件"></a>4. 技术合同附件</h4><ul><li>系统的商务报价表；</li><li>系统的需求规格说明书；</li><li>项目的工程进度计划书；</li><li>技术服务承诺；</li><li>培训计划；</li><li>移交的用户文档和技术文档；</li><li>场地和环境准备要求；</li><li>测试与验收标准；</li><li>初验与终验报告样式范本；</li><li>工程实施的分工界面定义。</li></ul><h4 id="5-合同生存周期"><a href="#5-合同生存周期" class="headerlink" title="5. 合同生存周期"></a>5. 合同生存周期</h4><ul><li>合同准备</li><li>合同签署</li><li>合同管理</li><li>合同终止</li></ul><h3 id="2-2-需方合同环境-甲方"><a href="#2-2-需方合同环境-甲方" class="headerlink" title="2.2 需方合同环境(甲方)"></a>2.2 需方合同环境(甲方)</h3><blockquote><p>企业在需方合同环境下，关键要素是提供准确、清晰和完整的需求，选择合格的供方并对采购对象（采购对象包括产品服务、人力资源等）进行必要的验收。<br>这个需求可能来自于企业内部的需要，也可能是在为客户开发的软件项目中的一部分，通过寻找合适的软件开发商，将部分软件外包给其他的开发商。</p></blockquote><h4 id="合同准备"><a href="#合同准备" class="headerlink" title="合同准备"></a>合同准备</h4><ul><li><p>招标书定义(采购需求定义)  启动一个项目主要是由于存在一种需求，招标书定义主要是需方的需求定义，也就是甲方(买方)定义采购的内容。 </p><p><strong>招标书主要内容可分为三大部分：程序条款、技术条款、商务条款。</strong></p><p>包含下列主要九项内容：1、招标邀请函;2、投标人须知;3、招标项目的技术要求及附件;4、投标书格式;5、投标保证文件;6、合同条件(合同的一般条款及特殊条款);7、技术标准、规范;8、投标企业资格文件;9、合同格式。</p><blockquote><p>流程如下：</p><p>需方申请</p><p>需求定义</p><p>商务条件确定</p><p>验收标准确定</p><p>资料汇集</p><p>采购需求认可</p><p>编写招标文件</p><p>招标文件</p></blockquote></li><li><p>供方选择  招标文件确定后，就可以通过招标的方式选择供方（乙方或者卖方）。 </p><blockquote><p>流程如下：</p><p>招标文件</p><p>招标</p><p>手机供方的建议书</p><p>评定供方</p><p>最终供方确定</p><p>供方名单</p><p>建议书</p></blockquote></li><li><p>合同文本准备   如果需方选择了合适的供方（软件开发商），需方应该与供方（软件开发商）签订一个具有法律效力的合同；签署合同之前需要起草一份合同文本。 </p><blockquote><p>采购资料</p><p>合同草案指定</p><p>合同草案评审</p><p>合同草案修订</p><p>合同草案确定</p><p>合同草案</p></blockquote></li></ul><h4 id="合同签署"><a href="#合同签署" class="headerlink" title="合同签署"></a>合同签署</h4><blockquote><p>合同签署过程就是正式签署合同，使之成为具有法律效力的文件；<br>同时，根据签署的合同，分解出合同中需方(甲方)的任务，并下达任务书，指派相应的项目经理负责相应的过程。 </p></blockquote><ul><li>合同草案</li><li>谈判日程确定</li><li>合同草案提交</li><li>合同条款协商</li><li>合同签署文本确定</li><li>合同签署文本审阅</li><li>合同签署</li><li>合同签署文本</li><li>任务书下达</li></ul><h4 id="合同管理"><a href="#合同管理" class="headerlink" title="合同管理"></a>合同管理</h4><blockquote><p> 对于企业处于需方(甲方)的环境，合同管理是需方对供方(乙方)执行合同的情况进行监督的过程，</p></blockquote><p>主要包括：<br>对需求对象（采购对象）的验收  验收过程是需方对供方交付的产品或服务进行验收检验，以保证它满足合同条款的要求。<br>对违约事件处理  在合同的执行过程中，如果供方发生与合同要求不一致的问题，导致违约事件，需要执行违约事件处理过程。</p><p><strong>验收过程</strong></p><p><strong>违约处理</strong></p><h4 id="合同终止"><a href="#合同终止" class="headerlink" title="合同终止"></a>合同终止</h4><blockquote><p>当项目满足结束的条件，项目经理或者合同管理者应该及时宣布项目结束，终止合同的执行，通过合同终止过程告知各方合同终止</p></blockquote><p><strong>过程</strong></p><ul><li>合同</li><li>合同相关文档归档</li><li>合同终止通知</li><li>项目执行总结</li><li>项目总结</li></ul><h3 id="2-3-供方合同环境-乙方"><a href="#2-3-供方合同环境-乙方" class="headerlink" title="2.3 供方合同环境(乙方)"></a>2.3 供方合同环境(乙方)</h3><blockquote><p>企业在供方(乙方)合同环境下，关键要素是了解清楚需方（甲方）的要求并判断企业是否有能力来满足这些需求。<br>作为软件开发商，更多担任的是供方的角色。 </p></blockquote><h4 id="合同准备-1"><a href="#合同准备-1" class="headerlink" title="合同准备"></a>合同准备</h4><ul><li>项目分析  项目分析是供方分析用户的项目需求，并据此开发出—初步的项目计划，作为下一步能力评估和可行性分析之用。 </li><li>项目竞标<br>能力评估；<br>可行性分析；<br>参加竞标。</li><li>合同文本准备  一般是需方(甲方)提供合同的框架结构，并起草主要内容，供方(乙方)提供意见。 </li></ul><h4 id="合同签署-1"><a href="#合同签署-1" class="headerlink" title="合同签署"></a>合同签署</h4><ul><li>供方的合同签署过程也类似于需方的合同签署过程，但是这个阶段对于供方的意义是重大的，它标志着一个软件项目的有效开始，这个时候，应该正式确定供方的项目经理。</li><li>这里需要说明的是项目任务书，项目任务书明确项目的目标、必要的约束，同时授权给项目经理。</li><li><strong>项目任务书是项目正式开始的标志</strong>，同时也是对项目经理有效授权的依据。<br>项目经理需要对这个任务书进行确认。</li><li>具体活动描述可以参见需方的合同签署过程。</li></ul><h4 id="合同管理-1"><a href="#合同管理-1" class="headerlink" title="合同管理"></a>合同管理</h4><ul><li>合同跟踪管理过程</li><li>合同修改控制过程</li><li>违约事件处理过程</li><li>产品交付过程</li><li>产品维护过程</li></ul><h4 id="合同终止-1"><a href="#合同终止-1" class="headerlink" title="合同终止"></a>合同终止</h4><blockquote><p>在合同终止过程中，供方应该配合需方的工作，包括：项目的验收、双方认可签字、总结项目的经验教训、获取合同的最后款项、开具相应的发票、获取需方的合同终止的通知、将合同相关文件归档。</p></blockquote><p><strong>过程</strong></p><ul><li>合同</li><li>合同相关文档归档</li><li>合同终止通知</li><li>项目执行总结</li><li>项目总结</li></ul><h3 id="2-4-企业内部的合同环境"><a href="#2-4-企业内部的合同环境" class="headerlink" title="2.4 企业内部的合同环境"></a>2.4 企业内部的合同环境</h3><blockquote><p>企业内部项目实施管理的核心是确定任务范围和确保相关各方进行有效的配合，这可以通过相关各方之间的“协议”来保证，此处“协议”可视为“合同”。</p></blockquote><p>企业内部项目“合同”无特别的商业约束。 </p><p><strong>总结</strong></p><ul><li><p>软件项目技术合同的执行过程可以划分为四个阶段，即：合同准备、合同签署、合同管理与合同终止。</p></li><li><p>针对企业在不同合同环境中承担的不同角色，又可将合同管理分为需方合同管理、供方合同管理及内部合同管理。</p></li><li><p>作为软件企业，一般是处于供方(乙方)的角色，因此，软件企业的项目经理应该重点掌握供方(乙方)的合同管理过程。</p></li><li><p>合同标志一个项目的真正开始，通过项目任务单明确项目经理，从此，项目经理可以真正行使相应的职责和权力。</p></li></ul><h2 id="第-3-章-软件生存期模型"><a href="#第-3-章-软件生存期模型" class="headerlink" title="第 3 章 软件生存期模型"></a><strong>第 3 章 软件生存期模型</strong></h2><h3 id="3-1-CMM-和-ISO9000"><a href="#3-1-CMM-和-ISO9000" class="headerlink" title="3.1 CMM 和 ISO9000"></a>3.1 CMM 和 ISO9000</h3><h4 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h4><blockquote><p>为了保证软件产品的质量，1991年美国卡内基·梅隆大学软件工程研究所（CMU/SEI）将软件过程成熟度框架进化为软件能力成熟度模型（Capability Maturity Model For Software，简称SW-CMM），并发布了最早的SW-CMM 1.0版。<br>SW-CMM为软件企业的过程能力提供了一个阶梯式的进化框架，阶梯共有五级。</p><p>(1)初始级(initial)。工作无序，项目进行过程中常放弃当初的计划。管理无章法，缺乏健全的管理制度。开发项目成效不稳定，项目成功主要依靠项目负责人的经验和能力，他一但离去，工作秩序面目全非。</p><p>(2)可重复级(Repeatable)。管理制度化，建立了基本的管理制度和规程，管理工作有章可循。初步实现标准化，开发工作比较好地按标准实施。变更依法进行，做到基线化，稳定可跟踪，新项目的计划和管理基于过去的实践经验，具有重复以前成功项目的环境和条件。</p><p>(3)已定义级(Defined)。开发过程，包括技术工作和管理工作，均已实现标准化、文档化。建立了完善的培训制度和专家评审制度，全部技术活动和管理活动均可控制，对项目进行中的过程、岗位和职责均有共同的理解。</p><p>(4)已管理级(Managed)。产品和过程已建立了定量的质量目标。开发活动中的生产率和质量是可量度的。已建立过程数据库。已实现项目产品和过程的控制。可预测过程和产品质量趋势，如预测偏差，实现及时纠正。</p><p>(5)优化级(Optimizing)。可集中精力改进过程，采用新技术、新方法。拥有防止出现缺陷、识别薄弱环节以及加以改进的手段。可取得过程有效性的统计数据，并可据进行分析，从而得出最佳方法</p></blockquote><p><strong>概念描述</strong></p><ul><li><p>软件过程</p><blockquote><p>是指人们用于开发和维护软件及其相关产品的一系列活动、方法、实践和革新。</p></blockquote></li><li><p>软件开发过程管理</p><blockquote><p>是指在软件开发过程中，除了先进技术和开发方法外，还有一整套的管理技术。</p></blockquote></li><li><p>软件过程改进</p><blockquote><p>是针对软件生产过程中会对产品质量产生影响的问题而进行的，它的直接结果是软件过程能力的提高。<br>现在常见的软件过程改进方法：ISO 9000，SW-CMM和由多种能力模型演变而来的CMMI。</p></blockquote></li></ul><h4 id="KP"><a href="#KP" class="headerlink" title="KP"></a>KP</h4><p>除第一级外，SW-CMM的每一级都是按完全相同的结构组成的。每一级包含了实现这一级目标的若干关键过程域（KPA），每个KPA进一步包含若干关键实施活动（KP），无论哪个KPA，它们的实施活动都统一按六个公共属性进行组织，即每一个KPA都包含六类KP：</p><ol><li>目标</li><li>实施保证</li><li>实施能力  </li><li>执行活动  </li><li>度量分析</li><li>实施验证</li></ol><h4 id="CMMI"><a href="#CMMI" class="headerlink" title="CMMI"></a>CMMI</h4><blockquote><p>由于不同领域能力成熟度模型存在不同的过程改进，重复的培训、评估和改进活动以及活动不协调等一些问题。于是由美国国防部出面，美国卡内基·梅隆大学软件工程研究所（CMU/SEI）于2001年12月发布的CMMI 1.1版本包括四个领域：软件工程（SW）、系统工程（SE）、集成的产品和过程开发（IPPD）、采购（SS）。</p></blockquote><ul><li>CMMI有两种不同的实施方法<ul><li>连续式－－主要是衡量一个企业的项目能力</li><li>阶段式－－主要是衡量一个企业的成熟度</li></ul></li><li>CMMI的五个台阶<ul><li>完成级</li><li>管理级 </li><li>定义级 </li><li>量化管理级 </li><li>优化级 </li></ul></li><li>每一个台阶都是上面一阶台阶的基石。要上高层台阶必须首先踏上较低一层台阶。 </li></ul><h4 id="ISO9000"><a href="#ISO9000" class="headerlink" title="ISO9000"></a>ISO9000</h4><blockquote><p> 所谓“ISO9000”不是指一般意义上的一个质量保证标准，而是一族系列标准的统称。 </p></blockquote><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>强化品质管理，提高企业效益；增强客户信心，扩大市场份额；</li><li>获得了国际贸易“通行证”，消除了国际贸易壁垒；</li><li>节省了第二方审核的精力和费用；</li><li>在产品品质竞争中永远立于不败之地；</li><li>有效地避免产品责任；</li><li>有利于国际间的经济合作和技术交流。</li></ul><h4 id="三者之间的比较"><a href="#三者之间的比较" class="headerlink" title="三者之间的比较"></a>三者之间的比较</h4><ul><li>选择SW-CMM还是CMMI的考虑<ul><li>实施企业的业务特点。</li><li>实施企业对过程改进的熟悉程度。</li><li>实施企业对过程改进项目的预算。</li><li>实施企业是否可以使用阶段式的演进路线。</li><li>实施CMM与CMMI可以平滑的转换。</li></ul></li><li>ISO9001与CMM的关系<ul><li>ISO9001和CMM既有区别又相互联系，两者不可简单地互相替代。</li><li>取得ISO9001认证并不意味着完全满足CMM某个等级的要求。</li><li>取得CMM第2级(或第3级)不能笼统地认为可以满足ISO9001的要求。</li></ul></li></ul><h3 id="3-2-生存期的项目特征"><a href="#3-2-生存期的项目特征" class="headerlink" title="3.2 生存期的项目特征"></a>3.2 生存期的项目特征</h3><table><thead><tr><th align="left">方法(Approach)</th><th>项目需求</th><th>开发活动</th><th>产品交付</th><th>目标</th></tr></thead><tbody><tr><td align="left">预测型(Predictive)</td><td>稳定（Fixed）</td><td>对整个项目执行一次</td><td>只提交一次</td><td>管理成本</td></tr><tr><td align="left">迭代型（Iterative）</td><td>不断变化的（Dynamic）</td><td>不断重复直到正确</td><td>只提交一次</td><td>获得正确的解决方案</td></tr><tr><td align="left">增量型（Incremental）</td><td>不断变化的</td><td>每次增量活动只执行一次</td><td>多次提交小版本</td><td>速度</td></tr><tr><td align="left">敏捷型（Agile）</td><td>不断变化的</td><td>不断重复一些活动直到正确</td><td>多次提交小版本</td><td>获得用户肯定</td></tr></tbody></table><h4 id="预测生存期模型"><a href="#预测生存期模型" class="headerlink" title="预测生存期模型"></a>预测生存期模型</h4><p><strong>预测模型：</strong> 项目具有高确定性，有很明确的绣球，项目活动通常以顺序方式执行(无反馈)。</p><p><strong>流程：</strong> Analyze(分析)–&gt;Design(设计)–&gt;Build–&gt;Test–&gt;Deliver</p><p>如瀑布模型，V模型。</p><h4 id="迭代生存期模型"><a href="#迭代生存期模型" class="headerlink" title="迭代生存期模型"></a>迭代生存期模型</h4><p><strong>迭代模型：</strong> 是通过连续的原型和概念验证来改进产品或结果，每一个新的原型都能带来新的相关反馈和团队的见解。</p><p>迭代模型有利于识别和减少项目的不确定性，也称为原型模型。(优点：可应对需求变化，缺点：时间长)</p><h4 id="增量生存期模型"><a href="#增量生存期模型" class="headerlink" title="增量生存期模型"></a>增量生存期模型</h4><p><strong>增量模型：</strong> 一个增量一个增量的开发过程，每个增量是一个交付成果。即增量模型向客户提交完成的可交付的成功，让用户可以立即使用。</p><h4 id="敏捷生存期模型"><a href="#敏捷生存期模型" class="headerlink" title="敏捷生存期模型"></a>敏捷生存期模型</h4><p>敏捷模型是符合《敏捷宣言》原则的模型，客户满意度将随着有价值产品的早期交付和持续交付不断提升。此外，功能性的、提供价值的增量可交付成果是衡量进展的主要尺度。为了适应更频繁的变更，更频繁底交付项目价值，敏捷模型结合了迭代和增量模型的方法。</p><p>在敏捷开发环境中，团队假设需求会发生变更。迭代和增量方法能够提供反馈，一遍改善项目下一部分的计划。在敏捷项目中，增量交付会发现隐藏或误解的需求。</p><p>敏捷方法是一个囊括了各种框架和方法的涵盖性术语。</p><p>Scrum模型是敏捷模型的代表。</p><p>敏捷是多种方法的统称，如Scrum、XP、Scrumban、OpenUp、看板方法、精益(lean)、持续交付、devOps等。</p><h3 id="3-2-传统软件开发生命周期模型"><a href="#3-2-传统软件开发生命周期模型" class="headerlink" title="3.2 传统软件开发生命周期模型"></a>3.2 传统软件开发生命周期模型</h3><blockquote><p>软件从需求确定、设计、开发、测试直至投入使用，并在使用中不断地修改、增补和完善，直至被新的系统所替代而停止该软件的使用的全过程。</p></blockquote><p>可划分为以下子阶段 </p><p> 1.可行性研究</p><p>2.需求分析和问题定义</p><p>3.总体设计</p><p>4.详细设计</p><p>5.编码（实现）</p><p>6.软件测试、运行维护　　</p><p><strong>据此相继产生了瀑布模型、螺旋模型、进化模型、原型模型、增量模型等。</strong>本节分别对这几种传统的软件开发生命周期模型予以介绍。 </p><h4 id="1-瀑布模型"><a href="#1-瀑布模型" class="headerlink" title="1) 瀑布模型"></a>1) 瀑布模型</h4><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><ul><li>系统需求</li><li>软件需求</li><li>分析</li><li>设计</li><li>编码</li><li>测试</li><li>运行</li></ul><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/pubu.png" alt="pubu"></p><h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>文档驱动的模型</li><li>阶段间具有顺序性和依赖性</li><li>项目开发周期较长</li><li>实际项目很少按照该模型给出的顺序进行</li><li>客户必须能够完整、正确和清晰地表达他们的需求</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>容易理解，管理成本低；强调开发的阶段性早起计划及需求调查和产品测试。软件项目较小</p><h4 id="2-快速原型模型"><a href="#2-快速原型模型" class="headerlink" title="2) 快速原型模型"></a>2) 快速原型模型</h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/yuanxing.png" alt="yuanxing"></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>在需求定义之前，需要快速构建一个系统</li><li>先看界面，然后实现功能，<strong>根据构建系统的优缺点，用户给开发人员提出反馈意见</strong></li><li>根据反馈意见修改软件需求规格，以便系统可以更正确地反映用户的需求</li><li>减少各种假设以及风险</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>为了尽快完成原型，开发者没有考虑整体软件的质量和changing的可维护性，系统结构通常较差</li><li>可能混淆原型系统和最终系统</li><li>额外的开发费用</li></ul><h4 id="3-增量模型"><a href="#3-增量模型" class="headerlink" title="3) 增量模型"></a>3) 增量模型</h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E5%A2%9E%E9%87%8F.png" alt="增量"></p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li><p><strong>为避免一次性投资太多带来的风险</strong></p></li><li><p>融合了瀑布模型和原型的迭代特征。</p></li><li><p>每一个增量均发布一个可操作产品。</p></li><li><p>较短的时间向用户提交有用的功能</p></li><li><p>逐步增加产品的功能</p></li><li><p>项目失败风险低</p></li><li><p><strong>优先级最高的服务首先交付</strong>，意味着软件马上就能使用</p></li></ul><h5 id="使用条件-1"><a href="#使用条件-1" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li><p>如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；</p></li><li><p>如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发；</p></li><li><p>管理发生的成本、进度和配置的复杂性，可能会超出组织的能力。</p></li></ul><h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><p>Word 字处理软件</p><p>教务系统</p><h4 id="4）进化模型"><a href="#4）进化模型" class="headerlink" title="4）进化模型"></a>4）进化模型</h4><p>这个模型可看作是重复执行的多个瀑布模型。</p><p> <img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BF%9B%E5%8C%96.png" alt="进化"></p><h4 id="5-螺旋模型"><a href="#5-螺旋模型" class="headerlink" title="5) 螺旋模型"></a>5) 螺旋模型</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/luoxuan.png" alt="luoxuan"></h4><blockquote><p> 螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析，弥补了这两种模型的不足。</p></blockquote><h5 id="使用条件-2"><a href="#使用条件-2" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>基于风险驱动的开发模型, 使用原型法或其它方法来尽量降低风险。</li><li>适用于需求不明确的大规模软件项目</li></ul><h4 id="6-V模型"><a href="#6-V模型" class="headerlink" title="6) V模型"></a>6) V模型</h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/vmoxing.png" alt="vmoxing"></p><h5 id="使用条件-3"><a href="#使用条件-3" class="headerlink" title="使用条件"></a>使用条件</h5><p>甲方提供了详细，准确的需求文档，我们的解决方案也是很明确，且安全性要求非常的严格.</p><h3 id="3-3-扩展的软件开发生命周期模型"><a href="#3-3-扩展的软件开发生命周期模型" class="headerlink" title="3.3 扩展的软件开发生命周期模型"></a>3.3 扩展的软件开发生命周期模型</h3><h4 id="极限模型"><a href="#极限模型" class="headerlink" title="极限模型"></a>极限模型</h4><blockquote><p>2001年，为了避免许多公司的软件团队陷入不断增长的过程泥潭，一批业界专家一起概括出了一些敏捷开发过程的方法：SCRUM，Crystal，特征驱动软件开发（Feature Driven Development，简称FDD），自适应软件开发（Adaptive Software Development，简称ASD），以及最重要的极限编程（eXtreme Programming,简称XP）。 </p></blockquote><p>极限编程将开发阶段的4个活动（<strong>分析、设计、编码和测试</strong>）混合在一起，在全过程中采用迭代增量开发、反馈修正和反复测试。 </p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E6%9E%81%E9%99%90%E6%A8%A1%E5%9E%8B.png" alt="极限模型"></p><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><ul><li>交流（Communication）</li><li>简单（Simplicity ）</li><li>反馈（Feedback）</li><li>进取（Aggressiveness）</li></ul><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li>优点<ul><li>采用简单计划策略，不需要长期计划和复杂模型，开发周期短；</li><li>在全过程采用迭代增量开发、反馈修正和反复测试的方法，能够适应用户经常变化的需求。</li></ul></li><li>缺点<ul><li>目前主要在小规模项目上应用并取得成功，但是否适用于中等规模或大规模软件产品，需慎重考虑；</li><li>由于这个模型较新产品交付后维护成本是否降低，不能确定；<br>对编码人员的经验要求高</li></ul></li></ul><h4 id="Rational统一过程-（RUP）"><a href="#Rational统一过程-（RUP）" class="headerlink" title="Rational统一过程 （RUP）"></a>Rational统一过程 （RUP）</h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/rmp.png" alt="rmp"></p><ul><li>用例驱动<br>Concise, simple, and understandable </li><li>以体系结构为中心<br>Effective basis for large-scale reuse</li><li>增量和迭代开发<br>基于风险前驱的原则，渐进地展开分析、设计及其相关活动，每个迭代都会提供一次验证和调整模型机会，推动软件质量的提升。</li></ul><h4 id="Scrum模型"><a href="#Scrum模型" class="headerlink" title="Scrum模型"></a>Scrum模型</h4><p>2层的项目规划，迭代式的软件开发过程，4个管理会议。</p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/scrum.png" alt="scrum"></p><h5 id="2层的项目规划"><a href="#2层的项目规划" class="headerlink" title="2层的项目规划"></a>2层的项目规划</h5><ul><li>体现为远期的项目计划和近期的计划，基于远粗近细的原则</li><li>远期计划和近期计划通过产品订单和冲刺订单体现</li><li>产品订单是所有需求的唯一来源，所有工作来自于它，开始阶段模糊，随着时间推移越来越明确。最高优先等级需求就是</li><li>当前冲刺订单，冲刺订单是当前迭代完成的任务清单。</li></ul><h5 id="迭代式的开发"><a href="#迭代式的开发" class="headerlink" title="迭代式的开发"></a>迭代式的开发</h5><ul><li>通过将整个软件交付过程分为多个迭代周期，一个迭代就是一个冲刺(Sprint)。</li><li>每个迭代周期2-4周，迭代内任务有详细的分解估算，可以分解到小时，迭代结束时提交一个运行版本。</li></ul><h5 id="4个管理会议"><a href="#4个管理会议" class="headerlink" title="4个管理会议"></a>4个管理会议</h5><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/sigeguanlihuiyi.png" alt="sigeguanlihuiyi"></p><h5 id="XP-eXtreme-Programming-极限编程模型"><a href="#XP-eXtreme-Programming-极限编程模型" class="headerlink" title="XP(eXtreme Programming) 极限编程模型"></a>XP(eXtreme Programming) 极限编程模型</h5><p>XP极限编程是由Kent Beck提出的一套针对业务需求和软件开发时间的规划。</p><h5 id="13个最佳实践"><a href="#13个最佳实践" class="headerlink" title="13个最佳实践"></a>13个最佳实践</h5><ul><li>整体实践：Whole Team，Customer Test，Small Releases(小版本)，Planing Game</li><li>开发团队实践：Collective Ownership，Coding Standard(编程标准)，Continuous Integration(持续集成)，Metaphor，</li><li>Sustainable Pace(恒定速度)</li><li>开发者实践：Test Driven，Development，Pair Programming，Simple Design，Refactoring(重构)</li></ul><h5 id="精益模型-lean-：-提倡持续不断的改进，减少流程中浪费。"><a href="#精益模型-lean-：-提倡持续不断的改进，减少流程中浪费。" class="headerlink" title="精益模型(lean)： 提倡持续不断的改进，减少流程中浪费。"></a>精益模型(lean)： 提倡持续不断的改进，减少流程中浪费。</h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/lean.png" alt="lean"></h5><h5 id="持续交付：-经典的敏捷软件开发延伸能够以较短周期完成需求的小粒度频繁交付。-持续集成，持续部署，持续交付"><a href="#持续交付：-经典的敏捷软件开发延伸能够以较短周期完成需求的小粒度频繁交付。-持续集成，持续部署，持续交付" class="headerlink" title="持续交付： 经典的敏捷软件开发延伸能够以较短周期完成需求的小粒度频繁交付。(持续集成，持续部署，持续交付)"></a>持续交付： 经典的敏捷软件开发延伸能够以较短周期完成需求的小粒度频繁交付。(持续集成，持续部署，持续交付)</h5><ul><li>持续集成：将个人代码像整体部分交付，以便尽早发现个人开发部分的问题</li><li>持续部署：集成的代码尽快向可运行的环境来交付，以便尽早测试</li><li>持续交付：尽快向客户交付以便尽早发现生产环境中存在的问题</li></ul><p>由持续交付演变成DevOps(Development和Operations的组合)融合一系列基本原则和实践的方法论。</p><h5 id="全程敏捷思维-开发段和运维端工作紧密合作"><a href="#全程敏捷思维-开发段和运维端工作紧密合作" class="headerlink" title="全程敏捷思维(开发段和运维端工作紧密合作)"></a>全程敏捷思维(开发段和运维端工作紧密合作)</h5><p>开发人员与运维人员的差异：开发人员希望尽快提交产品，运维端希望产品更加合理化，高性能，高可靠性，减少运维成本。</p><h5 id="DevOps：-是一组过程，方法与系统的统称，用于促进开发，技术运营和质量保障-QA-部门之间的沟通，协作与整合。"><a href="#DevOps：-是一组过程，方法与系统的统称，用于促进开发，技术运营和质量保障-QA-部门之间的沟通，协作与整合。" class="headerlink" title="DevOps： 是一组过程，方法与系统的统称，用于促进开发，技术运营和质量保障(QA)部门之间的沟通，协作与整合。"></a>DevOps： 是一组过程，方法与系统的统称，用于促进开发，技术运营和质量保障(QA)部门之间的沟通，协作与整合。</h5><h3 id="3-4-质量计划"><a href="#3-4-质量计划" class="headerlink" title="3.4 质量计划"></a>3.4 质量计划</h3><p>软件质量</p><blockquote><p>是“所有描述计算机软件优秀程度的特性的组合”</p></blockquote><p>软件质量度量模型有三层组成</p><ul><li>质量特性</li><li>质量子特性</li><li>度量</li></ul><h4 id="质量特性"><a href="#质量特性" class="headerlink" title="质量特性"></a>质量特性</h4><ul><li>功能性</li><li>可靠性</li><li>易使用性</li><li>高效性</li><li>可维护性</li><li>可移植性</li></ul><h4 id="质量规划"><a href="#质量规划" class="headerlink" title="质量规划"></a>质量规划</h4><blockquote><p>识别哪些质量标准适用于软件项目，并确定如何满足这些标准的需求</p></blockquote><h5 id="质量体系"><a href="#质量体系" class="headerlink" title="质量体系"></a>质量体系</h5><blockquote><p>指为保证产品，过程或服务质量，满足规定(或潜在)的要求，有组织机构，职责，程序，活动，能力和资源等构成的有机整体</p></blockquote><h5 id="质量手册"><a href="#质量手册" class="headerlink" title="质量手册"></a>质量手册</h5><blockquote><p>描述企业质量体系的文件</p></blockquote><h5 id="质量计划"><a href="#质量计划" class="headerlink" title="质量计划"></a>质量计划</h5><blockquote><p>质量管理的第一过程域</p></blockquote><h6 id="质量计划内容"><a href="#质量计划内容" class="headerlink" title="质量计划内容"></a>质量计划内容</h6><ul><li>项目实施总体目标<ul><li>质量</li><li>时间</li><li>成本</li></ul></li><li>项目分类<ul><li>质量倾斜型体系</li><li>工期倾斜型体系</li><li>成本倾斜型体系</li></ul></li><li>软件生命周期三大阶段<ul><li>软件定义</li><li>软件开发</li><li>软件使用和维护</li></ul></li></ul><h6 id="质量计划的编写"><a href="#质量计划的编写" class="headerlink" title="质量计划的编写"></a>质量计划的编写</h6><h4 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h4><ul><li>检测</li><li>控制</li></ul><h2 id="第-4-章-软件需求管理"><a href="#第-4-章-软件需求管理" class="headerlink" title="第 4 章 软件需求管理"></a><strong>第 4 章 软件需求管理</strong></h2><h2 id="第-5-章-软件项目任务分解"><a href="#第-5-章-软件项目任务分解" class="headerlink" title="第 5 章 软件项目任务分解"></a><strong>第 5 章 软件项目任务分解</strong></h2><h2 id="第-6-章-软件项目成本计划"><a href="#第-6-章-软件项目成本计划" class="headerlink" title="第 6 章 软件项目成本计划"></a><strong>第 6 章 软件项目成本计划</strong></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软件项目管理&quot;&gt;&lt;a href=&quot;#软件项目管理&quot; class=&quot;headerlink&quot; title=&quot;软件项目管理&quot;&gt;&lt;/a&gt;软件项目管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;&quot;&gt;&lt;strong&gt;持续更新~&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="软件项目管理" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="软件项目管理" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    <category term="总结" scheme="http://example.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/09/02/hello-world/"/>
    <id>http://example.com/2021/09/02/hello-world/</id>
    <published>2021-09-02T02:30:46.000Z</published>
    <updated>2021-09-06T09:59:01.935Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
