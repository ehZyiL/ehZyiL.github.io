<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ehZyiL的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-05T03:04:51.752Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ehZyiL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Day06</title>
    <link href="http://example.com/2021/09/05/JAVA/day06%E3%80%90Map%E3%80%91/"/>
    <id>http://example.com/2021/09/05/JAVA/day06%E3%80%90Map%E3%80%91/</id>
    <published>2021-09-05T02:35:46.000Z</published>
    <updated>2021-09-05T03:04:51.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day06【Map】"><a href="#day06【Map】" class="headerlink" title="day06【Map】"></a>day06【Map】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>Map集合  ，Collection集合<ul><li> 键值对集合，用的也很多。</li><li> Collection集合（单列集合，一个元素只能一个值。）</li><li> Map集合（双列集合，一个元素有2个值，每个元素叫键值对象，元素格式必须是：key=value）</li><li> <strong>List<String> names = new ArrayList&lt;&gt;();</strong></li><li> <strong>Set<Student> names = new HashSet&lt;&gt;();</strong></li><li> <strong>Map&lt;String , String&gt; names = new HashMap&lt;&gt;()；</strong></li></ul></li><li>图书管理系统(用的代码！)<ul><li> 让我们把集合和Map集合都用起来，然后引入一些业务思维做一个综合性的案例！</li></ul></li><li>Debug调试。(非常重要的排错手段)<ul><li> bug</li></ul></li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><p><input disabled="" type="checkbox">  能够使用集合工具类</p><pre><code class="java"> Collections下的API:    1、public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements)        -- 参数一：操作的集合对象。                -- 参数二：可变参数，给集合批量加的元素值。            2、public static void shuffle(List&lt;?&gt; list)：                -- 打乱List集合的顺序            3、public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)        -- 给List集合进行默认的升序排序。默认只能由小到大。                -- 有值特性的，按照值特性排序。                -- 对于字符串按照首字母的编号排序！                -- 此方法默认不能给引用类型的对象做排序，因为人家不知道你的排序规则！            4、public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c)        -- 参数一：被排序的集合对象。                -- 参数二：比较器对象，用于程序员来定制大小排序规则。</code></pre></li><li><p><input disabled="" type="checkbox">  能够使用Comparator比较器进行排序</p><pre><code class="java">          Student s1 = new Student(&quot;张三丰&quot;,100,&#39;男&#39;);        Student s2 = new Student(&quot;张无忌&quot;,32,&#39;男&#39;);        Student s3 = new Student(&quot;赵敏&quot;,22,&#39;女&#39;);        Student s4 = new Student(&quot;殷素素&quot;,45,&#39;女&#39;);        List&lt;Student&gt; stus = new ArrayList&lt;&gt;();        Collections.addAll(stus ,  s1 , s2 , s3 , s4);        Collections.sort(stus, new Comparator&lt;Student&gt;() &#123;            @Override            public int compare(Student o1, Student o2) &#123;                // Collections集合工具类会自动提取集合中的两两对象送进来让程序员自己来比较。                // o1  s1 = new Student(&quot;张三丰&quot;,100,&#39;男&#39;);                // o2  s2 = new Student(&quot;张无忌&quot;,32,&#39;男&#39;);                // 如果认为 o1 &gt; o2 应该返回正整数                // 如果认为 o1 &lt; o2 应该返回负整数                // 如果认为 o1 = o2 应该返回0//                if(o1.getAge() &gt; o2.getAge())&#123;//                    return  1;//                &#125;else if(o1.getAge() &lt; o2.getAge())&#123;//                    return -1;//                &#125;//                return 0;                return o1.getAge() - o2.getAge();            &#125;        &#125;);</code></pre></li><li><p><input disabled="" type="checkbox">  能够使用可变参数</p><pre><code class="properties">可变参数的作用：    可变参数可以用在方法，构造器等形参中，用于接收多个数据。可变参数的格式：数据类型... 变量名称可变参数在内部本质上就是一个数组！！可变参数的优点：参数传输非常的灵活！！可变参数的注意事项：    1.一个形参列表中只能有一个可变参数。    2.可变参数必须放在形参列表的最后面。</code></pre></li><li><p><input disabled="" type="checkbox">  能够理解冒泡排序的原理</p><pre><code class="properties">冒泡排序的核心点：每次两两比较找出当前最大值冒出到当前最后面即可！！</code></pre></li><li><p><input disabled="" type="checkbox">  能够说出Map集合特点</p><pre><code class="properties">Map集合的特点：    1.Map集合的特点都是由键决定的。    2.Map集合的键是无序,不重复的，无索引的。        Map集合后面重复的键对应的元素会覆盖前面的整个元素的值！    3.Map集合的值无要求。    4.Map集合的键值对都可以为null。</code></pre></li><li><p><input disabled="" type="checkbox">  使用Map集合添加方法保存数据</p><pre><code class="java">maps.put(&quot;iphoneX&quot; , 1);</code></pre></li><li><p><input disabled="" type="checkbox">  使用”键找值”的方式遍历Map集合</p><pre><code class="java">// a.先提取Map集合全部的键到一个Set集合中去// keys = [huawei, Java, iphoneX, 娃娃]Set&lt;String&gt; keys = maps.keySet();System.out.println(keys);// b.再遍历全部键，通过键获取对应的值for(String key : keys)&#123;    // 通过键取对应值    Integer value = maps.get(key);    System.out.println(key+&quot;----&gt;&quot;+value);&#125;</code></pre></li><li><p><input disabled="" type="checkbox">  使用”键值对”的方式遍历Map集合</p><pre><code class="java">/**    maps = &#123;huawei=8, Java=1, iphoneX=1, 娃娃=8&#125;    最开始是想直接用foreach遍历Map集合    发现foreach根本不能直接遍历Map集合，Map集合的键值对元素直接来看是没有类型的。        ↓    可以把Map集合通过如下API转换成一个Set集合。        -- Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()        -- entrySet = [(huawei=8), (Java=1), (iphoneX=1), (娃娃=8)]        --   entry        -- 此时该Set集合中的键值对元素成为一个整体，有了类型，            类型叫键值对实体类型：Map.Entry&lt;String,Integer&gt;        ↓    此时就可以通过foreach遍历entrySet集合了! */ Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = maps.entrySet(); for(Map.Entry&lt;String,Integer&gt; entry : entrySet)&#123;     String key = entry.getKey();     Integer value = entry.getValue();     System.out.println(key+&quot;--&gt;&quot;+value); &#125;</code></pre></li><li><p><input disabled="" type="checkbox">  能够使用HashMap存储自定义键值对的数据</p><pre><code class="java">// 学生对象作为键的类型，值用字符串表示地址信息Map&lt;Student , String&gt; maps = new HashMap&lt;&gt;();maps.put(new Student(&quot;欧世杰&quot;,18,&#39;男&#39;) , &quot;广州&quot;);maps.put(new Student(&quot;林志玲&quot;,41,&#39;女&#39;) , &quot;日本&quot;);maps.put(new Student(&quot;林志玲&quot;,41,&#39;女&#39;) , &quot;日本&quot;);maps.put(new Student(&quot;古天乐&quot;,41,&#39;男&#39;) , &quot;香港&quot;);</code></pre></li><li><p><input disabled="" type="checkbox">  能够理解图书管理系统案例</p><pre><code class="properties">参见代码！</code></pre></li></ul><h1 id="第一章-Map集合"><a href="#第一章-Map集合" class="headerlink" title="第一章 Map集合"></a>第一章 Map集合</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p><p><img src="/img/java/imgs6/Collection%E4%B8%8EMap.bmp"></p><ul><li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul><h2 id="1-2-Map的常用子类"><a href="#1-2-Map的常用子类" class="headerlink" title="1.2  Map的常用子类"></a>1.2  Map的常用子类</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p><ul><li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li><em><em>TreeMap&lt;K,V&gt;<strong>：TreeMap集合和Map相比没有特有的功能，底层的数据结构是红黑树；可以对元素的</strong></em>键</em><strong>进行排序，排序方式有两种:<strong>自然排序</strong>和</strong>比较器排序**</li></ul><blockquote><p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p></blockquote><h2 id="1-3-Map的常用方法"><a href="#1-3-Map的常用方法" class="headerlink" title="1.3  Map的常用方法"></a>1.3  Map的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li><li><code>public boolean containKey(Object key)</code>:判断该集合中是否有此键。</li></ul><p>Map接口的方法演示</p><pre><code class="java">public class MapDemo &#123;    public static void main(String[] args) &#123;        //创建 map对象        HashMap&lt;String, String&gt;  map = new HashMap&lt;String, String&gt;();        //添加元素到集合        map.put(&quot;黄晓明&quot;, &quot;杨颖&quot;);        map.put(&quot;文章&quot;, &quot;马伊琍&quot;);        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);        System.out.println(map);        //String remove(String key)        System.out.println(map.remove(&quot;邓超&quot;));        System.out.println(map);        // 想要查看 黄晓明的媳妇 是谁        System.out.println(map.get(&quot;黄晓明&quot;));        System.out.println(map.get(&quot;邓超&quot;));        &#125;&#125;</code></pre><blockquote><p>tips:</p><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p></blockquote><h2 id="1-4-Map的遍历"><a href="#1-4-Map的遍历" class="headerlink" title="1.4   Map的遍历"></a>1.4   Map的遍历</h2><h3 id="方式1-键找值方式"><a href="#方式1-键找值方式" class="headerlink" title="方式1:键找值方式"></a>方式1:键找值方式</h3><p>通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li></ol><p>遍历图解：</p><p><img src="/img/java/imgs6/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%80.bmp"></p><ul><li></li></ul><h3 id="方式2-键值对方式"><a href="#方式2-键值对方式" class="headerlink" title="方式2:键值对方式"></a>方式2:键值对方式</h3><p>即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p><strong>Entry键值对对象:</strong></p><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p> 获取了Entry对象 , 表示获取了一对键和值，那么同样Entry中 , 分别提供了获取键和获取值的方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>操作步骤与图解：</p><ol><li>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</li><li>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</li><li>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </li></ol><p>遍历图解：</p><p><img src="../../../%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%E8%AF%BE%E6%94%B9/day01-day15%E8%AE%B2%E4%B9%89-MD/day06-Collections,Set,Map,%E6%96%97%E5%9C%B0%E4%B8%BB%E6%8E%92%E5%BA%8F/img/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%BA%8C.bmp"></p><blockquote><p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p></blockquote><h2 id="1-5-HashMap存储自定义类型"><a href="#1-5-HashMap存储自定义类型" class="headerlink" title="1.5  HashMap存储自定义类型"></a>1.5  HashMap存储自定义类型</h2><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p><blockquote><p>注意，学生姓名相同并且年龄相同视为同一名学生。</p></blockquote><p>编写学生类：</p><pre><code class="java">public class Student &#123;    private String name;    private int age;    //构造方法    //get/set    @Override    public boolean equals(Object o) &#123;        if (this == o)            return true;        if (o == null || getClass() != o.getClass())            return false;        Student student = (Student) o;        return age == student.age &amp;&amp; Objects.equals(name, student.name);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(name, age);    &#125;&#125;</code></pre><p>编写测试类：</p><pre><code class="java">public class HashMapTest &#123;    public static void main(String[] args) &#123;        //1,创建Hashmap集合对象。        Map&lt;Student,String&gt; map = new HashMap&lt;Student,String&gt;();        //2,添加元素。        map.put(new Student(&quot;lisi&quot;,28), &quot;上海&quot;);        map.put(new Student(&quot;wangwu&quot;,22), &quot;北京&quot;);        map.put(new Student(&quot;wangwu&quot;,22), &quot;南京&quot;);                //3,取出元素。键找值方式        Set&lt;Student&gt; keySet = map.keySet();        for(Student key: keySet)&#123;            String value = map.get(key);            System.out.println(key.toString()+&quot;.....&quot;+value);        &#125;    &#125;&#125;</code></pre><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li></ul><h2 id="1-6-LinkedHashMap介绍"><a href="#1-6-LinkedHashMap介绍" class="headerlink" title="1.6   LinkedHashMap介绍"></a>1.6   LinkedHashMap介绍</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p><p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p><pre><code class="java">public class LinkedHashMapDemo &#123;    public static void main(String[] args) &#123;        LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;();        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);        map.put(&quot;李晨&quot;, &quot;范冰冰&quot;);        map.put(&quot;刘德华&quot;, &quot;朱丽倩&quot;);        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();        for (Entry&lt;String, String&gt; entry : entrySet) &#123;            System.out.println(entry.getKey() + &quot;  &quot; + entry.getValue());        &#125;    &#125;&#125;</code></pre><p>结果:</p><pre><code>邓超  孙俪李晨  范冰冰刘德华  朱丽倩</code></pre><h2 id="1-7-TreeMap集合"><a href="#1-7-TreeMap集合" class="headerlink" title="1.7 TreeMap集合"></a>1.7 TreeMap集合</h2><h3 id="1-TreeMap介绍"><a href="#1-TreeMap介绍" class="headerlink" title="1.TreeMap介绍"></a>1.TreeMap介绍</h3><p>TreeMap集合和Map相比没有特有的功能，底层的数据结构是红黑树；可以对元素的<em><strong>键</strong></em>进行排序，排序方式有两种:<strong>自然排序</strong>和<strong>比较器排序</strong>；到时使用的是哪种排序，取决于我们在创建对象的时候所使用的构造方法；</p><pre><code class="java">public TreeMap()                                    使用自然排序public TreeMap(Comparator&lt;? super K&gt; comparator)     比较器排</code></pre><h3 id="2-演示"><a href="#2-演示" class="headerlink" title="2.演示"></a>2.演示</h3><p>案例演示<strong>自然排序</strong></p><pre><code class="java">public static void main(String[] args) &#123;     TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();      map.put(1,&quot;张三&quot;);      map.put(4,&quot;赵六&quot;);      map.put(3,&quot;王五&quot;);      map.put(6,&quot;酒八&quot;);      map.put(5,&quot;老七&quot;);      map.put(2,&quot;李四&quot;);      System.out.println(map);&#125;控制台的输出结果为:&#123;1=张三, 2=李四, 3=王五, 4=赵六, 5=老七, 6=酒八&#125;</code></pre><p>案例演示<strong>比较器排序</strong></p><p><strong>需求:</strong></p><ol><li>创建一个TreeMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。</li><li>要求按照学生的年龄进行升序排序，如果年龄相同，比较姓名的首字母升序， 如果年龄和姓名都是相同，认为是同一个元素；</li></ol><p> <strong>实现:</strong></p><p>为了保证age和name相同的对象是同一个,Student类必须重写hashCode和equals方法</p><pre><code class="java">public class Student &#123;    private int age;    private String name;    //省略get/set..    public Student() &#123;&#125;    public Student(int age, String name) &#123;        this.age = age;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;age=&quot; + age +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Student student = (Student) o;        return age == student.age &amp;&amp;                Objects.equals(name, student.name);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(age, name);    &#125;&#125;</code></pre><pre><code class="java">public static void main(String[] args) &#123;      TreeMap&lt;Student, String&gt; map = new TreeMap&lt;Student, String&gt;(new Comparator&lt;Student&gt;() &#123;        @Override        public int compare(Student o1, Student o2) &#123;              //先按照年龄升序              int result = o1.getAge() - o2.getAge();              if (result == 0) &#123;                //年龄相同,则按照名字的首字母升序                return o1.getName().charAt(0) - o2.getName().charAt(0);              &#125; else &#123;                //年龄不同,直接返回结果                return result;              &#125;        &#125;      &#125;);      map.put(new Student(30, &quot;jack&quot;), &quot;深圳&quot;);      map.put(new Student(10, &quot;rose&quot;), &quot;北京&quot;);      map.put(new Student(20, &quot;tom&quot;), &quot;上海&quot;);      map.put(new Student(10, &quot;marry&quot;), &quot;南京&quot;);      map.put(new Student(30, &quot;lucy&quot;), &quot;广州&quot;);      System.out.println(map);&#125;控制台的输出结果为:&#123;  Student&#123;age=10, name=&#39;marry&#39;&#125;=南京,   Student&#123;age=10, name=&#39;rose&#39;&#125;=北京,   Student&#123;age=20, name=&#39;tom&#39;&#125;=上海,   Student&#123;age=30, name=&#39;jack&#39;&#125;=深圳,   Student&#123;age=30, name=&#39;lucy&#39;&#125;=广州&#125;</code></pre><h2 id="1-8-Map集合练习"><a href="#1-8-Map集合练习" class="headerlink" title="1.8 Map集合练习"></a>1.8 Map集合练习</h2><p><strong>需求：</strong></p><p>输入一个字符串中每个字符出现次数。</p><p><strong>分析：</strong></p><ol><li>获取一个字符串对象</li><li>创建一个Map集合，键代表字符，值代表次数。</li><li>遍历字符串得到每个字符。</li><li>判断Map中是否有该键。</li><li>如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li><li>打印最终结果</li></ol><p><strong>方法介绍</strong></p><p><code>public boolean containKey(Object key)</code>:判断该集合中是否有此键。</p><p><strong>代码：</strong></p><pre><code class="java">public class MapTest &#123;public static void main(String[] args) &#123;        //友情提示        System.out.println(&quot;请录入一个字符串:&quot;);        String line = new Scanner(System.in).nextLine();        // 定义 每个字符出现次数的方法        findChar(line);    &#125;    private static void findChar(String line) &#123;        //1:创建一个集合 存储  字符 以及其出现的次数        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();        //2:遍历字符串        for (int i = 0; i &lt; line.length(); i++) &#123;            char c = line.charAt(i);            //判断 该字符 是否在键集中            if (!map.containsKey(c)) &#123;//说明这个字符没有出现过                //那就是第一次                map.put(c, 1);            &#125; else &#123;                //先获取之前的次数                Integer count = map.get(c);                //count++;                //再次存入  更新                map.put(c, ++count);            &#125;        &#125;        System.out.println(map);    &#125;&#125;</code></pre><h1 id="第二章-模拟斗地主洗牌发牌"><a href="#第二章-模拟斗地主洗牌发牌" class="headerlink" title="第二章  模拟斗地主洗牌发牌"></a>第二章  模拟斗地主洗牌发牌</h1><h2 id="2-1-案例介绍"><a href="#2-1-案例介绍" class="headerlink" title="2.1 案例介绍"></a>2.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。</p><p><img src="/img/java/imgs6/%E6%96%97%E5%9C%B0%E4%B8%BB.png"></p><p>具体规则：</p><ol><li>组装54张扑克牌</li><li>54张牌顺序打乱</li><li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li><li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li></ol><blockquote><p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p></blockquote><h2 id="2-2-案例需求分析"><a href="#2-2-案例需求分析" class="headerlink" title="2.2 案例需求分析"></a>2.2 案例需求分析</h2><p>1.准备牌：</p><p>完成数字与纸牌的映射关系：</p><p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p><p>2.洗牌：</p><p>通过数字完成洗牌发牌</p><p>3.发牌：</p><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p><p>存放的过程中要求数字大小与斗地主规则的大小对应。</p><p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p><p>4.看牌：</p><p>通过Map集合找到对应字符展示。</p><p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p><p><img src="img/%E6%96%97%E5%9C%B0%E4%B8%BB%E5%88%86%E6%9E%90.png"></p><h2 id="2-3-实现代码步骤"><a href="#2-3-实现代码步骤" class="headerlink" title="2.3  实现代码步骤"></a>2.3  实现代码步骤</h2><pre><code class="java">package com.itheima04;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;/* * 组合牌 *       定义一个Map集合用来存储牌号  和 牌  *       定义一个List集合用来存储牌号 *      花色:♥-♠-♦-♣ *      数字:2-A-K-Q-J-10-9-8-7-6-5-4-3 * 洗牌 *         Collections.shuffle(牌号集合) * 发牌 *         三个玩家三个集合 *         发牌号  * 排序 * 看牌 */public class Pooker &#123;    public static void main(String[] args) &#123;        // 定义一个Map集合用来存储牌号  和 牌         Map&lt;Integer, String&gt; pookerMap = new HashMap&lt;Integer, String&gt;();        //定义一个List集合用来存储牌号        ArrayList&lt;Integer&gt; pookerList = new ArrayList&lt;Integer&gt;();                String[] colors = &quot;♥-♠-♦-♣&quot;.split(&quot;-&quot;);        String[] nums = &quot;2-A-K-Q-J-10-9-8-7-6-5-4-3&quot;.split(&quot;-&quot;);                        int index = 2;        for(String num : nums)&#123;            for(String color : colors)&#123;                String thisPooker = color+num;//                System.out.println(thisPooker);                //将扑克牌放入Map集合                pookerMap.put(index, thisPooker);                //将牌号放入到pookerList集合中                pookerList.add(index);                index++;            &#125;        &#125;                        //将大王小王添加到集合        pookerMap.put(0, &quot;大王&quot;);        pookerMap.put(1, &quot;小王&quot;);        pookerList.add(0);        pookerList.add(1);        //        System.out.println(pookerMap);//        System.out.println(pookerList);                //洗牌        Collections.shuffle(pookerList);                //发牌        ArrayList&lt;Integer&gt; player1 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; player2 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; player3 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; diPai = new ArrayList&lt;Integer&gt;();                //遍历牌号的集合 判断索引发牌号        for(int i = 0 ;i &lt; pookerList.size() ;i++)&#123;            Integer pookerNum = pookerList.get(i);                        if(i&gt;=51)&#123;                diPai.add(pookerNum);            &#125;else if(i % 3 == 0)&#123;                player1.add(pookerNum);            &#125;else if(i % 3 == 1)&#123;                player2.add(pookerNum);            &#125;else if(i % 3 == 2)&#123;                player3.add(pookerNum);            &#125;        &#125;                //        排序                Collections.sort(player1);        Collections.sort(player2);        Collections.sort(player3);        Collections.sort(diPai);//        System.out.println(player1);//        System.out.println(player2);//        System.out.println(player3);//        System.out.println(diPai);                show(&quot;张三&quot;,player1,pookerMap);        show(&quot;李四&quot;,player2,pookerMap);        show(&quot;王五&quot;,player3,pookerMap);        show(&quot;底牌&quot;,diPai,pookerMap);            &#125;    //定义方法 看牌    public static void show(String name,ArrayList&lt;Integer&gt; player,HashMap&lt;Integer, String&gt; pookerMap )&#123;        System.out.print(name+&quot;:&quot;);        for(Integer pookerNum : player)&#123;            String thisPooker = pookerMap.get(pookerNum);            System.out.print(thisPooker+&quot; &quot;);        &#125;        System.out.println();    &#125;&#125;</code></pre><h1 id="第三章-图书管理系统"><a href="#第三章-图书管理系统" class="headerlink" title="第三章 图书管理系统"></a>第三章 图书管理系统</h1><h2 id="3-1-图书管理系统项目演示"><a href="#3-1-图书管理系统项目演示" class="headerlink" title="3.1 图书管理系统项目演示"></a>3.1 图书管理系统项目演示</h2><p><img src="/img/java/imgs6/1543580142920.png" alt="1543580142920"></p><p><img src="/img/java/imgs6/1543580255773.png" alt="1543580255773"></p><p><img src="/img/java/imgs6/1543580374974.png" alt="1543580374974"></p><p><img src="/img/java/imgs6/1543580413991.png" alt="1543580413991"></p><p><img src="/img/java/imgs6/1543580469034.png" alt="1543580469034"></p><p><img src="/img/java/imgs6/1543580482970.png" alt="1543580482970"></p><p><strong>图书管理系统分析:</strong><br>1.定义Book类<br>2.完成主界面和选择<br>3.完成查询所有图书<br>4.完成添加图书<br>5.完成删除图书<br>6.完成修改图书<br>7.使用Debug追踪调试</p><h2 id="3-2-图书管理系统之标准Book类"><a href="#3-2-图书管理系统之标准Book类" class="headerlink" title="3.2 图书管理系统之标准Book类"></a>3.2 图书管理系统之标准Book类</h2><p><img src="/img/java/imgs6/1543582871305.png" alt="1543582871305"></p><p>我们发现每一本书都有书名和价格,定义一个Book类表示书籍</p><pre><code class="java">public class Book &#123;    private String name;    private double price;    public Book() &#123;    &#125;    public Book(String name, double price) &#123;        this.name = name;        this.price = price;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public double getPrice() &#123;        return price;    &#125;    public void setPrice(double price) &#123;        this.price = price;    &#125;&#125;</code></pre><h2 id="3-3-图书管理系统之主界面和选择的实现"><a href="#3-3-图书管理系统之主界面和选择的实现" class="headerlink" title="3.3 图书管理系统之主界面和选择的实现"></a>3.3 图书管理系统之主界面和选择的实现</h2><p><img src="/img/java/imgs6/1543580142920.png" alt="1543580142920"></p><p>主界面的内容其实就是通过打印语句打印出来的.但是要注意因为每个操作过后都会重新回到主界面,所以使用<code>while(true)</code>死循环的方式.</p><pre><code class="java">public class BookManager &#123;    public static void main(String[] args) &#123;        while (true) &#123;            //这是学生管理系统的主界面            System.out.println(&quot;--------欢迎来到学生管理系统--------&quot;);            System.out.println(&quot;1.查看所有书籍&quot;);            System.out.println(&quot;2.添加书&quot;);            System.out.println(&quot;3.删除书&quot;);            System.out.println(&quot;4.修改书&quot;);            System.out.println(&quot;5.退出&quot;);            System.out.println(&quot;请输入你的选择：&quot;);            //创建键盘录入对象            Scanner sc = new Scanner(System.in);            int num = sc.nextInt();            switch (num) &#123;                case 1:                    // 查看所有书籍                    break;                case 2:                    // 添加书籍                    break;                case 3:                    // 删除书                    break;                case 4:                    // 修改书                    break;                case 5:                    // 退出                    break;                default:                    System.out.println(&quot;输入错误,请重新输入&quot;);                    break;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="3-4-图书管理系统之查询所有图书"><a href="#3-4-图书管理系统之查询所有图书" class="headerlink" title="3.4 图书管理系统之查询所有图书"></a>3.4 图书管理系统之查询所有图书</h2><p><img src="/img/java/imgs6/1543582871305.png" alt="1543582871305"></p><pre><code class="java">public class BookManager &#123;    public static void main(String[] args) &#123;        Map&lt;String, ArrayList&lt;Book&gt;&gt; map = new HashMap&lt;&gt;();        // 创建集合对象，用于存储学生数据        ArrayList&lt;Book&gt; it = new ArrayList&lt;Book&gt;();        it.add(new Book(&quot;Java入门到精通&quot;, 99));        it.add(new Book(&quot;PHP入门到精通&quot;, 9.9));        map.put(&quot;it书籍&quot;, it);        ArrayList&lt;Book&gt; mz = new ArrayList&lt;Book&gt;();        mz.add(new Book(&quot;西游记&quot;, 19));        mz.add(new Book(&quot;水浒传&quot;, 29));        map.put(&quot;名著&quot;, mz);        while (true) &#123;            //这是学生管理系统的主界面            System.out.println(&quot;--------欢迎来到学生管理系统--------&quot;);            System.out.println(&quot;1.查看所有书籍&quot;);            System.out.println(&quot;2.添加书&quot;);            System.out.println(&quot;3.删除书&quot;);            System.out.println(&quot;4.修改书&quot;);            System.out.println(&quot;5.退出&quot;);            System.out.println(&quot;请输入你的选择：&quot;);            //创建键盘录入对象            Scanner sc = new Scanner(System.in);            int num = sc.nextInt();            switch (num) &#123;                case 1:                    // 查看所有书籍                    findAllBook(map);                    break;                case 2:                    // 添加书籍                    break;                case 3:                    // 删除书                    break;                case 4:                    // 修改书                    break;                case 5:                    // 退出                    System.out.println(&quot;谢谢你的使用&quot;);                    System.exit(0); // JVM退出                    break;                default:                    System.out.println(&quot;输入错误,请重新输入&quot;);                    break;            &#125;        &#125;    &#125;        private static void findAllBook(Map&lt;String, ArrayList&lt;Book&gt;&gt; map) &#123;        System.out.println(&quot;类型\t\t书名\t价格&quot;);        Set&lt;Map.Entry&lt;String, ArrayList&lt;Book&gt;&gt;&gt; entries = map.entrySet();        for (Map.Entry&lt;String, ArrayList&lt;Book&gt;&gt; entry : entries) &#123;            String key = entry.getKey();            System.out.println(key);            ArrayList&lt;Book&gt; value = entry.getValue();            for (Book book : value) &#123;                System.out.println(&quot;\t\t&quot; + book.getName() + &quot;\t&quot; + book.getPrice());            &#125;        &#125;    &#125;&#125;    </code></pre><h2 id="3-5-图书管理系统之添加图书"><a href="#3-5-图书管理系统之添加图书" class="headerlink" title="3.5 图书管理系统之添加图书"></a>3.5 图书管理系统之添加图书</h2><p><img src="/img/java/imgs6/1543580374974.png" alt="1543580374974"></p><pre><code class="java">private static void addBook(Map&lt;String, ArrayList&lt;Book&gt;&gt; map) &#123;    // 创建键盘录入对象    Scanner sc = new Scanner(System.in);    System.out.println(&quot;请输入要添加书籍的类型:&quot;);    String type = sc.next();    System.out.println(&quot;请输入要添加的书名:&quot;);    String name = sc.next();    System.out.println(&quot;请输入要添加书的价格:&quot;);    double price = sc.nextDouble();    Book book = new Book(name, price);    // 拿到书籍列表    ArrayList&lt;Book&gt; books = map.get(type);    if (books == null) &#123;        // 如果书籍列表不存在创建一个书籍列表        books = new ArrayList&lt;&gt;();        map.put(type, books);    &#125;    // 将书添加到集合中    books.add(book);    System.out.println(&quot;添加&quot; + name + &quot;成功&quot;);&#125;</code></pre><h2 id="3-6-图书管理系统之删除图书"><a href="#3-6-图书管理系统之删除图书" class="headerlink" title="3.6 图书管理系统之删除图书"></a>3.6 图书管理系统之删除图书</h2><p><img src="/img/java/imgs6/1543580413991.png" alt="1543580413991"></p><pre><code class="java">private static void deleteBook(Map&lt;String, ArrayList&lt;Book&gt;&gt; map) &#123;    // 创建键盘录入对象    Scanner sc = new Scanner(System.in);    System.out.println(&quot;请输入要删除书籍的类型:&quot;);    String type = sc.next();    System.out.println(&quot;请输入要删除的书名:&quot;);    String name = sc.next();    // 拿到书籍列表  ： 用Map集合的    ArrayList&lt;Book&gt; books = map.get(type);    if (books == null) &#123;        System.out.println(&quot;您删除的书籍类型不存在&quot;);        return;    &#125;    for (int i = 0; i &lt; books.size(); i++) &#123;        Book book = books.get(i);        if (book.getName().equals(name)) &#123;            books.remove(i); // 找到这本书,删除这本书            System.out.println(&quot;删除&quot; + name + &quot;书籍成功&quot;);            return; // 删除书籍后结束方法        &#125;    &#125;    System.out.println(&quot;没有找到&quot; + name + &quot;书籍&quot;);&#125;</code></pre><h2 id="3-7-图书管理系统之修改图书"><a href="#3-7-图书管理系统之修改图书" class="headerlink" title="3.7 图书管理系统之修改图书"></a>3.7 图书管理系统之修改图书</h2><p><img src="/img/java/imgs6/1543580469034.png" alt="1543580469034"></p><pre><code class="java">private static void editBook(Map&lt;String, ArrayList&lt;Book&gt;&gt; map) &#123;    // 创建键盘录入对象    Scanner sc = new Scanner(System.in);    System.out.println(&quot;请输入要修改书籍的类型:&quot;);    String type = sc.next();    System.out.println(&quot;请输入要修改的书名:&quot;);    String oldName = sc.next();    System.out.println(&quot;请输入新的书名:&quot;);    String newName = sc.next();    System.out.println(&quot;请输入新的价格:&quot;);    double price = sc.nextDouble();    // 拿到书籍列表    ArrayList&lt;Book&gt; books = map.get(type); // 根本不不像一个技术人员    if (books == null) &#123;        System.out.println(&quot;您修改的书籍类型不存在&quot;);        return;    &#125;    for (int i = 0; i &lt; books.size(); i++) &#123;        Book book = books.get(i);        if (book.getName().equals(oldName)) &#123;            // 找到这本书,修改这本书            book.setName(newName);            book.setPrice(price);            System.out.println(&quot;修改成功&quot;);            return; // 修改书籍后结束方法        &#125;    &#125;    System.out.println(&quot;没有找到&quot; + oldName + &quot;书籍&quot;);&#125;</code></pre><h2 id="3-8-Debug追踪调试"><a href="#3-8-Debug追踪调试" class="headerlink" title="3.8 Debug追踪调试"></a>3.8 Debug追踪调试</h2><p>之前我们看程序的执行流程都是通过<code>System.out.println();</code>但是有不能让程序执行到某条语句后<strong>停下来</strong>,也不能看到程序<strong>具体的执行步骤</strong>.而是执行完所有的语句程序结束了。</p><p><strong>断点调试可以查看程序的执行流程和暂停程序.可以快速解决程序中的bug</strong></p><p>Debug调试窗口介绍</p><p><img src="/img/java/imgs6%5Cdebug5.png"></p><h1 id="第四章-排序算法介绍"><a href="#第四章-排序算法介绍" class="headerlink" title="第四章 排序算法介绍"></a>第四章 排序算法介绍</h1><h2 id="4-1-冒泡排序"><a href="#4-1-冒泡排序" class="headerlink" title="4.1 冒泡排序"></a>4.1 冒泡排序</h2><h3 id="4-1-1-冒泡排序概述"><a href="#4-1-1-冒泡排序概述" class="headerlink" title="4.1.1 冒泡排序概述"></a>4.1.1 冒泡排序概述</h3><ul><li>一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序</li><li>如果有n个数据进行排序，总共需要比较n-1次</li><li>每一次比较完毕，下一次的比较就会少一个数据参与</li></ul><h3 id="4-1-2-冒泡排序图解"><a href="#4-1-2-冒泡排序图解" class="headerlink" title="4.1.2 冒泡排序图解"></a>4.1.2 冒泡排序图解</h3><p><img src="../../../../%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%E8%AF%BE%E6%94%B9/day01-day15%E8%AE%B2%E4%B9%89-MD/day07-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95,%E5%BC%82%E5%B8%B8,%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img/5.png" alt="5"></p><h3 id="4-1-3-冒泡排序代码实现"><a href="#4-1-3-冒泡排序代码实现" class="headerlink" title="4.1.3 冒泡排序代码实现"></a>4.1.3 冒泡排序代码实现</h3><pre><code class="java">/*    冒泡排序：        一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，        依次对所有的数据进行操作，直至所有数据按要求完成排序 */public class ArrayDemo &#123;    public static void main(String[] args) &#123;        //定义一个数组        int[] arr = &#123;7, 6, 5, 4, 3&#125;;        System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));        // 这里减1，是控制每轮比较的次数        for (int x = 0; x &lt; arr.length - 1; x++) &#123;            // -1是为了避免索引越界，-x是为了调高比较效率            for (int i = 0; i &lt; arr.length - 1 - x; i++) &#123;                if (arr[i] &gt; arr[i + 1]) &#123;                    int temp = arr[i];                    arr[i] = arr[i + 1];                    arr[i + 1] = temp;                &#125;            &#125;        &#125;        System.out.println(&quot;排序后：&quot; + Arrays.toString(arr));    &#125;&#125;</code></pre><h2 id="4-2-选择排序"><a href="#4-2-选择排序" class="headerlink" title="4.2 选择排序"></a>4.2 选择排序</h2><h3 id="4-2-1-选择排序概述"><a href="#4-2-1-选择排序概述" class="headerlink" title="4.2.1 选择排序概述"></a>4.2.1 选择排序概述</h3><ul><li>另外一种排序的方式，选中数组的某个元素,其后面的元素依次和选中的元素进行两两比较，将较大的数据放在后面，依次从前到后选中每个元素，直至所有数据按要求完成排序</li><li>如果有n个数据进行排序，总共需要比较n-1次</li><li>每一次比较完毕，下一次的比较就会少一个数据参与</li></ul><h3 id="4-2-2-选择排序图解"><a href="#4-2-2-选择排序图解" class="headerlink" title="4.2.2 选择排序图解"></a>4.2.2 选择排序图解</h3><p><img src="../../../../%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%E8%AF%BE%E6%94%B9/day01-day15%E8%AE%B2%E4%B9%89-MD/day07-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95,%E5%BC%82%E5%B8%B8,%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img/6.png" alt="5"></p><h3 id="4-2-3-选择排序代码实现"><a href="#4-2-3-选择排序代码实现" class="headerlink" title="4.2.3 选择排序代码实现"></a>4.2.3 选择排序代码实现</h3><pre><code class="java">/*    选择排序：        另外一种排序的方式，选中数组的某个元素,其后面的元素依次和选中的元素进行两两比较，将较大的数据放在后面，依次从前到后选中每个元素，直至所有数据按要求完成排序 */public class ArrayDemo &#123;    public static void main(String[] args) &#123;        //定义一个数组        int[] arr = &#123;7, 6, 5, 4, 3&#125;;        System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));          // 这里减1，是控制比较的轮数        for (int x = 0; x &lt; arr.length; x++) &#123;            // 从x+1开始,直到最后一个元素            for (int i = x+1; i &lt; arr.length; i++) &#123;                if (arr[x] &gt; arr[i]) &#123;                    int temp = arr[x];                    arr[x] = arr[i];                    arr[i] = temp;                &#125;            &#125;        &#125;        System.out.println(&quot;排序后：&quot; + Arrays.toString(arr));    &#125;&#125;</code></pre><h1 id="第五章-二分查找"><a href="#第五章-二分查找" class="headerlink" title="第五章 二分查找"></a>第五章 二分查找</h1><h2 id="5-1-普通查找和二分查找"><a href="#5-1-普通查找和二分查找" class="headerlink" title="5.1 普通查找和二分查找"></a>5.1 普通查找和二分查找</h2><p><strong>普通查找</strong></p><p>原理：遍历数组，获取每一个元素，然后判断当前遍历的元素是否和要查找的元素相同，如果相同就返回该元素的索引。如果没有找到，就返回一个负数作为标识(一般是-1)</p><p><strong>二分查找</strong></p><p>原理: 每一次都去获取数组的中间索引所对应的元素，然后和要查找的元素进行比对，如果相同就返回索引；</p><p>如果不相同，就比较中间元素和要查找的元素的值；</p><p>如果中间元素的值大于要查找的元素，说明要查找的元素在左侧，那么就从左侧按照上述思想继续查询(忽略右侧数据)；</p><p>如果中间元素的值小于要查找的元素，说明要查找的元素在右侧，那么就从右侧按照上述思想继续查询(忽略左侧数据)；</p><p><strong>二分查找对数组是有要求的,数组必须已经排好序</strong></p><h2 id="5-2-二分查找图解"><a href="#5-2-二分查找图解" class="headerlink" title="5.2 二分查找图解"></a>5.2 二分查找图解</h2><p>假设有一个给定有序数组(10,14,21,38,45,47,53,81,87,99),要查找50出现的索引</p><p>则查询过程如下图所示:</p><p><img src="../../../../%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%E8%AF%BE%E6%94%B9/day01-day15%E8%AE%B2%E4%B9%89-MD/day07-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95,%E5%BC%82%E5%B8%B8,%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img/7.png" alt="5"></p><h2 id="5-3-二分查找代码实现"><a href="#5-3-二分查找代码实现" class="headerlink" title="5.3 二分查找代码实现"></a>5.3 二分查找代码实现</h2><pre><code class="java">    public static void main(String[] args) &#123;        int[] arr = &#123;10, 14, 21, 38, 45, 47, 53, 81, 87, 99&#125;;        int index = binarySerach(arr, 38);        System.out.println(index);    &#125;    /**     * 二分查找方法     * @param arr 查找的目标数组     * @param number 查找的目标值     * @return 找到的索引,如果没有找到返回-1     */    public static int binarySerach(int[] arr, int number) &#123;        int start = 0;        int end = arr.length - 1;        while (start &lt;= end) &#123;            int mid = (start + end) / 2;            if (number == arr[mid]) &#123;                return mid + 1;            &#125; else if (number &lt; arr[mid]) &#123;                end = mid - 1;            &#125; else if (number &gt; arr[mid]) &#123;                start = mid + 1;            &#125;        &#125;        return -1;  //如果数组中有这个元素，则返回    &#125;</code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day06【Map】&quot;&gt;&lt;a href=&quot;#day06【Map】&quot; class=&quot;headerlink&quot; title=&quot;day06【Map】&quot;&gt;&lt;/a&gt;day06【Map】&lt;/h1&gt;&lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;head</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java进阶13天资料" scheme="http://example.com/tags/java%E8%BF%9B%E9%98%B613%E5%A4%A9%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Day05</title>
    <link href="http://example.com/2021/09/05/JAVA/day05-%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84,List,Set%20,TreeSet%E9%9B%86%E5%90%88,Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://example.com/2021/09/05/JAVA/day05-%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84,List,Set%20,TreeSet%E9%9B%86%E5%90%88,Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2021-09-05T02:34:46.000Z</published>
    <updated>2021-09-05T03:04:37.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day05【迭代器，数据结构-List-Set-TreeSet集合-Collections工具类】"><a href="#day05【迭代器，数据结构-List-Set-TreeSet集合-Collections工具类】" class="headerlink" title="day05【迭代器，数据结构,List,Set ,TreeSet集合,Collections工具类】"></a>day05【迭代器，数据结构,List,Set ,TreeSet集合,Collections工具类】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>Collection集合的遍历方式:</li></ul><ul><li>迭代器。<ul><li>foreach(增强for循环)</li><li>JDK 1.8开始的新技术Lambda表达式。</li></ul></li></ul><ul><li>数据结构<ul><li>是集合的底层，研究数据结构是为了选择使用某种集合。</li></ul></li><li>List接口<ul><li>元素是有序可重复有索引的。</li></ul></li><li>Set接口<ul><li>元素是无序不重复无索引的。</li></ul></li><li>Collections是操作集合的工具类。</li><li>把学的集合用起来：斗地主的游戏。</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><p><input disabled="" type="checkbox">  能够使用迭代器对集合进行取元素</p><ul><li><input disabled="" type="checkbox"> <pre><code class="java">Iterator&lt;String&gt; it = names.iterator();while(it.hasNext())&#123;    String rs = it.next();    System.out.println(rs);&#125;</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  能够说出List集合特点</p><ul><li><input disabled="" type="checkbox"> <strong>元素是有序，可重复的，有索引的，底层是基于数组存储元素的，查询快，增删慢！</strong></li></ul></li><li><p><input disabled="" type="checkbox">  能够说出常见的数据结构</p><ul><li><input disabled="" type="checkbox"> <strong>队列： 先进先出</strong></li><li><input disabled="" type="checkbox"> <strong>栈：先进后出，后进先出</strong></li><li><input disabled="" type="checkbox"> 数组：底层是连续内存区域，查询快，增删慢！</li><li><input disabled="" type="checkbox"> <strong>链表：元素是游离存储的，查询慢，首尾操作快！</strong></li><li><input disabled="" type="checkbox"> 红黑树 （HastSet ）：增删改查都很好，可以排序，可以提高检索数据的性能！</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出数组结构特点</p><ul><li><input disabled="" type="checkbox"> <strong>内存中的连续区域，每个区间大小固定，查询快，增删慢!</strong></li></ul></li><li><p><input disabled="" type="checkbox">  能够说出栈结构特点</p><ul><li><input disabled="" type="checkbox"> 先进后出。</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出队列结构特点</p><ul><li><input disabled="" type="checkbox"> 先进先出</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出单向链表结构特点</p><ul><li><input disabled="" type="checkbox"> 元素是游离存储的，查询慢, 一端的增删操作快！</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出Set集合的特点</p><ul><li><input disabled="" type="checkbox"> 元素是无序，不重复，无索引，底层是基于哈希表存储元素的，曾删查的性能都很好！！</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出哈希表的特点</p><ul><li><input disabled="" type="checkbox"> JDK 1.8之前是：链表+数组</li><li><input disabled="" type="checkbox"> JDK 1.8之后是：链表+数组+红黑树</li></ul></li><li><p><input disabled="" type="checkbox">  使用HashSet集合存储自定义元素</p><ul><li><input disabled="" type="checkbox"> Set<Apple> sets = new HashSet&lt;&gt;();</li></ul></li></ul><h1 id="第一章-Iterator迭代器"><a href="#第一章-Iterator迭代器" class="headerlink" title="第一章 Iterator迭代器"></a>第一章 Iterator迭代器</h1><h2 id="1-1-Iterator接口"><a href="#1-1-Iterator接口" class="headerlink" title="1.1 Iterator接口"></a>1.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>下面介绍一下迭代的概念：</p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p><pre><code class="java">public class IteratorDemo &#123;      public static void main(String[] args) &#123;        // 使用多态方式 创建对象        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();        // 添加元素到集合        coll.add(&quot;串串星人&quot;);        coll.add(&quot;吐槽星人&quot;);        coll.add(&quot;汪星人&quot;);        //遍历        //使用迭代器 遍历   每个集合对象都有自己的迭代器        Iterator&lt;String&gt; it = coll.iterator();        //  泛型指的是 迭代出 元素的数据类型        while(it.hasNext())&#123; //判断是否有迭代元素            String s = it.next();//获取迭代出的元素            System.out.println(s);        &#125;      &#125;&#125;</code></pre><blockquote><p>tips: </p><ol><li>在进行集合元素获取时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会抛出java.util.NoSuchElementException没有集合元素异常。</li><li>在进行集合元素获取时，如果添加或移除集合中的元素 , 将无法继续迭代 , 将会抛出ConcurrentModificationException并发修改异常.</li></ol></blockquote><h2 id="1-2-迭代器的实现原理"><a href="#1-2-迭代器的实现原理" class="headerlink" title="1.2 迭代器的实现原理"></a>1.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p><p><img src="/img/java/imgs5%5C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.bmp"></p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h1 id="第二章-数据结构"><a href="#第二章-数据结构" class="headerlink" title="第二章 数据结构"></a>第二章 数据结构</h1><h2 id="2-1-数据结构介绍"><a href="#2-1-数据结构介绍" class="headerlink" title="2.1 数据结构介绍"></a>2.1 数据结构介绍</h2><p>数据结构 : 数据用什么样的方式组合在一起。</p><h2 id="2-2-常见数据结构"><a href="#2-2-常见数据结构" class="headerlink" title="2.2 常见数据结构"></a>2.2 常见数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li></ul><p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p><ul><li>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</li><li>栈的入口、出口的都是栈的顶端位置。</li></ul><p>这里两个名词需要注意：</p><ul><li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li><li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li></ul><p><img src="img/%E9%98%9F%E5%88%97.png"></p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li></ul><p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p><p><img src="img/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png"></p></li><li><p>增删元素慢</p></li><li><p><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图<img src="img/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0.png"></p></li><li><p><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图<img src="img/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4.png"></p></li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p><p><img src="img/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png"></p></li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p></li><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p></li><li><p>增删元素快：</p><p><img src="img/%E9%93%BE%E8%A1%A8.png">树数据结构</p><p>树是有很多节点组成的</p></li></ul><h2 id="2-3-树基本结构介绍"><a href="#2-3-树基本结构介绍" class="headerlink" title="2.3. 树基本结构介绍"></a>2.3. 树基本结构介绍</h2><p>树具有的特点：</p><ol><li>每一个节点有零个或者多个子节点</li><li>没有父节点的节点称之为根节点，<strong>一个树最多有一个根节点。</strong></li><li>每一个非根节点有且只有一个父节点</li></ol><p><img src="img/1562637870270.png" alt="1562637870270"> </p><table><thead><tr><th>名词</th><th>含义</th></tr></thead><tbody><tr><td>节点</td><td>指树中的一个元素</td></tr><tr><td>节点的度</td><td>节点拥有的子树的个数，二叉树的度不大于2</td></tr><tr><td>叶子节点</td><td>度为0的节点，也称之为终端结点</td></tr><tr><td>高度</td><td>叶子结点的高度为1，叶子结点的父节点高度为2，以此类推，根节点的高度最高</td></tr><tr><td>层</td><td>根节点在第一层，以此类推</td></tr><tr><td>父节点</td><td>若一个节点含有子节点，则这个节点称之为其子节点的父节点</td></tr><tr><td>子节点</td><td>子节点是父节点的下一层节点</td></tr><tr><td>兄弟节点</td><td>拥有共同父节点的节点互称为兄弟节点</td></tr></tbody></table><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>如果树中的每个节点的子节点的个数不超过2，那么该树就是一个二叉树。</p><p><img src="img/1565609702432.png" alt="1565609702432"></p><h3 id="二叉查找树-二叉排序树"><a href="#二叉查找树-二叉排序树" class="headerlink" title="二叉查找树/二叉排序树"></a>二叉查找树/二叉排序树</h3><p>二叉查找树的特点：</p><ol><li>左子树上所有的节点的值均小于等于他的根节点的值</li><li>右子树上所有的节点值均大于或者等于他的根节点的值</li><li>每一个子节点最多有两个子树</li></ol><p>案例演示(20,18,23,22,17,24,19)数据的存储过程；</p><p><img src="img/1565611710800.png" alt="1565611710800"></p><p><strong>增删改查的性能都很高！！！</strong></p><p>遍历获取元素的时候可以按照”左中右”的顺序进行遍历；</p><p>注意：二叉查找树存在的问题：会出现”瘸子”的现象，影响查询效率。</p><p><img src="img/1565611927771.png" alt="1565611927771"></p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>（基于查找二叉树，但是让树不要太高，尽量让树的元素均衡分布。这样综合性能就高了）</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>为了避免出现”瘸子”的现象，减少树的高度，提高我们的搜素效率，又存在一种树的结构：”平衡二叉树”</p><p>规则：<strong>它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</strong></p><p>如下图所示：</p><p><img src="img/1562642409744.png" alt="1565611927771"></p><p>如下图所示，左图是一棵平衡二叉树，根节点10，左右两子树的高度差是1，而右图，虽然根节点左右两子树高度差是0，但是右子树15的左右子树高度差为2，不符合定义，</p><p>所以右图不是一棵平衡二叉树。</p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>在构建一棵平衡二叉树的过程中，当有新的节点要插入时，检查是否因插入后而破坏了树的平衡，如果是，则需要做旋转去改变树的结构。</p><p>左旋：</p><p><strong>左旋就是将节点的右支往左拉，右子节点变成父节点，并把晋升之后多余的左子节点出让给降级节点的右子节点；</strong></p><p><img src="img/%E5%B7%A6%E6%97%8B.png"></p><p>右旋：</p><p><strong>将节点的左支往右拉，左子节点变成了父节点，并把晋升之后多余的右子节点出让给降级节点的左子节点</strong></p><p><img src="img/%E5%8F%B3%E6%97%8B.png"></p><p>举个例子，像上图是否平衡二叉树的图里面，左图在没插入前”19”节点前，该树还是平衡二叉树，但是在插入”19”后，导致了”15”的左右子树失去了”平衡”，</p><p>所以此时可以将”15”节点进行左旋，让”15”自身把节点出让给”17”作为”17”的左树，使得”17”节点左右子树平衡，而”15”节点没有子树，左右也平衡了。如下图，</p><p><img src="img/1562644020804.png" alt="1562644020804"> </p><p>由于在构建平衡二叉树的时候，当有<strong>新节点插入</strong>时，都会判断插入后时候平衡，这说明了插入新节点前，都是平衡的，也即高度差绝对值不会超过1。当新节点插入后，</p><p>有可能会有导致树不平衡，这时候就需要进行调整，而可能出现的情况就有4种，分别称作<strong>左左，左右，右左，右右</strong>。</p><h5 id="左左"><a href="#左左" class="headerlink" title="左左"></a>左左</h5><p>左左即为在原来平衡的二叉树上，在节点的左子树的左子树下，有新节点插入，导致节点的左右子树的高度差为2，如下即为”10”节点的左子树”7”，的左子树”4”，插入了节点”5”或”3”导致失衡。</p><p><img src="img/1562644117681.png" alt="1562644117681"> </p><p>左左调整其实比较简单，只需要对节点进行右旋即可，如下图，对节点”10”进行右旋，</p><p><img src="img/1562645661857.png" alt="1562645661857"> </p><p><img src="img/1562645709201.png" alt="1562645709201"> </p><h5 id="左右"><a href="#左右" class="headerlink" title="左右"></a>左右</h5><p>左右即为在原来平衡的二叉树上，在节点的左子树的右子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”11”节点的左子树”7”，的右子树”9”，</p><p>插入了节点”10”或”8”导致失衡。</p><p><img src="img/1562644916480.png" alt="1562644916480"> </p><p>左右的调整就不能像左左一样，进行一次旋转就完成调整。我们不妨先试着让左右像左左一样对”11”节点进行右旋，结果图如下，右图的二叉树依然不平衡，而右图就是接下来要</p><p>讲的右左，即左右跟右左互为镜像，左左跟右右也互为镜像。</p><p><img src="img/1562645170454.png" alt="1562645170454"> </p><p>左右这种情况，进行一次旋转是不能满足我们的条件的，正确的调整方式是，将左右进行第一次旋转，将左右先调整成左左，然后再对左左进行调整，从而使得二叉树平衡。</p><p>即先对上图的节点”7”进行左旋，使得二叉树变成了左左，之后再对”11”节点进行右旋，此时二叉树就调整完成，如下图:</p><p><img src="img/1562645351977.png" alt="1562645351977"> </p><h5 id="右左"><a href="#右左" class="headerlink" title="右左"></a>右左</h5><p>右左即为在原来平衡的二叉树上，在节点的右子树的左子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”11”节点的右子树”15”，的左子树”13”，</p><p>插入了节点”12”或”14”导致失衡。</p><p><img src="img/1562645765291.png" alt="1562645765291"> </p><p>前面也说了，右左跟左右其实互为镜像，所以调整过程就反过来，先对节点”15”进行右旋，使得二叉树变成右右，之后再对”11”节点进行左旋，此时二叉树就调整完成，如下图:</p><p><img src="img/1562645894833.png" alt="1562645894833"> </p><h5 id="右右"><a href="#右右" class="headerlink" title="右右"></a>右右</h5><p>右右即为在原来平衡的二叉树上，在节点的右子树的右子树下，有新节点插入，导致节点的左右子树的高度差为2，如下即为”11”节点的右子树”13”，的左子树”15”，插入了节点</p><p>“14”或”19”导致失衡。</p><p><img src="img/1562645951703.png" alt="1562645951703"> </p><p>右右只需对节点进行一次左旋即可调整平衡，如下图，对”11”节点进行左旋。</p><p><img src="img/1562646135227.png" alt="1562646135227"> </p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>就是平衡的二叉查找树！！</p><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构，它是在1972年由Rudolf Bayer发明的，当时被称之为平衡二叉B树，后来，在1978年被</p><p>Leoj.Guibas和Robert Sedgewick修改为如今的”红黑树”。它是一种特殊的二叉查找树，红黑树的每一个节点上都有存储位表示节点的颜色，可以是红或者黑；</p><p>红黑树不是高度平衡的，它的平衡是通过”红黑树的特性”进行实现的；</p><p>红黑树的特性：</p><ol><li>每一个节点或是红色的，或者是黑色的。</li><li>根节点必须是黑色</li><li>每个叶节点(Nil)是黑色的；（如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点）</li><li>如果某一个节点是红色，那么它的子节点必须是黑色(不能出现两个红色节点相连的情况)</li><li>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点；</li></ol><p>如下图所示就是一个</p><p><img src="img/1562653205543.png" alt="1562653205543"> </p><p>在进行元素插入的时候，和之前一样； 每一次插入完毕以后，使用黑色规则进行校验，如果不满足红黑规则，就需要通过变色，左旋和右旋来调整树，使其满足红黑规则；</p><h1 id="第三章-List接口"><a href="#第三章-List接口" class="headerlink" title="第三章 List接口"></a>第三章 List接口</h1><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p><p>接下来，我们一起学习Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p><h2 id="3-1-List接口介绍"><a href="#3-1-List接口介绍" class="headerlink" title="3.1 List接口介绍"></a>3.1 List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><p>看完API，我们总结一下：</p><p>List接口特点：</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><blockquote><p>tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p></blockquote><h2 id="3-2-List接口中常用方法"><a href="#3-2-List接口中常用方法" class="headerlink" title="3.2 List接口中常用方法"></a>3.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>List集合特有的方法都是跟索引相关，我们在基础班都学习过。</p><blockquote><p>tips:我们之前学习Colletion体系的时候，发现List集合下有很多集合，它们的存储结构不同，这样就导致了这些集合它们有各自的特点，供我们在不同的环境下使用，那么常见的数据结构有哪些呢？在下一章我们来介绍：</p></blockquote><h2 id="3-3-ArrayList集合"><a href="#3-3-ArrayList集合" class="headerlink" title="3.3 ArrayList集合"></a>3.3 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p><h2 id="3-4-LinkedList集合"><a href="#3-4-LinkedList集合" class="headerlink" title="3.4 LinkedList集合"></a>3.4 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><blockquote><p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p></blockquote><p><img src="img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为<strong>了解即可</strong>：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。</p><pre><code class="java">public class Demo04LinkedList &#123;    public static void main(String[] args) &#123;        method4();    &#125;    /*     *  void push(E e)： 压入。把元素添加到集合的第一个位置。     *  E pop()： 弹出。把第一个元素删除，然后返回这个元素。     */    public static void method4() &#123;        //创建LinkedList对象        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();        //添加元素        list.add(&quot;达尔文&quot;);        list.add(&quot;达芬奇&quot;);        list.add(&quot;达尔优&quot;);        System.out.println(&quot;list:&quot; + list);        //调用push在集合的第一个位置添加元素        //list.push(&quot;爱迪生&quot;);        //System.out.println(&quot;list:&quot; + list);//[爱迪生, 达尔文, 达芬奇, 达尔优]                //E pop()： 弹出。把第一个元素删除，然后返回这个元素。        String value = list.pop();        System.out.println(&quot;value:&quot; + value);//达尔文        System.out.println(&quot;list:&quot; + list);//[达芬奇，达尔优]    &#125;        /*     * E removeFirst()：删除第一个元素     * E removeLast()：删除最后一个元素。     */    public static void method3() &#123;        //创建LinkedList对象        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();        //添加元素        list.add(&quot;达尔文&quot;);        list.add(&quot;达芬奇&quot;);        list.add(&quot;达尔优&quot;);        //删除集合的第一个元素//        String value = list.removeFirst();//        System.out.println(&quot;value:&quot; + value);//达尔文//        System.out.println(&quot;list:&quot; + list);//[达芬奇，达尔优]                //删除最后一个元素        String value = list.removeLast();        System.out.println(&quot;value:&quot; + value);//达尔优        System.out.println(&quot;list:&quot; + list);//[达尔文， 达芬奇]    &#125;        /*     * E getFirst()： 获取集合中的第一个元素     * E getLast()： 获取集合中的最后一个元素     */    public static void method2() &#123;        //创建LinkedList对象        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();        //添加元素        list.add(&quot;达尔文&quot;);        list.add(&quot;达芬奇&quot;);        list.add(&quot;达尔优&quot;);                System.out.println(&quot;list:&quot; + list);        //获取集合中的第一个元素        System.out.println(&quot;第一个元素是：&quot; + list.getFirst());        //获取集合中的最后一个元素怒        System.out.println(&quot;最后一个元素是：&quot; + list.getLast());    &#125;             /*     * void addFirst(E e)： 在集合的开头位置添加元素。     * void addLast(E e)： 在集合的尾部添加元素。     */    public static void method1() &#123;        //创建LinkedList对象        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();        //添加元素        list.add(&quot;达尔文&quot;);        list.add(&quot;达芬奇&quot;);        list.add(&quot;达尔优&quot;);        //打印这个集合        System.out.println(&quot;list:&quot; + list);//[达尔文, 达芬奇, 达尔优]        //调用addFirst添加元素        list.addFirst(&quot;曹操&quot;);        System.out.println(&quot;list:&quot; + list);//[曹操, 达尔文, 达芬奇, 达尔优]        //调用addLast方法添加元素        list.addLast(&quot;大乔&quot;);        System.out.println(&quot;list:&quot; + list);//[曹操, 达尔文, 达芬奇, 达尔优, 大乔]            &#125;&#125;</code></pre><h1 id="第四章-Set接口"><a href="#第四章-Set接口" class="headerlink" title="第四章 Set接口"></a>第四章 Set接口</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口都会以某种规则保证存入的元素不出现重复。</p><p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>、<code>java.util.TreeSet</code>这两个集合。</p><blockquote><p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p></blockquote><h2 id="4-1-HashSet集合介绍"><a href="#4-1-HashSet集合介绍" class="headerlink" title="4.1 HashSet集合介绍"></a>4.1 HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不能保证不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存储和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p><pre><code class="java">public class HashSetDemo &#123;    public static void main(String[] args) &#123;        //创建 Set集合        HashSet&lt;String&gt;  set = new HashSet&lt;String&gt;();        //添加元素        set.add(new String(&quot;cba&quot;));        set.add(&quot;abc&quot;);        set.add(&quot;bac&quot;);         set.add(&quot;cba&quot;);          //遍历        for (String name : set) &#123;            System.out.println(name);        &#125;    &#125;&#125;</code></pre><p>输出结果如下，说明集合中不能存储重复元素：</p><pre><code>cbaabcbac</code></pre><blockquote><p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p></blockquote><h2 id="4-2-HashSet集合存储数据的结构（哈希表）"><a href="#4-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="4.2  HashSet集合存储数据的结构（哈希表）"></a>4.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p><p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用数组处理冲突，同一hash值的链表都存储在一个数组里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<img src="assets/%E5%93%88%E5%B8%8C%E8%A1%A8.png"> </p><p>看到这张图就有人要问了，这个是怎么存储的呢？</p><p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p><p><img src="img/%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p><h2 id="4-3-HashSet存储自定义类型元素"><a href="#4-3-HashSet存储自定义类型元素" class="headerlink" title="4.3  HashSet存储自定义类型元素"></a>4.3  HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一.</p><p>创建自定义Student类:</p><pre><code class="java">public class Student &#123;    private String name;    private int age;    //get/set    @Override    public boolean equals(Object o) &#123;        if (this == o)            return true;        if (o == null || getClass() != o.getClass())            return false;        Student student = (Student) o;        return age == student.age &amp;&amp;               Objects.equals(name, student.name);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(name, age);    &#125;&#125;</code></pre><p>创建测试类:</p><pre><code class="java">public class HashSetDemo2 &#123;    public static void main(String[] args) &#123;        //创建集合对象   该集合中存储 Student类型对象        HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;();        //存储         Student stu = new Student(&quot;于谦&quot;, 43);        stuSet.add(stu);        stuSet.add(new Student(&quot;郭德纲&quot;, 44));        stuSet.add(new Student(&quot;于谦&quot;, 43));        stuSet.add(new Student(&quot;郭麒麟&quot;, 23));        stuSet.add(stu);        for (Student stu2 : stuSet) &#123;            System.out.println(stu2);        &#125;    &#125;&#125;执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23]</code></pre><h2 id="4-4-LinkedHashSet"><a href="#4-4-LinkedHashSet" class="headerlink" title="4.4 LinkedHashSet"></a>4.4 LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><p>演示代码如下:</p><pre><code class="java">public class LinkedHashSetDemo &#123;    public static void main(String[] args) &#123;        Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;();        set.add(&quot;bbb&quot;);        set.add(&quot;aaa&quot;);        set.add(&quot;abc&quot;);        set.add(&quot;bbc&quot;);        Iterator&lt;String&gt; it = set.iterator();        while (it.hasNext()) &#123;            System.out.println(it.next());        &#125;    &#125;&#125;结果：  bbb  aaa  abc  bbc</code></pre><h2 id="4-5-TreeSet集合"><a href="#4-5-TreeSet集合" class="headerlink" title="4.5 TreeSet集合"></a>4.5 TreeSet集合</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><p>TreeSet集合是Set接口的一个实现类,底层依赖于TreeMap,是一种基于<strong>红黑树</strong>的实现,其特点为：</p><ol><li>元素唯一</li><li>元素没有索引</li><li>使用元素的<a href="../../java/lang/Comparable.html">自然顺序</a>对元素进行排序，或者根据创建 TreeSet 时提供的 <a href="../../java/util/Comparator.html"><code>Comparator</code></a> 比较器<br>进行排序，具体取决于使用的构造方法：</li></ol><pre><code class="java">public TreeSet()：                                根据其元素的自然排序进行排序public TreeSet(Comparator&lt;E&gt; comparator):    根据指定的比较器进行排序</code></pre><h3 id="2-演示"><a href="#2-演示" class="headerlink" title="2. 演示"></a>2. 演示</h3><p>案例演示<strong>自然排序</strong>(20,18,23,22,17,24,19):</p><pre><code class="java">public static void main(String[] args) &#123;    //无参构造,默认使用元素的自然顺序进行排序    TreeSet&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;();    set.add(20);    set.add(18);      set.add(23);      set.add(22);      set.add(17);      set.add(24);      set.add(19);      System.out.println(set);&#125;控制台的输出结果为:[17, 18, 19, 20, 22, 23, 24]</code></pre><p>案例演示<strong>比较器排序</strong>(20,18,23,22,17,24,19):</p><pre><code class="java">public static void main(String[] args) &#123;      //有参构造,传入比较器,使用比较器对元素进行排序      TreeSet&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;(new Comparator&lt;Integer&gt;() &#123;        @Override        public int compare(Integer o1, Integer o2) &#123;              //元素前 - 元素后 : 升序              //元素后 - 元素前 : 降序              return o2 - o1;        &#125;      &#125;);      set.add(20);      set.add(18);      set.add(23);      set.add(22);      set.add(17);      set.add(24);      set.add(19);      System.out.println(set);&#125;控制台的输出结果为:[24, 23, 22, 20, 19, 18, 17]</code></pre><h1 id="第五章-Collections类"><a href="#第五章-Collections类" class="headerlink" title="第五章  Collections类"></a>第五章  Collections类</h1><h2 id="5-1-Collections常用功能"><a href="#5-1-Collections常用功能" class="headerlink" title="5.1 Collections常用功能"></a>5.1 Collections常用功能</h2><ul><li><p><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。</p><p>常用方法如下：</p></li><li><p><code>public static void shuffle(List&lt;?&gt; list) </code>:打乱集合顺序。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</p></li></ul><p>代码演示：</p><pre><code class="java">public class CollectionsDemo &#123;    public static void main(String[] args) &#123;        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();           list.add(100);        list.add(300);        list.add(200);        list.add(50);        //排序方法         Collections.sort(list);        System.out.println(list);    &#125;&#125;结果：[50,100, 200, 300]</code></pre><p>我们的集合按照默认的自然顺序进行了排列，如果想要指定顺序那该怎么办呢？</p><h2 id="5-2-Comparator比较器"><a href="#5-2-Comparator比较器" class="headerlink" title="5.2 Comparator比较器"></a>5.2 Comparator比较器</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p><p>Student 类</p><pre><code class="java">public class Student&#123;    private String name;    private int age;    //构造方法    //get/set     //toString&#125;</code></pre><p>测试类：</p><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        // 创建四个学生对象 存储到集合中        ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;();        list.add(new Student(&quot;rose&quot;,18));        list.add(new Student(&quot;jack&quot;,16));        list.add(new Student(&quot;abc&quot;,20));        Collections.sort(list, new Comparator&lt;Student&gt;() &#123;            @Override            public int compare(Student o1, Student o2) &#123;            return o1.getAge()-o2.getAge();//以学生的年龄升序            &#125;        &#125;);        for (Student student : list) &#123;            System.out.println(student);        &#125;    &#125;&#125;Student&#123;name=&#39;jack&#39;, age=16&#125;Student&#123;name=&#39;rose&#39;, age=18&#125;Student&#123;name=&#39;abc&#39;, age=20&#125;</code></pre><h2 id="5-3-可变参数"><a href="#5-3-可变参数" class="headerlink" title="5.3 可变参数"></a>5.3 可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化.</p><p><strong>格式：</strong></p><pre><code>修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</code></pre><p><strong>代码演示:</strong></p><pre><code class="java">  public class ChangeArgs &#123;    public static void main(String[] args) &#123;        int sum = getSum(6, 7, 2, 12, 2121);        System.out.println(sum);    &#125;        public static int getSum(int... arr) &#123;           int sum = 0;            for (int a : arr) &#123;         sum += a;        &#125;            return sum;    &#125;&#125;</code></pre><p><strong>注意：</strong></p><p>​    1.一个方法只能有一个可变参数</p><p>​    2.如果方法中有多个参数，可变参数要放到最后。</p><p><strong>应用场景: Collections</strong></p><p>​    在Collections中也提供了添加一些元素方法：</p><p>​    <code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</p><p><strong>代码演示:</strong></p><pre><code class="java">public class CollectionsDemo &#123;    public static void main(String[] args) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();      //原来写法      //list.add(12);      //list.add(14);      //list.add(15);      //list.add(1000);      //采用工具类 完成 往集合中添加元素        Collections.addAll(list, 5, 222, 1，2);      System.out.println(list);&#125;</code></pre><h1 id="第六章-集合综合案例"><a href="#第六章-集合综合案例" class="headerlink" title="第六章 集合综合案例"></a>第六章 集合综合案例</h1><h2 id="6-1-案例介绍"><a href="#6-1-案例介绍" class="headerlink" title="6.1 案例介绍"></a>6.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p><p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p><h2 id="6-2-案例分析"><a href="#6-2-案例分析" class="headerlink" title="6.2 案例分析"></a>6.2 案例分析</h2><ul><li><p>准备牌：</p><p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p></li><li><p>发牌</p><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p></li><li><p>看牌</p><p>直接打印每个集合。</p></li></ul><h2 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h2><ol><li>Poker.java</li></ol><pre><code class="java">public class Poker &#123;    private String name;    public Poker() &#123;    &#125;    public Poker(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;&#123;&quot; + name + &quot;&#125;&quot;;    &#125;&#125;</code></pre><p>2 测试类</p><pre><code class="java">public class Demo12 &#123;    public static void main(String[] args) &#123;        // 创建一个ArrayList用于存放一副牌        ArrayList&lt;Poker&gt; pokers = new ArrayList&lt;&gt;();        pokers.add(new Poker(&quot;大王&quot;, &quot;&quot;));        pokers.add(new Poker(&quot;小王&quot;, &quot;&quot;));        String[] colors = new String[] &#123;&quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot;&#125;;        String[] numbers = new String[] &#123;&quot;2&quot;, &quot;A&quot;, &quot;K&quot;, &quot;Q&quot;, &quot;J&quot;, &quot;10&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;&#125;;        // 组合牌, 嵌套循环的流程:外循环一次,内循环所有次        // 2.使用嵌套循环生成一副牌        for (String n : numbers) &#123;            // &quot;2&quot;, &quot;A&quot;            for (String c : colors) &#123;                // &quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot;                Poker p = new Poker(c, n);                // 3.将54张牌放到集合                pokers.add(p);            &#125;        &#125;        // 打印//        System.out.println(pokers);        // 洗牌: Collections,集合工具类        // static void shuffle​(List&lt;?&gt; list) 将集合中元素的顺序打乱        Collections.shuffle(pokers);        System.out.println(&quot;洗牌后:&quot; + pokers);        // 发牌        // 1.创建3个玩家集合,创建底牌集合        ArrayList&lt;Poker&gt; player01 = new ArrayList&lt;&gt;();        ArrayList&lt;Poker&gt; player02 = new ArrayList&lt;&gt;();        ArrayList&lt;Poker&gt; player03 = new ArrayList&lt;&gt;();        ArrayList&lt;Poker&gt; diPai = new ArrayList&lt;&gt;();        // 2.遍历牌的集合        //            0     1      2     3     4     5      6     7     8      9     10 ...51    52     53        // pokers = [♦5], [♣4], [♦8], [♣A], [♣7], [♦2], [♠6], [♣J], [♥A], [♥7], [♥6], [♣5], [♦7], [♥10]        // 玩家1:   索引0,3,6       索引 % 3 == 0        // 玩家2:   索引1,4,7       索引 % 3 == 1        // 玩家3:   索引2,5,8       索引 % 3 == 2        // 3.根据索引将牌发给不同的玩家        for (int i = 0; i &lt; pokers.size(); i++) &#123;            // i表示索引,poker就是i索引对应的poker            Poker poker = pokers.get(i);            if (i &gt;= 51) &#123; // 最后3张给底牌                diPai.add(poker);            &#125; else if (i % 3 == 0) &#123; // 玩家1                player01.add(poker);            &#125; else if (i % 3 == 1) &#123; // 玩家2                player02.add(poker);            &#125; else if (i % 3 == 2) &#123; // 玩家3                player03.add(poker);            &#125;        &#125;        // 看牌        System.out.println(&quot;玩家1: &quot; + player01);        System.out.println(&quot;玩家2: &quot; + player02);        System.out.println(&quot;玩家3: &quot; + player03);        System.out.println(&quot;底牌: &quot; + diPai);        // 还要创建一副牌        // 创建一个ArrayList用于存放一副牌    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day05【迭代器，数据结构-List-Set-TreeSet集合-Collections工具类】&quot;&gt;&lt;a href=&quot;#day05【迭代器，数据结构-List-Set-TreeSet集合-Collections工具类】&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java进阶13天资料" scheme="http://example.com/tags/java%E8%BF%9B%E9%98%B613%E5%A4%A9%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Day04</title>
    <link href="http://example.com/2021/09/05/JAVA/day04%E3%80%90%E5%B8%B8%E7%94%A8API%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E3%80%81collection%E6%8E%A5%E5%8F%A3%E3%80%91/"/>
    <id>http://example.com/2021/09/05/JAVA/day04%E3%80%90%E5%B8%B8%E7%94%A8API%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E3%80%81collection%E6%8E%A5%E5%8F%A3%E3%80%91/</id>
    <published>2021-09-05T02:33:46.000Z</published>
    <updated>2021-09-05T03:04:28.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day04【常用API、正则表达式，泛型、Collection集合API】"><a href="#day04【常用API、正则表达式，泛型、Collection集合API】" class="headerlink" title="day04【常用API、正则表达式，泛型、Collection集合API】"></a>day04【常用API、正则表达式，泛型、Collection集合API】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>Date类<ul><li>Java是面向对象的思想，会用一个类来代表一个事物。</li><li>Date代表了系统当前此刻日期对象！年月日时分秒。</li></ul></li><li>DateFormat类<ul><li>日期格式化类，认为日期对象拿到的时间是不好看的！</li><li>日期格式化类可以把时间格式化成我们喜欢的格式。</li><li>日期格式化类可以把字符串时间解析成日期对象!!  “2019-10-01 09:28:00”</li></ul></li><li>Calendar类  <ul><li>日历类，代表了此刻日期对象对应的日历对象。日历的信息更加的丰富。</li></ul></li><li>System类<ul><li>代表了当前JVM虚拟机对应的操作系统对象。</li><li>可以拿系统时间。</li><li>可以让程序退出JVM虚拟机，让程序立即死亡！！</li><li>可以做数组拷贝。</li></ul></li><li>StringBuilder类<ul><li>String类不适合做字符串的拼接，增删等运算。不可变字符串，增删性能较差！</li><li>StringBuillder非常适合做字符串的增删改查操作，性能更好！！</li></ul></li><li>包装类<ul><li>一切皆对象。   </li><li>int Integer   int age = 21;    Integer age1 = 21; </li><li>float Float </li><li>double Double</li></ul></li><li>泛型<ul><li>ArrayLIst<Integer> lists = new ArrayList&lt;&gt;();</li></ul></li><li><strong>Collection集合：List , Map , Set</strong> <ul><li>三天的集合框架（重点内容，开发必用的！！）</li></ul></li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><p><input disabled="" type="checkbox">  能够使用日期类输出当前日期</p><ul><li><input disabled="" type="checkbox"> <strong>Date d = new Date();</strong></li><li><input disabled="" type="checkbox"> <strong>System.out.println(d);</strong></li></ul></li><li><p><input disabled="" type="checkbox">  能够使用将日期格式化为字符串的方法</p><ul><li><input disabled="" type="checkbox"> <strong>SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);</strong></li><li><input disabled="" type="checkbox"> <strong>String rs = sdf.format(“日期对象”)</strong></li><li><input disabled="" type="checkbox"> <strong>String rs = sdf.format(“时间毫秒值”)</strong></li></ul></li><li><p><input disabled="" type="checkbox">  能够使用将字符串转换成日期的方法</p><ul><li><input disabled="" type="checkbox"> <strong>SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);</strong></li><li><input disabled="" type="checkbox"> <strong>String str = “2019-11-11 11:11:11”;</strong></li><li><input disabled="" type="checkbox"> <strong>Data d = sdf.parse(str );</strong></li><li><input disabled="" type="checkbox"> System.out.println(d);</li></ul></li><li><p><input disabled="" type="checkbox">  能够使用System类的数组复制方法</p><pre><code class="java">// 3.数组拷贝：int[] arrs1 = &#123;10 , 20 , 30 , 40 , 50 , 60 , 70 , 80&#125;;// arrs2 = [ 0 , 0 , 0 , 0 , 0 , 0]// arrs2 = [0 , 0 , 30 , 40 , 50 , 0]// 希望把第一个数组的 30 , 40 , 50赋值到第二个数组！int[] arrs2 = new int[6];/** arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length) 参数一：原数组。 参数二：从原数组哪个位置开始复制 参数三：目标数组 参数四：复制到目标数组的哪个位置开始。 参数五：复制多少个！ */System.arraycopy(arrs1, 2 ,arrs2 , 2 , 3);System.out.println(Arrays.toString(arrs2));</code></pre></li><li><p><input disabled="" type="checkbox">  能够使用System类获取当前毫秒时刻值</p><ul><li><input disabled="" type="checkbox"> <pre><code class="java">long time = System.currentTimeMillis();</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  能够说出使用StringBuilder类可以解决的问题</p><ul><li><input disabled="" type="checkbox"> 可以做字符串的运算（拼接，增删，反转）</li></ul></li><li><p><input disabled="" type="checkbox">  能够使用StringBuilder进行字符串拼接操作</p><ul><li><input disabled="" type="checkbox"> append</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出8种基本类型对应的包装类名称</p><ul><li><p><input disabled="" type="checkbox">  int Integer</p></li><li><p><input disabled="" type="checkbox">  char Character</p></li><li><p><input disabled="" type="checkbox"> </p><pre><code class="properties">基本数据类型              包装类    byte                 Byte    short                Short    int                  Integer(特殊)    long                 Long    float                Float    double               Double    char                 Character(特殊)    boolean              Boolean</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  能够说出自动装箱、自动拆箱的概念</p><ul><li><input disabled="" type="checkbox"> <pre><code class="properties">自动装箱：可以直接把基本数据类型的变量或者值赋值给对应的包装类对象。自动拆箱：可以把包装类的对象赋值给基本数据类型的变量。</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  能够将字符串转换为对应的基本类型</p><pre><code class="properties">功能3: 把字符串类型的数字转化成对应的基本数据类型的值！！（真的有用，而且挺重要）          Xxxx.parseXxxx(&quot;字符串类型的数字&quot;)          Xxxx.valueOf(&quot;字符串类型的数字&quot;)：推荐使用的！</code></pre></li><li><p><input disabled="" type="checkbox">  能够将基本类型转换为对应的字符串</p><pre><code class="java">// 功能2: 包装类可以把基本数据类型的值转换成字符串。// 1.把基本数据类型的值转换成字符串:toString()Integer num = 23 ;String numStr1 = num.toString();System.out.println(numStr1+1); // 231// 2.把基本数据类型的值转换成字符串:Integer num1 = 23 ;String num1Str1 = Integer.toString(num1);System.out.println(num1Str1+1); // 231// 3.把基本数据类型的值转换成字符串:Integer num2 = 23 ;String num2Str1 = num2 + &quot;&quot; ; //常见做法！System.out.println(num2Str1+1); // 231</code></pre></li><li><p><input disabled="" type="checkbox">  能够说出Collection集合的常用功能</p><ul><li><input disabled="" type="checkbox"> <pre><code class="properties">Collection集合作为集合的根类，它的功能是一切集合都可以直接使用的。 - public boolean add(E e)：  把给定的对象添加到当前集合中 。 - public void clear() :清空集合中所有的元素。 - public boolean remove(E e): 把给定的对象在当前集合中删除。 - public boolean contains(Object obj): 判断当前集合中是否包含给定的对象。 - public boolean isEmpty(): 判断当前集合是否为空。 - public int size(): 返回集合中元素的个数。 - public Object[] toArray(): 把集合中的元素，存储到数组中</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  能够使用泛型创建集合对象</p><ul><li><input disabled="" type="checkbox"> <pre><code class="java">ArrayList&lt;String&gt; lists = new ArrayList&lt;&gt;(); // JDK 1.7之后泛型的简化写法！ArrayList&lt;Integer&gt; lists1 = new ArrayList&lt;&gt;();// JDK 1.7之后泛型的简化写法！</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  能够理解泛型上下限</p><ul><li><input disabled="" type="checkbox"> ? extends Car : ?必须是Car的子类或者本身 。  上限</li><li><input disabled="" type="checkbox"> ? super Car : ?必须是Car的父类或者本身 。  下限   不用的!!</li></ul></li><li><p><input disabled="" type="checkbox">  能够阐述泛型通配符的作用</p><ul><li><input disabled="" type="checkbox"> ? 可以在使用泛型的时候，代表接收一切类型</li></ul></li></ul><h1 id="第一章-DateFormat类"><a href="#第一章-DateFormat类" class="headerlink" title="第一章 DateFormat类"></a>第一章 DateFormat类</h1><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p><ul><li><strong>格式化</strong>：按照指定的格式，把Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，把String对象转换为Date对象。</li></ul><h2 id="1-1-构造方法"><a href="#1-1-构造方法" class="headerlink" title="1.1 构造方法"></a>1.1 构造方法</h2><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。</li></ul><h2 id="1-2-格式规则"><a href="#1-2-格式规则" class="headerlink" title="1.2 格式规则"></a>1.2 格式规则</h2><p>常用的格式规则为：</p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><blockquote><p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档。</p></blockquote><h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><p>DateFormat类的常用方法有：</p><ul><li><p><code>public String format(Date date)</code>：将Date对象格式化为字符串。</p></li><li><p><code>public Date parse(String source)</code>：将字符串解析为Date对象。</p><pre><code class="java">public class SimpleDateFormatDemo &#123;    public static void main(String[] args) throws ParseException &#123;        //格式化：从 Date 到 String        Date d = new Date();        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);        String s = sdf.format(d);        System.out.println(s);        System.out.println(&quot;--------&quot;);        //从 String 到 Date        String ss = &quot;2048-08-09 11:11:11&quot;;        //ParseException        SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        Date dd = sdf2.parse(ss);        System.out.println(dd);    &#125;&#125;</code></pre></li></ul><blockquote><p>小结：DateFormat可以将Date对象和字符串相互转换。</p></blockquote><h1 id="第二章-Calendar类"><a href="#第二章-Calendar类" class="headerlink" title="第二章 Calendar类"></a>第二章 Calendar类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul><li>java.util.Calendar类表示一个“日历类”，可以进行日期运算。它是一个抽象类，不能创建对象，我们可以使用它的子类：java.util.GregorianCalendar类。</li><li>有两种方式可以获取GregorianCalendar对象：<ul><li>直接创建GregorianCalendar对象；</li><li>通过Calendar的静态方法getInstance()方法获取GregorianCalendar对象【本次课使用】</li></ul></li></ul><h2 id="2-2-常用方法"><a href="#2-2-常用方法" class="headerlink" title="2.2 常用方法"></a>2.2 常用方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Calendar getInstance()</td><td>获取一个它的子类GregorianCalendar对象。</td></tr><tr><td>public int get(int field)</td><td>获取某个字段的值。field参数表示获取哪个字段的值，<br />可以使用Calender中定义的常量来表示：<br />Calendar.YEAR : 年<br />Calendar.MONTH ：月<br />Calendar.DAY_OF_MONTH：月中的日期<br />Calendar.HOUR：小时<br />Calendar.MINUTE：分钟<br />Calendar.SECOND：秒<br />Calendar.DAY_OF_WEEK：星期</td></tr><tr><td>public void set(int field,int value)</td><td>设置某个字段的值</td></tr><tr><td>public void add(int field,int amount)</td><td>为某个字段增加/减少指定的值</td></tr></tbody></table><h2 id="2-3-get方法示例"><a href="#2-3-get方法示例" class="headerlink" title="2.3 get方法示例"></a>2.3 get方法示例</h2><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        //1.获取一个GregorianCalendar对象        Calendar instance = Calendar.getInstance();//获取子类对象        //2.打印子类对象        System.out.println(instance);        //3.获取属性        int year = instance.get(Calendar.YEAR);        int month = instance.get(Calendar.MONTH) + 1;//Calendar的月份值是0-11        int day = instance.get(Calendar.DAY_OF_MONTH);        int hour = instance.get(Calendar.HOUR);        int minute = instance.get(Calendar.MINUTE);        int second = instance.get(Calendar.SECOND);        int week = instance.get(Calendar.DAY_OF_WEEK);//返回值范围：1--7，分别表示：&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,...,&quot;星期六&quot;        System.out.println(year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot; +                                hour + &quot;:&quot; + minute + &quot;:&quot; + second);        System.out.println(getWeek(week));    &#125;    //查表法，查询星期几    public static String getWeek(int w) &#123;//w = 1 --- 7        //做一个表(数组)        String[] weekArray = &#123;&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;&#125;;        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]        //查表        return weekArray[w - 1];    &#125;&#125;</code></pre><h2 id="2-4-set方法示例："><a href="#2-4-set方法示例：" class="headerlink" title="2.4 set方法示例："></a>2.4 set方法示例：</h2><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        //设置属性——set(int field,int value):        Calendar c1 = Calendar.getInstance();//获取当前日期        //计算班长出生那天是星期几(假如班长出生日期为：1998年3月18日)        c1.set(Calendar.YEAR, 1998);        c1.set(Calendar.MONTH, 3 - 1);//转换为Calendar内部的月份值        c1.set(Calendar.DAY_OF_MONTH, 18);        int w = c1.get(Calendar.DAY_OF_WEEK);        System.out.println(&quot;班长出生那天是：&quot; + getWeek(w));            &#125;    //查表法，查询星期几    public static String getWeek(int w) &#123;//w = 1 --- 7        //做一个表(数组)        String[] weekArray = &#123;&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;&#125;;        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]        //查表        return weekArray[w - 1];    &#125;&#125;</code></pre><h2 id="2-5-add方法示例："><a href="#2-5-add方法示例：" class="headerlink" title="2.5 add方法示例："></a>2.5 add方法示例：</h2><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        //计算200天以后是哪年哪月哪日，星期几？        Calendar c2 = Calendar.getInstance();//获取当前日期        c2.add(Calendar.DAY_OF_MONTH, 200);//日期加200        int y = c2.get(Calendar.YEAR);        int m = c2.get(Calendar.MONTH) + 1;//转换为实际的月份        int d = c2.get(Calendar.DAY_OF_MONTH);        int wk = c2.get(Calendar.DAY_OF_WEEK);        System.out.println(&quot;200天后是：&quot; + y + &quot;年&quot; + m + &quot;月&quot; + d + &quot;日&quot; + getWeek(wk));    &#125;    //查表法，查询星期几    public static String getWeek(int w) &#123;//w = 1 --- 7        //做一个表(数组)        String[] weekArray = &#123;&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;&#125;;        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]        //查表        return weekArray[w - 1];    &#125;&#125;</code></pre><h1 id="第三章-Math类"><a href="#第三章-Math类" class="headerlink" title="第三章 Math类"></a>第三章 Math类</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ul><li>java.lang.Math(类): Math包含执行基本数字运算的方法。</li><li>它不能创建对象，它的构造方法被“私有”了。因为他内部都是“静态方法”，通过“类名”直接调用即可。</li></ul><h2 id="3-2-常用方法"><a href="#3-2-常用方法" class="headerlink" title="3.2 常用方法"></a>3.2 常用方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static int abs(int a)</td><td>获取参数a的绝对值：</td></tr><tr><td>public static double ceil(double a)</td><td>向上取整</td></tr><tr><td>public static double floor(double a)</td><td>向下取整</td></tr><tr><td>public static double pow(double a, double b)</td><td>获取a的b次幂</td></tr><tr><td>public static long round(double a)</td><td>四舍五入取整</td></tr></tbody></table><h2 id="3-3-示例代码"><a href="#3-3-示例代码" class="headerlink" title="3.3 示例代码"></a>3.3 示例代码</h2><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;-5的绝对值：&quot; + Math.abs(-5));//5        System.out.println(&quot;3.4向上取整：&quot; + Math.ceil(3.4));//4.0        System.out.println(&quot;3.4向下取整：&quot; + Math.floor(3.4));//3.0        System.out.println(&quot;2的8次幂：&quot; + Math.pow(2, 8));//256.0        System.out.println(&quot;3.2四舍五入：&quot; + Math.round(3.2));//3        System.out.println(&quot;3.5四舍五入：&quot; + Math.round(3.5));//4    &#125;&#125;</code></pre><h1 id="第四章-System"><a href="#第四章-System" class="headerlink" title="第四章 System"></a>第四章 System</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作。</p><h2 id="4-2-常用方法"><a href="#4-2-常用方法" class="headerlink" title="4.2 常用方法"></a>4.2 常用方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public   static void exit(int status)</td><td>终止当前运行的   Java   虚拟机，非零表示异常终止</td></tr><tr><td>public   static long currentTimeMillis()</td><td>返回当前时间(以毫秒为单位)</td></tr></tbody></table><h2 id="4-3-练习"><a href="#4-3-练习" class="headerlink" title="4.3 练习"></a>4.3 练习</h2><p>在控制台输出1-10000，计算这段代码执行了多少毫秒 </p><pre><code class="java">import java.util.Date;//验证for循环打印数字1-9999所需要使用的时间（毫秒）public class SystemDemo &#123;    public static void main(String[] args) &#123;           //获取当前时间毫秒值       System.out.println(System.currentTimeMillis());       //计算程序运行时间       long start = System.currentTimeMillis();        for (int i = 1; i &lt;= 10000; i++) &#123;            System.out.println(i);        &#125;        long end = System.currentTimeMillis();        System.out.println(&quot;共耗时毫秒：&quot; + (end - start));    &#125;  &#125;</code></pre><h1 id="第五章-BigDecimal类"><a href="#第五章-BigDecimal类" class="headerlink" title="第五章 BigDecimal类"></a>第五章 BigDecimal类</h1><h2 id="5-1-引入"><a href="#5-1-引入" class="headerlink" title="5.1 引入"></a>5.1 引入</h2><p>浮点数做运算精度问题；</p><p>看程序说结果：</p><pre><code class="java">public static void main(String[] args) &#123;    System.out.println(0.09 + 0.01);    System.out.println(1.0 - 0.32);    System.out.println(1.015 * 100);    System.out.println(1.301 / 100);&#125;</code></pre><h2 id="5-2-概述"><a href="#5-2-概述" class="headerlink" title="5.2 概述"></a>5.2 概述</h2><table><thead><tr><th>相关内容</th><th align="left">具体描述</th></tr></thead><tbody><tr><td>包</td><td align="left">java.math                                                                  使用时需要导包</td></tr><tr><td>类声明</td><td align="left">public class BigDecimal extends Number implements Comparable<BigDecimal></td></tr><tr><td>描述</td><td align="left">BigDecimal类提供了算术，缩放操作，舍入，比较，散列和格式转换的操作。提供了更加精准的数据计算方式</td></tr></tbody></table><h2 id="5-3-构造方法"><a href="#5-3-构造方法" class="headerlink" title="5.3 构造方法"></a>5.3 构造方法</h2><table><thead><tr><th>构造方法名</th><th>描述</th></tr></thead><tbody><tr><td>BigDecimal(double val)</td><td>将double类型的数据封装为BigDecimal对象</td></tr><tr><td>BigDecimal(String val)</td><td>将 BigDecimal 的字符串表示形式转换为 BigDecimal</td></tr></tbody></table><p>注意：推荐使用第二种方式，第一种存在精度问题；</p><h2 id="5-4-常用方法"><a href="#5-4-常用方法" class="headerlink" title="5.4 常用方法"></a>5.4 常用方法</h2><p>BigDecimal类中使用最多的还是提供的进行四则运算的方法，如下：</p><table><thead><tr><th>方法声明</th><th>描述</th></tr></thead><tbody><tr><td>public BigDecimal add(BigDecimal value)</td><td>加法运算</td></tr><tr><td>public BigDecimal subtract(BigDecimal value)</td><td>减法运算</td></tr><tr><td>public BigDecimal multiply(BigDecimal value)</td><td>乘法运算</td></tr><tr><td>public BigDecimal divide(BigDecimal value)</td><td>触发运算</td></tr></tbody></table><p>注意：对于divide方法来说，如果除不尽的话，就会出现java.lang.ArithmeticException异常。此时可以使用divide方法的另一个重载方法；</p><blockquote><p>BigDecimal divide(BigDecimal divisor, int scale, int roundingMode): divisor：除数对应的BigDecimal对象；scale:精确的位数；roundingMode取舍模式</p></blockquote><blockquote><p>小结：Java中小数运算有可能会有精度问题，如果要解决这种精度问题，可以使用BigDecimal</p></blockquote><h1 id="第六章-正则表达式"><a href="#第六章-正则表达式" class="headerlink" title="第六章 正则表达式"></a>第六章 正则表达式</h1><h2 id="6-1-正则表达式的概念及演示"><a href="#6-1-正则表达式的概念及演示" class="headerlink" title="6.1 正则表达式的概念及演示"></a>6.1 正则表达式的概念及演示</h2><ul><li>在Java中，我们经常需要验证一些字符串，例如：年龄必须是2位的数字、用户名必须是8位长度而且只能包含大小写字母、数字等。正则表达式就是用来验证各种字符串的规则。它内部描述了一些规则，我们可以验证用户输入的字符串是否匹配这个规则。</li><li>先看一个不使用正则表达式验证的例子：下面的程序让用户输入一个QQ号码，我们要验证：<ul><li>QQ号码必须是5–15位长度</li><li>而且必须全部是数字</li><li>而且首位不能为0</li></ul></li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);                System.out.println(&quot;请输入你的QQ号码：&quot;);        String qq = sc.next();                System.out.println(checkQQ(qq));    &#125;    //我们自己编写代码，验证QQ号码    private static boolean checkQQ(String qq) &#123;        //1.验证5--15位        if(qq.length() &lt; 5 || qq.length() &gt; 15)&#123;            return false;        &#125;        //2.必须都是数字；        for(int i = 0;i &lt; qq.length() ; i++)&#123;            char c = qq.charAt(i);            if(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)&#123;                return false;            &#125;        &#125;        //3.首位不能是0；        char c = qq.charAt(0);        if(c == &#39;0&#39;)&#123;            return false;        &#125;        return true;//验证通过    &#125;    &#125;</code></pre><ul><li>使用正则表达式验证：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);                System.out.println(&quot;请输入你的QQ号码：&quot;);        String qq = sc.next();                System.out.println(checkQQ2(qq));    &#125;    //使用正则表达式验证    private static boolean checkQQ2(String qq)&#123;        String regex = &quot;[1-9]\\d&#123;4,14&#125;&quot;;//正则表达式        return qq.matches(regex);    &#125;&#125;</code></pre><p>上面程序checkQQ2()方法中String类型的变量regex就存储了一个”正则表达式 “，而这个正则表达式就描述了我们需要的三个规则。matches()方法是String类的一个方法，用于接收一个正则表达式，并将”本对象”与参数”正则表达式”进行匹配，如果本对象符合正则表达式的规则，则返回true，否则返回false。</p><p><strong>我们接下来就重点学习怎样写正则表达式</strong></p><h2 id="6-2-正则表达式-字符类"><a href="#6-2-正则表达式-字符类" class="headerlink" title="6.2 正则表达式-字符类"></a>6.2 正则表达式-字符类</h2><ul><li>语法示例：</li></ul><ol><li>[abc]：代表a或者b，或者c字符中的一个。</li><li>[^abc]：代表除a,b,c以外的任何字符。</li><li>[a-z]：代表a-z的所有小写字符中的一个。</li><li>[A-Z]：代表A-Z的所有大写字符中的一个。</li><li>[0-9]：代表0-9之间的某一个数字字符。</li><li>[a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。</li><li>[a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。 </li></ol><ul><li>代码示例：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;ead&quot;;                //1.验证str是否以h开头，以d结尾，中间是a,e,i,o,u中某个字符        String regex = &quot;h[aeiou]d&quot;;        System.out.println(&quot;1.&quot; + str.matches(regex));                //2.验证str是否以h开头，以d结尾，中间不是a,e,i,o,u中的某个字符        regex = &quot;h[^aeiou]d&quot;;        System.out.println(&quot;2.&quot; +  str.matches(regex));                //3.验证str是否a-z的任何一个小写字符开头，后跟ad        regex = &quot;[a-z]ad&quot;;        System.out.println(&quot;3.&quot; + str.matches(regex));                //4.验证str是否以a-d或者m-p之间某个字符开头，后跟ad        regex = &quot;[[a-d][m-p]]ad&quot;;        System.out.println(&quot;4.&quot; + str.matches(regex));    &#125;&#125;</code></pre><h2 id="6-3-正则表达式-逻辑运算符"><a href="#6-3-正则表达式-逻辑运算符" class="headerlink" title="6.3 正则表达式-逻辑运算符"></a>6.3 正则表达式-逻辑运算符</h2><ul><li>语法示例：<ol><li>&amp;&amp;：并且</li><li>|    ：或者</li></ol></li><li>代码示例：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;had&quot;;                //1.要求字符串是小写辅音字符开头，后跟ad        String regex = &quot;[a-z&amp;&amp;[^aeiou]]ad&quot;;        System.out.println(&quot;1.&quot; + str.matches(regex));                //2.要求字符串是aeiou中的某个字符开头，后跟ad        regex = &quot;[a|e|i|o|u]ad&quot;;//这种写法相当于：regex = &quot;[aeiou]ad&quot;;        System.out.println(&quot;2.&quot; + str.matches(regex));    &#125;&#125;</code></pre><h2 id="6-4-正则表达式-预定义字符"><a href="#6-4-正则表达式-预定义字符" class="headerlink" title="6.4 正则表达式-预定义字符"></a>6.4 正则表达式-预定义字符</h2><ul><li>语法示例：<ol><li>“.” ： 匹配任何字符。</li><li>“\d”：任何数字[0-9]的简写；</li><li>“\D”：任何非数字[^0-9]的简写；</li><li>“\s”： 空白字符：[ \t\n\x0B\f\r] 的简写</li><li>“\S”： 非空白字符：[^\s] 的简写</li><li>“\w”：单词字符：[a-zA-Z_0-9]的简写</li><li>“\W”：非单词字符：[^\w]</li></ol></li><li>代码示例：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;258&quot;;                //1.验证str是否3位数字        String regex = &quot;\\d\\d\\d&quot;;        System.out.println(&quot;1.&quot; + str.matches(regex));                //2.验证手机号：1开头，第二位：3/5/8，剩下9位都是0-9的数字        str = &quot;13513153355&quot;;//要验证的字符串        regex = &quot;1[358]\\d\\d\\d\\d\\d\\d\\d\\d\\d&quot;;//正则表达式        System.out.println(&quot;2.&quot; + str.matches(regex));                //3.验证字符串是否以h开头，以d结尾，中间是任何字符        str = &quot;had&quot;;//要验证的字符串        regex = &quot;h.d&quot;;//正则表达式        System.out.println(&quot;3.&quot; + str.matches(regex));                //4.验证str是否是：had.        str = &quot;had.&quot;;//要验证的字符串        regex = &quot;had\\.&quot;;//\\.代表&#39;.&#39;符号，因为.在正则中被预定义为&quot;任意字符&quot;，不能直接使用        System.out.println(&quot;4.&quot; + str.matches(regex));            &#125;&#125;</code></pre><h2 id="6-5-正则表达式-数量词"><a href="#6-5-正则表达式-数量词" class="headerlink" title="6.5 正则表达式-数量词"></a>6.5 正则表达式-数量词</h2><ul><li>语法示例：<ol><li>X? : 0次或1次</li><li>X* : 0次到多次</li><li>X+ : 1次或多次</li><li>X{n} : 恰好n次</li><li>X{n,} : 至少n次</li><li>X{n,m}: n到m次(n和m都是包含的)</li></ol></li><li>代码示例：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;&quot;;                //1.验证str是否是三位数字        str = &quot;012&quot;;        String regex = &quot;\\d&#123;3&#125;&quot;;        System.out.println(&quot;1.&quot; + str.matches(regex));                //2.验证str是否是多位数字        str = &quot;88932054782342&quot;;        regex = &quot;\\d+&quot;;        System.out.println(&quot;2.&quot; + str.matches(regex));                //3.验证str是否是手机号：        str = &quot;13813183388&quot;;        regex = &quot;1[358]\\d&#123;9&#125;&quot;;        System.out.println(&quot;3.&quot; + str.matches(regex));                //4.验证小数:必须出现小数点，但是只能出现1次        String s2 = &quot;3.1&quot;;        regex = &quot;\\d*\\.&#123;1&#125;\\d+&quot;;        System.out.println(&quot;4.&quot; + s2.matches(regex));                //5.验证小数：小数点可以不出现，也可以出现1次        regex = &quot;\\d+\\.?\\d+&quot;;        System.out.println(&quot;5.&quot; + s2.matches(regex));                //6.验证小数：要求匹配：3、3.、3.14、+3.14、-3.        s2 = &quot;-3.&quot;;        regex = &quot;[+-]\\d+\\.?\\d*&quot;;        System.out.println(&quot;6.&quot; + s2.matches(regex));                //7.验证qq号码：1).5--15位；2).全部是数字;3).第一位不是0        s2 = &quot;1695827736&quot;;        regex = &quot;[1-9]\\d&#123;4,14&#125;&quot;;        System.out.println(&quot;7.&quot; + s2.matches(regex));    &#125;&#125;</code></pre><h2 id="6-6-正则表达式-分组括号"><a href="#6-6-正则表达式-分组括号" class="headerlink" title="6.6 正则表达式-分组括号( )"></a>6.6 正则表达式-分组括号( )</h2><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;DG8FV-B9TKY-FRT9J-99899-XPQ4G&quot;;                //验证这个序列号：分为5组，每组之间使用-隔开，每组由5位A-Z或者0-9的字符组成        String regex = &quot;([A-Z0-9]&#123;5&#125;-)&#123;4&#125;[A-Z0-9]&#123;5&#125;&quot;;        System.out.println(str.matches(regex));    &#125;&#125;</code></pre><h2 id="6-7-String的split方法中使用正则表达式"><a href="#6-7-String的split方法中使用正则表达式" class="headerlink" title="6.7 String的split方法中使用正则表达式"></a>6.7 String的split方法中使用正则表达式</h2><ul><li><p>String类的split()方法原型：</p><pre><code class="java">public String[] split(String regex)//参数regex就是一个正则表达式。可以将当前字符串中匹配regex正则表达式的符号作为&quot;分隔符&quot;来切割字符串。</code></pre></li><li><p>代码示例：</p></li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;18  4 567       99     56&quot;;        String[] strArray = str.split(&quot; +&quot;);        for (int i = 0; i &lt; strArray.length; i++) &#123;            System.out.println(strArray[i]);        &#125;    &#125;&#125;</code></pre><h2 id="6-8-String类的replaceAll方法中使用正则表达式"><a href="#6-8-String类的replaceAll方法中使用正则表达式" class="headerlink" title="6.8 String类的replaceAll方法中使用正则表达式"></a>6.8 String类的replaceAll方法中使用正则表达式</h2><ul><li>String类的replaceAll()方法原型：</li></ul><pre><code class="java">public String replaceAll(String regex,String newStr)//参数regex就是一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。</code></pre><ul><li>代码示例：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        //将下面字符串中的&quot;数字&quot;替换为&quot;*&quot;        String str = &quot;jfdk432jfdk2jk24354j47jk5l31324&quot;;        System.out.println(str.replaceAll(&quot;\\d+&quot;, &quot;*&quot;));    &#125;&#125;</code></pre><h1 id="第七章-包装类"><a href="#第七章-包装类" class="headerlink" title="第七章  包装类"></a>第七章  包装类</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="7-2-Integer类"><a href="#7-2-Integer类" class="headerlink" title="7.2 Integer类"></a>7.2 Integer类</h2><ul><li><p>Integer类概述</p><p>包装一个对象中的原始类型 int 的值</p></li><li><p>Integer类构造方法及静态方法</p></li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Integer(int   value)</td><td>根据 int 值创建 Integer 对象(过时)</td></tr><tr><td>public Integer(String s)</td><td>根据 String 值创建 Integer 对象(过时)</td></tr><tr><td>public static Integer valueOf(int i)</td><td>返回表示指定的 int 值的 Integer   实例</td></tr><tr><td>public static Integer valueOf(String s)</td><td>返回保存指定String值的 Integer 对象</td></tr></tbody></table><ul><li>示例代码</li></ul><pre><code class="java">public class IntegerDemo &#123;    public static void main(String[] args) &#123;        //public Integer(int value)：根据 int 值创建 Integer 对象(过时)        Integer i1 = new Integer(100);        System.out.println(i1);        //public Integer(String s)：根据 String 值创建 Integer 对象(过时)        Integer i2 = new Integer(&quot;100&quot;);        //Integer i2 = new Integer(&quot;abc&quot;); //NumberFormatException        System.out.println(i2);        System.out.println(&quot;--------&quot;);        //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例        Integer i3 = Integer.valueOf(100);        System.out.println(i3);        //public static Integer valueOf(String s)：返回保存指定String值的Integer对象         Integer i4 = Integer.valueOf(&quot;100&quot;);        System.out.println(i4);    &#125;&#125;</code></pre><h2 id="7-3-装箱与拆箱"><a href="#7-3-装箱与拆箱" class="headerlink" title="7.3 装箱与拆箱"></a>7.3 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</li><li><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</li></ul><p>用Integer与 int为例：（看懂代码即可）</p><p>基本数值—-&gt;包装对象</p><pre><code class="java">Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法</code></pre><p>包装对象—-&gt;基本数值</p><pre><code class="java">int num = i.intValue();</code></pre><h2 id="7-4-自动装箱与自动拆箱"><a href="#7-4-自动装箱与自动拆箱" class="headerlink" title="7.4 自动装箱与自动拆箱"></a>7.4 自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p><pre><code class="java">Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。</code></pre><h2 id="7-5-基本类型与字符串之间的转换"><a href="#7-5-基本类型与字符串之间的转换" class="headerlink" title="7.5 基本类型与字符串之间的转换"></a>7.5 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><ul><li>转换方式</li><li>方式一：直接在数字后加一个空字符串</li><li>方式二：通过String类静态方法valueOf()</li><li>示例代码</li></ul><pre><code class="java">public class IntegerDemo &#123;    public static void main(String[] args) &#123;        //int --- String        int number = 100;        //方式1        String s1 = number + &quot;&quot;;        System.out.println(s1);        //方式2        //public static String valueOf(int i)        String s2 = String.valueOf(number);        System.out.println(s2);        System.out.println(&quot;--------&quot;);    &#125;&#125;</code></pre><h3 id="String转换成基本类型"><a href="#String转换成基本类型" class="headerlink" title="String转换成基本类型"></a>String转换成基本类型</h3><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><strong><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</strong></li><li><strong><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</strong></li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p><ul><li>转换方式<ul><li>方式一：先将字符串数字转成Integer，再调用valueOf()方法</li><li>方式二：通过Integer静态方法parseInt()进行转换</li></ul></li><li>示例代码</li></ul><pre><code class="java">public class IntegerDemo &#123;    public static void main(String[] args) &#123;        //String --- int        String s = &quot;100&quot;;        //方式1：String --- Integer --- int        Integer i = Integer.valueOf(s);        //public int intValue()        int x = i.intValue();        System.out.println(x);        //方式2        //public static int parseInt(String s)        int y = Integer.parseInt(s);        System.out.println(y);    &#125;&#125;</code></pre><blockquote><p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote><h1 id="第八章-泛型（难点）"><a href="#第八章-泛型（难点）" class="headerlink" title="第八章 泛型（难点）"></a>第八章 泛型（难点）</h1><h2 id="8-1-泛型概述"><a href="#8-1-泛型概述" class="headerlink" title="8.1  泛型概述"></a>8.1  泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><p>大家观察下面代码：</p><pre><code class="java">public class GenericDemo &#123;    public static void main(String[] args) &#123;        Collection coll = new ArrayList();        coll.add(&quot;abc&quot;);        coll.add(&quot;itcast&quot;);        coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放        Iterator it = coll.iterator();        while(it.hasNext())&#123;            //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型            String str = (String) it.next();            System.out.println(str.length());        &#125;    &#125;&#125;</code></pre><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h2 id="8-2-使用泛型的好处"><a href="#8-2-使用泛型的好处" class="headerlink" title="8.2  使用泛型的好处"></a>8.2  使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>通过我们如下代码体验一下：</p><pre><code class="java">public class GenericDemo2 &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;abc&quot;);        list.add(&quot;itcast&quot;);        // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错        // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型        Iterator&lt;String&gt; it = list.iterator();        while(it.hasNext())&#123;            String str = it.next();            //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型            System.out.println(str.length());        &#125;    &#125;&#125;</code></pre><blockquote><p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p></blockquote><h2 id="8-3-泛型的定义与使用"><a href="#8-3-泛型的定义与使用" class="headerlink" title="8.3  泛型的定义与使用"></a>8.3  泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><pre><code>修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</code></pre><p>例如，API中的ArrayList集合：</p><p>泛型在定义的时候不具体，使用的时候才变得具体。在使用的时候确定泛型的具体数据类型。</p><pre><code class="java">class ArrayList&lt;E&gt;&#123;     public boolean add(E e)&#123; &#125;    public E get(int index)&#123; &#125;       ....&#125;</code></pre><p>使用泛型： 即什么时候确定泛型。</p><p><strong>在创建对象的时候确定泛型</strong></p><p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p><pre><code class="java">class ArrayList&lt;String&gt;&#123;      public boolean add(String e)&#123; &#125;     public String get(int index)&#123;  &#125;     ...&#125;</code></pre><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><pre><code class="java">class ArrayList&lt;Integer&gt; &#123;      public boolean add(Integer e) &#123; &#125;     public Integer get(int index) &#123;  &#125;     ...&#125;</code></pre><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><pre><code>修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</code></pre><p>例如，</p><pre><code class="java">public class MyGenericMethod &#123;          public &lt;MVP&gt; void show(MVP mvp) &#123;        System.out.println(mvp.getClass());    &#125;        public &lt;MVP&gt; MVP show2(MVP mvp) &#123;            return mvp;    &#125;&#125;</code></pre><p><strong>调用方法时，确定泛型的类型</strong></p><pre><code class="java">public class GenericMethodDemo &#123;    public static void main(String[] args) &#123;        // 创建对象        MyGenericMethod mm = new MyGenericMethod();        // 演示看方法提示        mm.show(&quot;aaa&quot;);        mm.show(123);        mm.show(12.45);    &#125;&#125;</code></pre><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><pre><code>修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</code></pre><p>例如，</p><pre><code class="java">public interface MyGenericInterface&lt;E&gt;&#123;    public abstract void add(E e);        public abstract E getE();  &#125;</code></pre><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如</p><pre><code class="java">public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123;    @Override    public void add(String e) &#123;        // 省略...    &#125;    @Override    public String getE() &#123;        return null;    &#125;&#125;</code></pre><p>此时，泛型E的值就是String类型。</p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p> 例如</p><pre><code class="java">public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123;    @Override    public void add(E e) &#123;            // 省略...    &#125;    @Override    public E getE() &#123;        return null;    &#125;&#125;</code></pre><p>确定泛型：</p><pre><code class="java">/* * 使用 */public class GenericInterface &#123;    public static void main(String[] args) &#123;        MyImp2&lt;String&gt;  my = new MyImp2&lt;String&gt;();          my.add(&quot;aa&quot;);    &#125;&#125;</code></pre><h2 id="8-4-泛型通配符"><a href="#8-4-泛型通配符" class="headerlink" title="8.4  泛型通配符"></a>8.4  泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h3 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h3><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><pre><code class="java">public static void main(String[] args) &#123;    Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;();    getElement(list1);    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();    getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;// ？代表可以接收任意类型泛型不存在继承关系 Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;();这种是错误的</code></pre><h3 id="通配符高级使用"><a href="#通配符高级使用" class="headerlink" title="通配符高级使用"></a>通配符高级使用</h3><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><pre><code class="java">public static void main(String[] args) &#123;    Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();    Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;();    Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;();        getElement(list1);    getElement(list2);//报错    getElement(list3);    getElement(list4);//报错      getElement2(list1);//报错    getElement2(list2);//报错    getElement2(list3);    getElement2(list4);  &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;</code></pre><h1 id="第九章-Collection集合"><a href="#第九章-Collection集合" class="headerlink" title="第九章 Collection集合"></a>第九章 Collection集合</h1><h2 id="9-1-集合概述"><a href="#9-1-集合概述" class="headerlink" title="9.1 集合概述"></a>9.1 集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</p><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有什么区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储任意类型数据。集合存储的都是引用数据类型。如果想存储基本类型数据需要存储对应的包装类型。</li></ul><h2 id="9-2-集合常用类的继承体系"><a href="#9-2-集合常用类的继承体系" class="headerlink" title="9.2  集合常用类的继承体系"></a>9.2  集合常用类的继承体系</h2><p>Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.LinkedHashSet</code>。</p><p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述集合常用类的继承体系</p><p><img src="/img/java/imgs4%5CCollection%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE.jpg"></p><p>注意:这张图只是我们常用的集合有这些，不是说就只有这些集合。</p><p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p><h2 id="9-3-Collection-常用API"><a href="#9-3-Collection-常用API" class="headerlink" title="9.3 Collection 常用API"></a>9.3 Collection 常用API</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(Object obj)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中</li></ul><blockquote><p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。!</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day04【常用API、正则表达式，泛型、Collection集合API】&quot;&gt;&lt;a href=&quot;#day04【常用API、正则表达式，泛型、Collection集合API】&quot; class=&quot;headerlink&quot; title=&quot;day04【常用API、正则表达式，</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java进阶13天资料" scheme="http://example.com/tags/java%E8%BF%9B%E9%98%B613%E5%A4%A9%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Day03</title>
    <link href="http://example.com/2021/09/05/JAVA/day03%E3%80%90%E5%A4%9A%E6%80%81%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8CObject%E7%B1%BB%E3%80%91/"/>
    <id>http://example.com/2021/09/05/JAVA/day03%E3%80%90%E5%A4%9A%E6%80%81%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8CObject%E7%B1%BB%E3%80%91/</id>
    <published>2021-09-05T02:32:46.000Z</published>
    <updated>2021-09-05T03:04:04.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day03【多态、包、权限修饰符、内部类，Object类-Date类】"><a href="#day03【多态、包、权限修饰符、内部类，Object类-Date类】" class="headerlink" title="day03【多态、包、权限修饰符、内部类，Object类,Date类】"></a>day03【多态、包、权限修饰符、内部类，Object类,Date类】</h1><h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><ul><li><strong>多态（重点）</strong>：<ul><li>面向对象的三大特征之一：封装，继承，多态。</li></ul></li><li>代码块<ul><li><strong>已经讲完了</strong>。</li></ul></li><li>包  <ul><li>包我们介绍一下就好了</li></ul></li><li>权限修饰符<ul><li>介绍一下： private -&gt; 缺省 -&gt; protected -&gt; public</li></ul></li><li>内部类(很抽象)<ul><li>知识完整性（5大成分之一）</li><li>只关注语法即可，实际开发几乎无用，主要是sun公司自己用，我们能理解即可！！</li><li><strong>匿名内部类（重点,必须掌握的）</strong></li></ul></li><li>Object类<ul><li>API使用工程师。90%的技术都是别人写好的.我们直接调用。</li><li>从这里开始，几乎没有语法了，全部是别人写好的技术我们直接调用即可，调用API。</li><li>都是别人做好的技术，我们拿来用： <ul><li>MySQL  , JDBC, Mybatis,HTML , CSS , JS  , JQuery ,UI框架 ， WEB开发， Servlet , JSP</li><li>Tomcat , Spring家族的技术（Spring , Spring MVC  Spring Data JPA ） , Spring Boot</li><li>Spring Cloud</li></ul></li></ul></li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><p><input disabled="" type="checkbox">  能够说出使用多态的前提条件</p><ul><li><input disabled="" type="checkbox"> <pre><code>（1）必须有继承或者实现关系！（2）必须存在父类类的变量引用子类类型的对象！（3）存在方法重写！</code></pre></li></ul></li><li><p><input disabled="" type="checkbox">  理解多态的向上转型（自动类型转换）</p><ul><li><input disabled="" type="checkbox"> 自动类型转换。Animal a = new Cat();</li></ul></li><li><p><input disabled="" type="checkbox">  理解多态的向下转型</p><ul><li><input disabled="" type="checkbox"> 强制类型转换。</li><li><input disabled="" type="checkbox"> Animal a= new Cat();</li><li><input disabled="" type="checkbox"> Cat c = (Cat)a;</li></ul></li><li><p><input disabled="" type="checkbox">  能够完成笔记本案例</p><ul><li><input disabled="" type="checkbox"> 参见代码！</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出权限修饰符作用范</p><ul><li><input disabled="" type="checkbox"> <strong>private   本类</strong></li><li><input disabled="" type="checkbox"> <strong>缺省 本类 本包其他类</strong></li><li><input disabled="" type="checkbox"> <strong>protected 本类 本包其他类 其他包下的子类中</strong></li><li><input disabled="" type="checkbox"> <strong>public     任何地方</strong></li></ul></li><li><p><input disabled="" type="checkbox">  说出内部类的概念</p><ul><li><input disabled="" type="checkbox"> 定义在一个类里面的类就是内部类。</li></ul></li><li><p><input disabled="" type="checkbox">  能够说出Object类的特点</p><ul><li><input disabled="" type="checkbox"> 祖宗类，它的功能，全部类都 可以使用！！</li></ul></li><li><p><input disabled="" type="checkbox">  能够重写Object类的toString方法</p><ul><li><input disabled="" type="checkbox"> 自动生成：重写返回对象内容输出。</li></ul></li><li><p><input disabled="" type="checkbox">  能够重写Object类的equals方法</p><ul><li><input disabled="" type="checkbox"> 自动生成：比较对象的内容，制定比较规则。</li></ul></li></ul><h1 id="第一章-多态-重点"><a href="#第一章-多态-重点" class="headerlink" title="第一章 多态[重点]"></a>第一章 多态[重点]</h1><h2 id="1-1-多态的形式"><a href="#1-1-多态的形式" class="headerlink" title="1.1 多态的形式"></a>1.1 多态的形式</h2><p><strong>多态是继封装、继承之后，面向对象的第三大特性。</strong></p><p><strong>多态是出现在继承或者实现关系中的</strong>。</p><p><strong>多态体现的格式</strong>：</p><pre><code class="java">父类类型 变量名 = new 子类/实现类构造器;变量名.方法名();</code></pre><p><strong>多态的前提</strong>：有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。</p><h2 id="1-2-多态的案例演示"><a href="#1-2-多态的案例演示" class="headerlink" title="1.2 多态的案例演示"></a>1.2 多态的案例演示</h2><p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。如果子类没有重写该方法，就会调用父类的该方法</strong>。</p><p>总结起来就是：<strong>编译看左边，运行看右边。</strong></p><p>代码如下：</p><p>定义父类：</p><pre><code class="java">public class Animal &#123;      public void eat()｛        System.out.println(&quot;动物吃东西！&quot;)    ｝&#125;  </code></pre><p>定义子类：</p><pre><code class="java">class Cat extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃鱼&quot;);      &#125;  &#125;  class Dog extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃骨头&quot;);      &#125;  &#125;</code></pre><p>定义测试类：</p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        // 多态形式，创建对象        Animal a1 = new Cat();        // 调用的是 Cat 的 eat        a1.eat();        // 多态形式，创建对象        Animal a2 = new Dog();        // 调用的是 Dog 的 eat        a2.eat();    &#125;  &#125;</code></pre><h2 id="1-3-多态的定义和前提"><a href="#1-3-多态的定义和前提" class="headerlink" title="1.3 多态的定义和前提"></a>1.3 多态的定义和前提</h2><p><strong>多态</strong>： 是指同一行为，具有多个不同表现形式。</p><p>从上面案例可以看出，Cat和Dog都是动物，都是吃这一行为，但是出现的效果（表现形式）是不一样的。</p><p> <strong>前提【重点】</strong></p><ol><li><p>继承或者实现【二选一】</p></li><li><p>方法的重写【意义体现：不重写，无意义】</p></li><li><p>父类引用指向子类对象【格式体现】</p><blockquote><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p></blockquote></li></ol><h2 id="1-4-多态的好处"><a href="#1-4-多态的好处" class="headerlink" title="1.4 多态的好处"></a>1.4 多态的好处</h2><p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下：</p><p>定义父类：</p><pre><code class="java">public abstract class Animal &#123;      public abstract void eat();  &#125;  </code></pre><p>定义子类：</p><pre><code class="java">class Cat extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃鱼&quot;);      &#125;  &#125;  class Dog extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃骨头&quot;);      &#125;  &#125;</code></pre><p>定义测试类：</p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        // 多态形式，创建对象        Cat c = new Cat();          Dog d = new Dog();         // 调用showCatEat         showCatEat(c);        // 调用showDogEat         showDogEat(d);         /*        以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代        而执行效果一致        */        showAnimalEat(c);        showAnimalEat(d);     &#125;    public static void showCatEat (Cat c)&#123;        c.eat();     &#125;    public static void showDogEat (Dog d)&#123;        d.eat();    &#125;    public static void showAnimalEat (Animal a)&#123;        a.eat();    &#125;&#125;</code></pre><p>由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。</p><p>当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。</p><p>不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。<strong>从而实现了实现类的自动切换。</strong></p><p>所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。</p><h2 id="1-5-多态的弊端"><a href="#1-5-多态的弊端" class="headerlink" title="1.5 多态的弊端"></a>1.5 多态的弊端</h2><p>我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时<strong>多态的写法就无法访问子类独有功能了</strong>。</p><pre><code class="java">class Animal&#123;    public  void eat()｛        System.out.println(&quot;动物吃东西！&quot;)    ｝&#125;class Cat extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃鱼&quot;);      &#125;         public void catchMouse() &#123;          System.out.println(&quot;抓老鼠&quot;);      &#125;  &#125;  class Dog extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃骨头&quot;);      &#125;  &#125;class Test&#123;    public static void main(String[] args)&#123;        Animal a = new Cat();        a.eat();        a.catchMouse();//编译报错，编译看左边，Animal没有这个方法    &#125;&#125;</code></pre><h2 id="1-6-引用类型转换"><a href="#1-6-引用类型转换" class="headerlink" title="1.6 引用类型转换"></a>1.6 引用类型转换</h2><h3 id="1-6-1-为什么要转型"><a href="#1-6-1-为什么要转型" class="headerlink" title="1.6.1 为什么要转型"></a>1.6.1 为什么要转型</h3><p><strong>多态的写法就无法访问子类独有功能了。</strong></p><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。</p><p>回顾基本数据类型转换</p><ul><li>自动转换: 范围小的赋值给范围大的.自动完成:double d = 5; </li><li>强制转换: 范围大的赋值给范围小的,强制转换:int i = (int)3.14 </li></ul><p>​     多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。</p><h3 id="1-6-2-向上转型（自动转换）"><a href="#1-6-2-向上转型（自动转换）" class="headerlink" title="1.6.2 向上转型（自动转换）"></a>1.6.2 向上转型（自动转换）</h3><ul><li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。<br>当父类引用指向一个子类对象时，便是向上转型。<br>使用格式：</li></ul><pre><code class="java">父类类型  变量名 = new 子类类型();如：Animal a = new Cat();</code></pre><p><strong>原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。</strong>所以子类范围小可以直接自动转型给父类类型的变量。</p><h3 id="1-6-3-向下转型（强制转换）"><a href="#1-6-3-向下转型（强制转换）" class="headerlink" title="1.6.3 向下转型（强制转换）"></a>1.6.3 向下转型（强制转换）</h3><ul><li><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。<br>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</li></ul><p>使用格式：</p><pre><code class="java">子类类型 变量名 = (子类类型) 父类变量名;如:Aniaml a = new Cat();   Cat c =(Cat) a;  </code></pre><h3 id="1-6-4-案例演示"><a href="#1-6-4-案例演示" class="headerlink" title="1.6.4 案例演示"></a>1.6.4 案例演示</h3><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。</p><p>转型演示，代码如下：</p><p>定义类：</p><pre><code class="java">abstract class Animal &#123;      abstract void eat();  &#125;  class Cat extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃鱼&quot;);      &#125;      public void catchMouse() &#123;          System.out.println(&quot;抓老鼠&quot;);      &#125;  &#125;  class Dog extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃骨头&quot;);      &#125;      public void watchHouse() &#123;          System.out.println(&quot;看家&quot;);      &#125;  &#125;</code></pre><p>定义测试类：</p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        // 向上转型          Animal a = new Cat();          a.eat();                 // 调用的是 Cat 的 eat        // 向下转型          Cat c = (Cat)a;               c.catchMouse();         // 调用的是 Cat 的 catchMouse    &#125;  &#125;</code></pre><h3 id="1-6-5-转型的异常"><a href="#1-6-5-转型的异常" class="headerlink" title="1.6.5 转型的异常"></a>1.6.5 转型的异常</h3><p>转型的过程中，一不小心就会遇到这样的问题，请看如下代码：</p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        // 向上转型          Animal a = new Cat();          a.eat();               // 调用的是 Cat 的 eat        // 向下转型          Dog d = (Dog)a;               d.watchHouse();        // 调用的是 Dog 的 watchHouse 【运行报错】    &#125;  &#125;</code></pre><p>这段代码可以通过编译，但是运行时，却报出了 <code>ClassCastException</code> ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。</p><h3 id="1-6-6-instanceof关键字"><a href="#1-6-6-instanceof关键字" class="headerlink" title="1.6.6 instanceof关键字"></a>1.6.6 instanceof关键字</h3><p>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验，格式如下：</p><pre><code class="java">变量名 instanceof 数据类型 如果变量属于该数据类型或者其子类类型，返回true。如果变量不属于该数据类型或者其子类类型，返回false。</code></pre><p>所以，转换前，我们最好先做一个判断，代码如下：</p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        // 向上转型          Animal a = new Cat();          a.eat();               // 调用的是 Cat 的 eat        // 向下转型          if (a instanceof Cat)&#123;            Cat c = (Cat)a;                   c.catchMouse();        // 调用的是 Cat 的 catchMouse        &#125; else if (a instanceof Dog)&#123;            Dog d = (Dog)a;                   d.watchHouse();       // 调用的是 Dog 的 watchHouse        &#125;    &#125;  &#125;</code></pre><h1 id="第二章-内部类"><a href="#第二章-内部类" class="headerlink" title="第二章 内部类"></a>第二章 内部类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><h3 id="2-1-1-什么是内部类"><a href="#2-1-1-什么是内部类" class="headerlink" title="2.1.1 什么是内部类"></a>2.1.1 什么是内部类</h3><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<strong>内部类</strong>，B则称为<strong>外部类</strong>。可以把内部类理解成寄生，外部类理解成宿主。</p><p>内部类是Java类的五大成份之一，也是我们最后一个需要学习的成份。</p><h3 id="2-1-2-什么时候使用内部类"><a href="#2-1-2-什么时候使用内部类" class="headerlink" title="2.1.2 什么时候使用内部类"></a>2.1.2 什么时候使用内部类</h3><p>一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用</p><ol><li>人里面有一颗心脏。</li><li>汽车内部有一个发动机。</li><li>为了实现更好的封装性。</li></ol><h2 id="2-2-内部类的分类"><a href="#2-2-内部类的分类" class="headerlink" title="2.2 内部类的分类"></a>2.2 内部类的分类</h2><p>按定义的位置来分</p><ol><li><strong>静态内部类</strong>，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)</li><li><strong>实例内部内</strong>，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)</li><li><strong>局部内部类</strong>，类定义在方法内</li><li><strong>匿名内部类</strong>。一般定义在方法中，或者可执行代码中</li></ol><h2 id="2-3-静态内部类"><a href="#2-3-静态内部类" class="headerlink" title="2.3 静态内部类"></a>2.3 静态内部类</h2><p><strong>静态内部类特点</strong>：</p><ul><li>有static修饰的内部类，属于外部类本身的。</li><li>总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。</li><li><strong>拓展</strong>:静态内部类可以直接访问外部类的静态成员。</li></ul><p><strong>内部类的使用格式</strong>：</p><pre><code>外部类.内部类。</code></pre><p><strong>静态内部类对象的创建格式</strong>：</p><pre><code class="java">外部类.内部类  变量 = new  外部类.内部类构造器;</code></pre><p><strong>案例演示</strong>：</p><pre><code class="java">// 外部类：Outer01class Outer01&#123;    private static  String sc_name = &quot;黑马程序&quot;;    // 内部类: Inner01    public static class Inner01&#123;        // 这里面的东西与类是完全一样的。        private String name;        public Inner01(String name) &#123;            this.name = name;        &#125;        public void showName()&#123;            System.out.println(this.name);            // 拓展:静态内部类可以直接访问外部类的静态成员。            System.out.println(sc_name);        &#125;    &#125;&#125;public class InnerClassDemo01 &#123;    public static void main(String[] args) &#123;        // 创建静态内部类对象。        // 外部类.内部类  变量 = new  外部类.内部类构造器;        Outer01.Inner01 in  = new Outer01.Inner01(&quot;张三&quot;);        in.showName();    &#125;&#125;</code></pre><h2 id="2-4-实例内部类"><a href="#2-4-实例内部类" class="headerlink" title="2.4 实例内部类"></a>2.4 实例内部类</h2><p><strong>实例内部类特点</strong>：</p><ul><li>无static修饰的内部类，属于外部类对象的。</li><li>宿主：外部类对象。</li></ul><p><strong>内部类的使用格式</strong>：</p><pre><code class="java"> 外部类.内部类。 // 访问内部类的类型都是用 外部类.内部类</code></pre><p><strong>实例内部类创建对象格式</strong>：</p><pre><code>外部类.内部类 变量 = new 外部类构造器.new 内部类构造器;</code></pre><ul><li><p>拓展1：实例内部类不能定义静态成员。</p></li><li><p>拓展2：实例内部类可以直接访问外部类的私有和静态成员。</p><p><strong>案例演示</strong></p></li></ul><pre><code class="java">public class InnerClassDemo02 &#123;    public static void main(String[] args) &#123;        //  宿主：外部类对象。       // Outer02 out = new Outer02();        // 创建内部类对象。        Outer02.Inner02 in = new Outer02().new Inner02(&quot;张三&quot;);        in.showName();    &#125;&#125;class Outer02&#123;    // 实例内部类，属于外部类对象的。    // 拓展：实例内部类不能定义静态成员。    public class Inner02&#123;        // 这里面的东西与类是完全一样的。        private String name;        public Inner02(String name) &#123;            this.name = name;        &#125;        public void showName()&#123;            System.out.println(this.name);        &#125;    &#125;&#125;</code></pre><h2 id="2-5-实例内部类面试题"><a href="#2-5-实例内部类面试题" class="headerlink" title="2.5 实例内部类面试题"></a>2.5 实例内部类面试题</h2><p>请在?地方向上相应代码,以达到输出的内容</p><p>注意：内部类访问外部类对象的格式是：<strong>外部类名.this</strong></p><pre><code class="java">public class Demo05 &#123;    public static void main(String[] args) &#123;        Body.Heart heart = new Body().new Heart();        heart.jump();    &#125;&#125;class Body &#123;    // 身体    private int weight = 30;    // 在成员位置定义一个类    class Heart &#123;        private int weight = 20;        public void jump() &#123;            int weight = 10;            System.out.println(&quot;心脏在跳动 &quot; + ?);    // 10            System.out.println(&quot;心脏在跳动 &quot; + ?);    // 20            System.out.println(&quot;心脏在跳动 &quot; + ?);    // 30        &#125;    &#125;&#125;</code></pre><h2 id="2-6-局部内部类"><a href="#2-6-局部内部类" class="headerlink" title="2.6 局部内部类"></a>2.6 局部内部类</h2><ul><li><strong>局部内部类</strong> ：定义在<strong>方法中</strong>的类。</li></ul><p>定义格式:</p><pre><code class="java">class 外部类名 &#123;    数据类型 变量名;        修饰符 返回值类型 方法名(参数列表) &#123;        // …        class 内部类 &#123;            // 成员变量            // 成员方法        &#125;    &#125;&#125;</code></pre><blockquote><p>局部内部类编译后仍然是一个独立的类，编译后有$还有一个数字。Chinese$1Chopsticks.class</p></blockquote><h2 id="2-7-匿名内部类【重点】"><a href="#2-7-匿名内部类【重点】" class="headerlink" title="2.7 匿名内部类【重点】"></a>2.7 匿名内部类【重点】</h2><h3 id="2-7-1-概述"><a href="#2-7-1-概述" class="headerlink" title="2.7.1 概述"></a>2.7.1 概述</h3><p><strong>匿名内部类</strong> ：是内部类的简化写法。它的本质是一个<code>带具体实现的</code> <code>父类或者父接口的</code> <code>匿名的</code> <strong>子类对象</strong>。<br>开发中，最常用到的内部类就是匿名内部类了。</p><h3 id="2-7-2-引入"><a href="#2-7-2-引入" class="headerlink" title="2.7.2 引入"></a>2.7.2 引入</h3><p><strong>实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用</strong></p><p><strong>是为了简化代码</strong>。 </p><p>之前我們使用接口时，似乎得做如下几步操作：</p><ol><li>定义子类</li><li>重写接口中的方法</li><li>创建子类对象</li><li>调用重写后的方法</li></ol><pre><code class="java">interface Swim &#123;    public abstract void swimming();&#125;// 1. 定义接口的实现类class Student implements Swim &#123;    // 2. 重写抽象方法    @Override    public void swimming() &#123;        System.out.println(&quot;狗刨式...&quot;);    &#125;&#125;public class Demo07 &#123;    public static void main(String[] args) &#123;        // 3. 创建实现类对象        Student s = new Student();        // 4. 调用方法        s.swimming();    &#125;&#125;</code></pre><p>我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。</p><h3 id="2-7-3-匿名内部类前提和格式"><a href="#2-7-3-匿名内部类前提和格式" class="headerlink" title="2.7.3 匿名内部类前提和格式"></a>2.7.3 匿名内部类前提和格式</h3><p>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p><p><strong>匿名内部类格式</strong></p><pre><code class="java">new 父类名或者接口名()&#123;    // 方法重写    @Override     public void method() &#123;        // 执行语句    &#125;&#125;;</code></pre><h3 id="2-7-4-使用方式"><a href="#2-7-4-使用方式" class="headerlink" title="2.7.4 使用方式"></a>2.7.4 使用方式</h3><p>以接口为例，匿名内部类的使用，代码如下：</p><p>创建匿名内部类，并调用：GUI做界面</p><pre><code class="java">interface Swim &#123;    public abstract void swimming();&#125;public class Demo07 &#123;    public static void main(String[] args) &#123;        // 使用匿名内部类        new Swim() &#123;            @Override            public void swimming() &#123;                System.out.println(&quot;自由泳...&quot;);            &#125;        &#125;.swimming();        // 接口 变量 = new 实现类(); // 多态,走子类的重写方法        Swim s2 = new Swim() &#123;            @Override            public void swimming() &#123;                System.out.println(&quot;蛙泳...&quot;);            &#125;        &#125;;        s2.swimming();        s2.swimming();    &#125;&#125;</code></pre><h3 id="2-7-5-匿名内部类的特点"><a href="#2-7-5-匿名内部类的特点" class="headerlink" title="2.7.5 匿名内部类的特点"></a>2.7.5 匿名内部类的特点</h3><ol><li>定义一个没有名字的内部类</li><li>这个类实现了父类，或者父类接口</li><li>匿名内部类会创建这个没有名字的类的对象</li></ol><h3 id="2-7-6-匿名内部类的使用场景"><a href="#2-7-6-匿名内部类的使用场景" class="headerlink" title="2.7.6 匿名内部类的使用场景"></a>2.7.6 匿名内部类的使用场景</h3><p>通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：</p><pre><code class="java">interface Swim &#123;    public abstract void swimming();&#125;public class Demo07 &#123;    public static void main(String[] args) &#123;        // 普通方式传入对象        // 创建实现类对象        Student s = new Student();                goSwimming(s);        // 匿名内部类使用场景:作为方法参数传递        Swim s3 = new Swim() &#123;            @Override            public void swimming() &#123;                System.out.println(&quot;蝶泳...&quot;);            &#125;        &#125;;        // 传入匿名内部类        goSwimming(s3);        // 完美方案: 一步到位        goSwimming(new Swim() &#123;            public void swimming() &#123;                System.out.println(&quot;大学生, 蛙泳...&quot;);            &#125;        &#125;);        goSwimming(new Swim() &#123;            public void swimming() &#123;                System.out.println(&quot;小学生, 自由泳...&quot;);            &#125;        &#125;);    &#125;    // 定义一个方法,模拟请一些人去游泳    public static void goSwimming(Swim s) &#123;        s.swimming();    &#125;&#125;</code></pre><h1 id="第三章-包和权限修饰符"><a href="#第三章-包和权限修饰符" class="headerlink" title="第三章 包和权限修饰符"></a>第三章 包和权限修饰符</h1><h2 id="3-1-包"><a href="#3-1-包" class="headerlink" title="3.1 包"></a>3.1 包</h2><p>包我们每天建的项目就是在一个目录下，我们每次都会建立一个包，这个包在磁盘下其实就是一个目录。<strong>包是用来分门别类的管理技术，不同的技术类放在不同的包下</strong>，方便管理和维护。</p><p>在IDEA项目中，建包的操作如下：</p><p><img src="/img/java/imgs3/aaa.jpg"></p><p><strong>包名的命名规范</strong>：</p><pre><code>路径名.路径名.xxx.xxx// 例如：com.itheima.oa</code></pre><ul><li>包名一般是公司域名的倒写。例如：黑马是<a href="http://www.itheima.com,包名就可以定义成com.itheima.技术名称./">www.itheima.com,包名就可以定义成com.itheima.技术名称。</a></li><li>包名必须用”.“连接。</li><li>包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。</li></ul><h2 id="3-2-权限修饰符"><a href="#3-2-权限修饰符" class="headerlink" title="3.2 权限修饰符"></a>3.2 权限修饰符</h2><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和缺省（default默认）修饰符的作用。</p><ul><li>public：公共的，所有地方都可以访问。</li><li>protected：当前类 ，当前包，当前类的子类可以访问。</li><li>缺省（没有修饰符）：当前类 ，当前包可以访问。</li><li>private：私有的，当前类可以访问。<br><code>public &gt; protected &gt; 缺省 &gt; private</code></li></ul><h2 id="3-3-不同权限的访问能力"><a href="#3-3-不同权限的访问能力" class="headerlink" title="3.3 不同权限的访问能力"></a>3.3 不同权限的访问能力</h2><table><thead><tr><th></th><th>public</th><th>protected</th><th>缺省（空的）</th><th>private</th></tr></thead><tbody><tr><td>同一类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一包中的类</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不同包的子类</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>不同包中的无关类</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><p>可见，public具有最大权限。private则是最小权限。</p><p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p><ul><li>成员变量使用<code>private</code> ，隐藏细节。</li><li>构造方法使用<code> public</code> ，方便创建对象。</li><li>成员方法使用<code>public</code> ，方便调用方法。</li></ul><blockquote><p>小贴士：不加权限修饰符，就是default权限</p></blockquote><h1 id="第四章-Object类"><a href="#第四章-Object类" class="headerlink" title="第四章 Object类"></a>第四章 Object类</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p><p>如果一个类没有特别指定父类，    那么默认则继承自Object类。例如：</p><pre><code class="java">public class MyClass /*extends Object*/ &#123;      // ...&#125;</code></pre><p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><h2 id="4-2-toString方法"><a href="#4-2-toString方法" class="headerlink" title="4.2 toString方法"></a>4.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p><pre><code class="java">public class Person &#123;      private String name;    private int age;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; + &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; + &quot;, age=&quot; + age + &#39;&#125;&#39;;    &#125;    // 省略构造器与Getter Setter&#125;</code></pre><p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。如下图所示：</p><p><img src="/img/java/imgs3%5CtoString%E6%96%B9%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E9%87%8D%E5%86%99.bmp" alt="toString方法的自动重写"></p><blockquote><p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p></blockquote><h2 id="4-3-equals方法"><a href="#4-3-equals方法" class="headerlink" title="4.3 equals方法"></a>4.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p><h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p><h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p><pre><code class="java">import java.util.Objects;public class Person &#123;        private String name;    private int age;        @Override    public boolean equals(Object o) &#123;        // 如果对象地址一样，则认为相同        if (this == o)            return true;        // 如果参数为空，或者类型信息不一样，则认为不同        if (o == null || getClass() != o.getClass())            return false;        // 转换为当前类型        Person person = (Person) o;        // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果        return age == person.age &amp;&amp; Objects.equals(name, person.name);    &#125;&#125;</code></pre><p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成。如下图所示：</p><p><img src="/img/java/imgs3%5Cequals%E6%96%B9%E6%B3%951.png"></p><p><img src="/img/java/imgs3%5Cequals%E6%96%B9%E6%B3%952.png"></p><p><img src="/img/java/imgs3%5Cequals%E6%96%B9%E6%B3%953.png"></p><blockquote><p>tips：Object类当中的hashCode等其他方法，今后学习。</p></blockquote><h1 id="第五章-Objects类"><a href="#第五章-Objects类" class="headerlink" title="第五章 Objects类"></a>第五章 Objects类</h1><p>Objects类是对象工具类，它里面的的方法都是用来操作对象的。</p><h2 id="5-1-equals方法"><a href="#5-1-equals方法" class="headerlink" title="5.1 equals方法"></a>5.1 equals方法</h2><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p><p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p><p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p><ul><li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li></ul><p>我们可以查看一下源码，学习一下：</p><pre><code class="java">public static boolean equals(Object a, Object b) &#123;      return (a == b) || (a != null &amp;&amp; a.equals(b));  </code></pre><h2 id="5-2-isNull"><a href="#5-2-isNull" class="headerlink" title="5.2 isNull"></a>5.2 isNull</h2><p>static boolean isNull(Object obj) 判断对象是否为null，如果为null返回true。</p><pre><code class="java">Student s1 = null;Student s2 = new Student(&quot;蔡徐坤&quot;, 22);// static boolean isNull(Object obj) 判断对象是否为null,如果为null返回trueSystem.out.println(Objects.isNull(s1)); // trueSystem.out.println(Objects.isNull(s2)); // false</code></pre><h1 id="第六章-Date类"><a href="#第六章-Date类" class="headerlink" title="第六章 Date类"></a>第六章 Date类</h1><h2 id="6-1-Date概述"><a href="#6-1-Date概述" class="headerlink" title="6.1 Date概述"></a>6.1 Date概述</h2><p>java.util.Date`类 表示特定的瞬间，精确到毫秒。</p><p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，我们重点看以下两个构造函数</p><ul><li><code>public Date()</code>：从运行程序的此时此刻到时间原点经历的毫秒值,转换成Date对象，分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li><code>public Date(long date)</code>：将指定参数的毫秒值date,转换成Date对象，分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li></ul><blockquote><p>tips: 由于中国处于东八区（GMT+08:00）是比世界协调时间/格林尼治时间（GMT）快8小时的时区，当格林尼治标准时间为0:00时，东八区的标准时间为08:00。</p></blockquote><p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p><pre><code class="java">import java.util.Date;public class Demo01Date &#123;    public static void main(String[] args) &#123;        // 创建日期对象，把当前的时间        System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2020        // 创建日期对象，把当前的毫秒值转成日期对象        System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970    &#125;&#125;</code></pre><blockquote><p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p></blockquote><h2 id="6-2-Date常用方法"><a href="#6-2-Date常用方法" class="headerlink" title="6.2 Date常用方法"></a>6.2 Date常用方法</h2><p>Date类中的多数方法已经过时，常用的方法有：</p><ul><li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li><li><code>public void setTime(long time)</code> 把方法参数给定的毫秒值设置给日期对象</li></ul><p>示例代码</p><pre><code class="java">public class DateDemo02 &#123;    public static void main(String[] args) &#123;        //创建日期对象        Date d = new Date();                //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值        //System.out.println(d.getTime());        //System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + &quot;年&quot;);        //public void setTime(long time):设置时间，给的是毫秒值        //long time = 1000*60*60;        long time = System.currentTimeMillis();        d.setTime(time);        System.out.println(d);    &#125;&#125;</code></pre><blockquote><p>小结：Date表示特定的时间瞬间，我们可以使用Date对象对时间进行操作。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day03【多态、包、权限修饰符、内部类，Object类-Date类】&quot;&gt;&lt;a href=&quot;#day03【多态、包、权限修饰符、内部类，Object类-Date类】&quot; class=&quot;headerlink&quot; title=&quot;day03【多态、包、权限修饰符、内部类，O</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java进阶13天资料" scheme="http://example.com/tags/java%E8%BF%9B%E9%98%B613%E5%A4%A9%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Day02</title>
    <link href="http://example.com/2021/09/05/JAVA/day02-%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81final%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E6%9E%9A%E4%B8%BE/"/>
    <id>http://example.com/2021/09/05/JAVA/day02-%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81final%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E6%9E%9A%E4%B8%BE/</id>
    <published>2021-09-05T02:31:46.000Z</published>
    <updated>2021-09-05T03:02:39.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day02【抽象类，接口、代码块、final、单例、枚举】"><a href="#day02【抽象类，接口、代码块、final、单例、枚举】" class="headerlink" title="day02【抽象类，接口、代码块、final、单例、枚举】"></a>day02【抽象类，接口、代码块、final、单例、枚举】</h1><h2 id="今日内容-记住语法"><a href="#今日内容-记住语法" class="headerlink" title="今日内容(记住语法)"></a>今日内容(记住语法)</h2><ul><li>抽象类<ul><li>拥有抽象方法的类就是抽象类。</li><li>抽象方法：是只有方法签名没有方法体，必须用abstract修饰。</li><li>抽象类本身也要用abstract修饰的，作用是让子类继承，子类一定要重写抽象方法。</li><li>模板思想，设计模板模式。</li></ul></li><li>接口<ul><li>更加彻底的抽象，接口中全部是抽象方法和常量（JDK1.8之后）</li><li>接口体现的是规范思想，实现接口的类必须重写完接口的全部抽象方法，否则这个类必须是抽象类。 </li><li>JDK 1.8之后的接口新增了三个方法。接口不再纯洁。</li></ul></li><li>代码块（成员变量，方法，构造器，代码块，内部类）</li><li>final关键字<ul><li>final是最终的意思。可以修饰类，变量，和方法。</li><li>修饰类：类不能被继承。类绝育了。</li><li>修饰方法：方法不能被重写。</li><li>修饰变量：变量有且仅能被赋值一次。</li></ul></li><li>单例设计模式<ul><li>设计模式，面试必考，经典模式。</li></ul></li><li>枚举<ul><li>面向对象的一种特殊类型，做信息分类和信息标志的。</li></ul></li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><p><input checked="" disabled="" type="checkbox">  能够写出抽象类的格式</p><ul><li><input disabled="" type="checkbox"> <strong>abstract</strong> class Animal{</li><li><input disabled="" type="checkbox"> }</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  能够写出抽象方法的格式</p><ul><li><input disabled="" type="checkbox"> <strong>public abstract void run();</strong></li><li><input disabled="" type="checkbox"> 只有方法签名，没有方法体，必须用abstract修饰。</li></ul></li><li><p><input disabled="" type="checkbox">  父类抽象方法的意义</p><ul><li><input disabled="" type="checkbox"> 被子类继承</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  写出定义接口的格式</p><ul><li><p><input disabled="" type="checkbox">  public <strong>interface</strong> SportMan{</p><p>​        </p></li><li><p><input disabled="" type="checkbox">  }</p></li></ul></li><li><p><input checked="" disabled="" type="checkbox">  写出实现接口的格式</p><ul><li><input disabled="" type="checkbox"> 修饰符 class 实现类  <strong>implements</strong>  接口1 , 接口2{</li><li><input disabled="" type="checkbox"> }</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  说出接口中成员的特点</p><ul><li><input disabled="" type="checkbox"> JDK 1.8之前全部是抽象方法和常量，其他都没有。</li><li><input disabled="" type="checkbox"> JDK 1.8之后，有了静态方法，默认方法，JDK 1.9之后有了私有方法。</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  描述final修饰的类的特点</p><ul><li><input disabled="" type="checkbox"> 类不能被继承</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  描述final修饰的方法的特点</p><ul><li><input disabled="" type="checkbox"> 方法不能被重写了</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  描述final修饰的变量的特点</p><ul><li><input disabled="" type="checkbox"> 变量有且仅能被赋值一次</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  能够写出静态代码块的</p><ul><li><input disabled="" type="checkbox"> static{ </li><li><input disabled="" type="checkbox"> }</li></ul></li></ul><h1 id="第一章-抽象类"><a href="#第一章-抽象类" class="headerlink" title="第一章 抽象类"></a>第一章 抽象类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><h3 id="1-1-1-抽象类引入"><a href="#1-1-1-抽象类引入" class="headerlink" title="1.1.1 抽象类引入"></a>1.1.1 抽象类引入</h3><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类完全只需要提供一个没有方法体的方法签名即可，具体实现交给子类自己去实现。<strong>我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类</strong>。</p><ul><li><strong>抽象方法</strong> ： 没有方法体的方法。</li><li><strong>抽象类</strong>：包含抽象方法的类。</li></ul><h2 id="1-2-abstract使用格式"><a href="#1-2-abstract使用格式" class="headerlink" title="1.2 abstract使用格式"></a>1.2 abstract使用格式</h2><p><strong>abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。</strong></p><h3 id="1-2-1-抽象方法"><a href="#1-2-1-抽象方法" class="headerlink" title="1.2.1 抽象方法"></a>1.2.1 抽象方法</h3><p>使用<code>abstract</code> 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>定义格式：</p><pre><code class="java">修饰符 abstract 返回值类型 方法名 (参数列表)；</code></pre><p>代码举例：</p><pre><code class="java">public abstract void run()；</code></pre><h3 id="1-2-2-抽象类"><a href="#1-2-2-抽象类" class="headerlink" title="1.2.2 抽象类"></a>1.2.2 抽象类</h3><p>如果一个类包含抽象方法，那么该类必须是抽象类。<strong>注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。</strong></p><p>定义格式：</p><pre><code class="java">abstract class 类名字 &#123;   &#125;</code></pre><p>代码举例：</p><pre><code class="java">public abstract class Animal &#123;    public abstract void run()；&#125;</code></pre><h3 id="1-2-3-抽象类的使用"><a href="#1-2-3-抽象类的使用" class="headerlink" title="1.2.3 抽象类的使用"></a>1.2.3 抽象类的使用</h3><p><strong>要求</strong>：继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。否则，该子类也必须声明为抽象类。</p><p>代码举例：</p><pre><code class="java">// 父类,抽象类abstract class Employee &#123;    private String id;    private String name;    private double salary;        public Employee() &#123;    &#125;        public Employee(String id, String name, double salary) &#123;        this.id = id;        this.name = name;        this.salary = salary;    &#125;        // 抽象方法    // 抽象方法必须要放在抽象类中    abstract public void work();&#125;// 定义一个子类继承抽象类class Manager extends Employee &#123;    public Manager() &#123;    &#125;    public Manager(String id, String name, double salary) &#123;        super(id, name, salary);    &#125;    // 2.重写父类的抽象方法    @Override    public void work() &#123;        System.out.println(&quot;管理其他人&quot;);    &#125;&#125;// 定义一个子类继承抽象类class Cook extends Employee &#123;    public Cook() &#123;    &#125;    public Cook(String id, String name, double salary) &#123;        super(id, name, salary);    &#125;    @Override    public void work() &#123;        System.out.println(&quot;厨师炒菜多加点盐...&quot;);    &#125;&#125;// 测试类public class Demo10 &#123;    public static void main(String[] args) &#123;        // 创建抽象类,抽象类不能创建对象        // 假设抽象类让我们创建对象,里面的抽象方法没有方法体,无法执行.所以不让我们创建对象//        Employee e = new Employee();//        e.work();                // 3.创建子类        Manager m = new Manager();        m.work();                Cook c = new Cook(&quot;ap002&quot;, &quot;库克&quot;, 1);        c.work();    &#125;&#125;</code></pre><p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p><h2 id="1-3-抽象类的特征"><a href="#1-3-抽象类的特征" class="headerlink" title="1.3 抽象类的特征"></a>1.3 抽象类的特征</h2><p>抽象类的特征总结起来可以说是 <strong>有得有失</strong></p><p><strong>有得：抽象类得到了拥有抽象方法的能力。</strong></p><p><strong>有失：抽象类失去了创建对象的能力。</strong></p><p>其他成员（构造器，实例方法，静态方法等）抽象类都是具备的。</p><h2 id="1-4-抽象类的注意事项"><a href="#1-4-抽象类的注意事项" class="headerlink" title="1.4 抽象类的注意事项"></a>1.4 抽象类的注意事项</h2><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p><ol><li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p><blockquote><p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></blockquote></li><li><p>抽象类中，可以有构造器，是供子类创建对象时，初始化父类成员使用的。</p><blockquote><p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p></blockquote></li><li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><blockquote><p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p></blockquote></li><li><p>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。 </p><blockquote><p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p></blockquote></li><li><p>抽象类存在的意义是为了被子类继承，抽象类体现的是模板思想。</p><blockquote><p>理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。</p></blockquote></li></ol><h2 id="1-5-抽象类存在的意义"><a href="#1-5-抽象类存在的意义" class="headerlink" title="1.5 抽象类存在的意义"></a>1.5 抽象类存在的意义</h2><p>抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义，<strong>抽象类体现的是模板思想</strong>，模板是通用的东西抽象类中已经是具体的实现（抽象类中可以有成员变量和实现方法），而模板中不能决定的东西定义成抽象方法，让使用模板（继承抽象类的类）的类去重写抽象方法实现需求，这是典型的模板思想。</p><h2 id="1-6-第一个设计模式：模板模式"><a href="#1-6-第一个设计模式：模板模式" class="headerlink" title="1.6 第一个设计模式：模板模式"></a>1.6 第一个设计模式：模板模式</h2><p>我们现在使用抽象类设计一个模板模式的应用，例如在小学的时候，我们经常写作文，通常都是有模板可以套用的。假如我现在需要定义新司机和老司机类，新司机和老司机都有开车功能，开车的步骤都一样，只是驾驶时的姿势有点不同，<code>新司机:开门,点火,双手紧握方向盘,刹车,熄火</code>，<code>老司机:开门,点火,右手握方向盘左手抽烟,刹车,熄火</code>。我们可以将固定流程写到父类中，不同的地方就定义成抽象方法，让不同的子类去重写，代码如下:</p><pre><code class="java">// 司机开车的模板类public abstract class Driver &#123;    public void go() &#123;        System.out.println(&quot;开门&quot;);        System.out.println(&quot;点火&quot;);        // 开车姿势不确定?定义为抽象方法        ziShi();        System.out.println(&quot;刹车&quot;);        System.out.println(&quot;熄火&quot;);    &#125;    public abstract void ziShi();&#125;</code></pre><p>现在定义两个使用模板的司机：</p><pre><code class="java">public class NewDriver extends Driver &#123;    @Override    public void ziShi() &#123;        System.out.println(&quot;新司机双手紧握方向盘&quot;);    &#125;&#125;public class OldDriver extends Driver &#123;    @Override    public void ziShi() &#123;        System.out.println(&quot;老司机右手握方向盘左手抽烟...&quot;);    &#125;&#125;</code></pre><p>编写测试类</p><pre><code class="java">public class Demo02 &#123;    public static void main(String[] args) &#123;        NewDriver nd = new NewDriver();        nd.go();        OldDriver od = new OldDriver();        od.go();    &#125;&#125;</code></pre><p>运行效果</p><p><img src="assets/1560747035458.png" alt="1560747035458"></p><p><strong>可以看出，模板模式的优势是，模板已经定义了通用架构，使用者只需要关心自己需要实现的功能即可！非常的强大！</strong></p><h1 id="第二章-接口"><a href="#第二章-接口" class="headerlink" title="第二章 接口"></a>第二章 接口</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>我们已经学完了抽象类，抽象类中可以用抽象方法，也可以有普通方法，已经构造器，成员变量等。那么什么是接口呢？<strong>接口是更加彻底的抽象，接口中全部是抽象方法。（JDK8之前），接口同样是不能创建对象的</strong>。</p><h2 id="2-2-定义格式"><a href="#2-2-定义格式" class="headerlink" title="2.2 定义格式"></a>2.2 定义格式</h2><pre><code class="java">//接口的定义格式：修饰符 interface 接口名称&#123;    // 抽象方法&#125;// 修饰符：public|缺省// 接口的声明：interface// 接口名称：首字母大写，满足“驼峰模式”</code></pre><h2 id="2-3-接口成分的特点"><a href="#2-3-接口成分的特点" class="headerlink" title="2.3 接口成分的特点"></a>2.3 接口成分的特点</h2><p>  在JDK8之前，接口中的成分包含：抽象方法和常量</p><h3 id="2-3-1-抽象方法"><a href="#2-3-1-抽象方法" class="headerlink" title="2.3.1.抽象方法"></a>2.3.1.抽象方法</h3><p>​       注意：接口中的抽象方法默认会自动加上public abstract修饰程序员无需自己手写！！<br>​       按照规范：以后接口中的抽象方法建议不要写上public abstract。因为没有必要啊，默认会加上。</p><h3 id="2-3-2-常量"><a href="#2-3-2-常量" class="headerlink" title="2.3.2 常量"></a>2.3.2 常量</h3><p> 在接口中定义的成员变量默认会加上： public static final修饰。也就是说在接口中定义的成员变量实际上是一个常量。这里是使用public static final修饰后，变量值就不可被修改，并且是静态化的变量可以直接用接口名访问，所以也叫常量。常量必须要给初始值。常量命名规范建议字母全部大写，多个单词用下划线连接。</p><h3 id="2-3-3-案例演示"><a href="#2-3-3-案例演示" class="headerlink" title="2.3.3 案例演示"></a>2.3.3 案例演示</h3><pre><code class="java">public interface InterF &#123;    // 抽象方法！    //    public abstract void run();    void run();    //    public abstract String getName();    String getName();    //    public abstract int add(int a , int b);    int add(int a , int b);    // 它的最终写法是：    // public static final int AGE = 12 ;    int AGE  = 12; //常量    String SCHOOL_NAME = &quot;黑马程序员&quot;;&#125;</code></pre><h2 id="2-4-基本的实现"><a href="#2-4-基本的实现" class="headerlink" title="2.4 基本的实现"></a>2.4 基本的实现</h2><h3 id="2-4-1-实现接口的概述"><a href="#2-4-1-实现接口的概述" class="headerlink" title="2.4.1 实现接口的概述"></a>2.4.1 实现接口的概述</h3><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code> implements</code>关键字。</p><h3 id="2-4-2-实现接口的格式"><a href="#2-4-2-实现接口的格式" class="headerlink" title="2.4.2 实现接口的格式"></a>2.4.2 实现接口的格式</h3><pre><code class="java">/**接口的实现：    在Java中接口是被实现的，实现接口的类称为实现类。    实现类的格式:*/[修饰符] class 类名 implements 接口1,接口2,接口3...&#123;&#125;</code></pre><p>从上面格式可以看出，接口是可以被多实现的。大家可以想一想为什么呢？</p><h3 id="2-4-3-类实现接口的要求和意义"><a href="#2-4-3-类实现接口的要求和意义" class="headerlink" title="2.4.3 类实现接口的要求和意义"></a>2.4.3 类实现接口的要求和意义</h3><ol><li>必须重写实现的全部接口中所有抽象方法。</li><li>如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。</li><li><strong>意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。</strong></li></ol><h3 id="2-4-4-类与接口基本实现案例"><a href="#2-4-4-类与接口基本实现案例" class="headerlink" title="2.4.4  类与接口基本实现案例"></a>2.4.4  类与接口基本实现案例</h3><p>假如我们定义一个运动员的<strong>接口</strong>（规范），代码如下：</p><pre><code class="java">/**   接口：接口体现的是规范。 * */public interface SportMan &#123;    void run(); // 抽象方法，跑步。    void law(); // 抽象方法，遵守法律。    String compittion(String project);  // 抽象方法，比赛。&#125;</code></pre><p>接下来定义一个乒乓球运动员类，实现接口，实现接口的<strong>实现类</strong>代码如下：</p><pre><code class="java">package com.itheima._03接口的实现;/** * 接口的实现： *    在Java中接口是被实现的，实现接口的类称为实现类。 *    实现类的格式: *      [修饰符] class 类名 implements 接口1,接口2,接口3...&#123; * * *      &#125; * */public class PingPongMan  implements SportMan &#123;    @Override    public void run() &#123;        System.out.println(&quot;乒乓球运动员稍微跑一下！！&quot;);    &#125;    @Override    public void law() &#123;        System.out.println(&quot;乒乓球运动员守法！&quot;);    &#125;    @Override    public String compittion(String project) &#123;        return &quot;参加&quot;+project+&quot;得金牌！&quot;;    &#125;&#125;</code></pre><p><strong>测试代码</strong>：</p><pre><code class="java">public class TestMain &#123;    public static void main(String[] args) &#123;        // 创建实现类对象。        PingPongMan zjk = new PingPongMan();        zjk.run();        zjk.law();        System.out.println(zjk.compittion(&quot;全球乒乓球比赛&quot;));    &#125;&#125;</code></pre><h3 id="1-4-5-类与接口的多实现案例"><a href="#1-4-5-类与接口的多实现案例" class="headerlink" title="1.4.5 类与接口的多实现案例"></a>1.4.5 类与接口的多实现案例</h3><p><strong>类与接口之间的关系是多实现的，一个类可以同时实现多个接口。</strong></p><p>首先我们先定义两个接口，代码如下：</p><pre><code class="java">/** 法律规范：接口*/public interface Law &#123;    void rule();&#125;/** 这一个运动员的规范：接口*/public interface SportMan &#123;    void run();&#125;</code></pre><p>然后定义一个实现类：</p><pre><code class="java">/** * Java中接口是可以被多实现的： *    一个类可以实现多个接口: Law ,SportMan * * */public class JumpMan implements Law ,SportMan &#123;    @Override    public void rule() &#123;        System.out.println(&quot;尊长守法&quot;);    &#125;    @Override    public void run() &#123;        System.out.println(&quot;训练跑步！&quot;);    &#125;&#125;</code></pre><p>从上面可以看出类与接口之间是可以多实现的，我们可以理解成实现多个规范，这是合理的。</p><h2 id="2-5-接口与接口的多继承"><a href="#2-5-接口与接口的多继承" class="headerlink" title="2.5 接口与接口的多继承"></a>2.5 接口与接口的多继承</h2><p>Java中，接口与接口之间是可以多继承的：也就是一个接口可以同时继承多个接口。大家一定要注意：</p><p><strong>类与接口是实现关系</strong></p><p><strong>接口与接口是继承关系</strong></p><p>接口继承接口就是把其他接口的抽象方法与本接口进行了合并。</p><p>案例演示：</p><pre><code class="java">public interface Abc &#123;    void go();    void test();&#125;/** 法律规范：接口*/public interface Law &#123;    void rule();    void test();&#125; * *  总结： *     接口与类之间是多实现的。 *     接口与接口之间是多继承的。 * */public interface SportMan extends Law , Abc &#123;    void run();&#125;</code></pre><h2 id="2-6-JDK-8之后的接口新增方法"><a href="#2-6-JDK-8之后的接口新增方法" class="headerlink" title="2.6 JDK 8之后的接口新增方法"></a>2.6 JDK 8之后的接口新增方法</h2><p>从JDK 8开始之后，接口不再纯洁了，接口中不再只是抽象方法，接口还可以有<strong>默认方法</strong>（也就是实例方法），和<strong>静态方法</strong>了，还包含了私有实例方法和私有静态方法</p><h3 id="2-6-1-含有默认方法和静态方法"><a href="#2-6-1-含有默认方法和静态方法" class="headerlink" title="2.6.1 含有默认方法和静态方法"></a>2.6.1 含有默认方法和静态方法</h3><p><strong>默认方法：使用 <code>default</code> 修饰，不可省略，供子类调用或者子类重写。</strong></p><p><strong>静态方法：使用 <code>static</code> 修饰，供接口直接调用。</strong></p><p>代码如下：</p><pre><code class="java">public interface InterFaceName &#123;    public default void method() &#123;        // 执行语句    &#125;    public static void method2() &#123;        // 执行语句        &#125;&#125;</code></pre><h3 id="2-6-2-含有私有方法和私有静态方法"><a href="#2-6-2-含有私有方法和私有静态方法" class="headerlink" title="2.6.2 含有私有方法和私有静态方法"></a>2.6.2 含有私有方法和私有静态方法</h3><p>私有方法：使用 <code>private</code> 修饰，供接口中的默认方法或者静态方法调用。</p><p>代码如下：</p><pre><code class="java">public interface InterFaceName &#123;    private void method() &#123;        // 执行语句    &#125;&#125;</code></pre><h3 id="2-6-3-新增方法的使用"><a href="#2-6-3-新增方法的使用" class="headerlink" title="2.6.3 新增方法的使用"></a>2.6.3 新增方法的使用</h3><p><strong>默认方法和静态方法以及私有方法和私有静态方法</strong>，<strong>遵循面向对象的继承关系使用原则，实现类依然可以访问接口的非私有方法，对于接口中的非私有静态方法，可以直接通过接口名进行访问。</strong></p><p>重写默认方法注意（了解）:</p><ul><li><p>子接口重写默认方法时，default关键字可以保留。</p></li><li><p>实现类重写默认方法时，default关键字不可以保留。</p></li></ul><h2 id="2-7-实现多个接口使用注意事项"><a href="#2-7-实现多个接口使用注意事项" class="headerlink" title="2.7 实现多个接口使用注意事项"></a>2.7 实现多个接口使用注意事项</h2><h3 id="2-7-1-多个接口同名静态方法"><a href="#2-7-1-多个接口同名静态方法" class="headerlink" title="2.7.1 多个接口同名静态方法"></a>2.7.1 多个接口同名静态方法</h3><p>如果实现了多个接口，多个接口中存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。</p><pre><code class="java">public interface A &#123;  public static void test()&#123;  &#125;&#125; interface B &#123;    public static void test()&#123;    &#125;&#125;class C implements  A , B&#123;    public static void main(String[] args) &#123;        People.test();        B.test();       // C.test(); // 编译出错    &#125;&#125;</code></pre><h3 id="2-7-2-优先级的问题"><a href="#2-7-2-优先级的问题" class="headerlink" title="2.7.2 优先级的问题"></a>2.7.2 优先级的问题</h3><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。代码如下：</p><p>定义接口：</p><pre><code class="java">interface A &#123;    public default void methodA()&#123;        System.out.println(&quot;AAAAAAAAAAAA&quot;);    &#125;&#125;</code></pre><p>定义父类：</p><pre><code class="java">class D &#123;    public void methodA()&#123;        System.out.println(&quot;DDDDDDDDDDDD&quot;);    &#125;&#125;</code></pre><p>定义子类：</p><pre><code class="java">class C extends D implements A &#123;      // 未重写methodA方法&#125;</code></pre><p>定义测试类：</p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        C c = new C();        c.methodA();     &#125;&#125;输出结果:DDDDDDDDDDDD</code></pre><h2 id="2-8-接口小结"><a href="#2-8-接口小结" class="headerlink" title="2.8 接口小结"></a>2.8 接口小结</h2><ul><li>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。</li><li>接口中的方法全是抽象方法，默认会自动加上public abstract修饰</li><li>JDK 8开始，接口不再纯洁，支持静态方法，默认方法，私有方法。</li><li>接口中，没有构造器，<strong>不能创建对象</strong>。</li><li>类与接口是多实现的</li><li>接口与接口是多继承的</li><li>接口体现的规范。</li></ul><h1 id="第三章-代码块"><a href="#第三章-代码块" class="headerlink" title="第三章 代码块"></a>第三章 代码块</h1><h2 id="3-1-引入"><a href="#3-1-引入" class="headerlink" title="3.1 引入"></a>3.1 引入</h2><p>类的成分：<br>​    1.成员变量<br>​    2.构造器<br>​    3.成员方法<br>​    4.代码块<br>​    5.内部类</p><p>我们已经学完了成员变量，构造器，成员方法，接下来我们来介绍以下代码快，代码块按照有无static可以分为静态代码块和实例代码块。</p><h2 id="3-2-静态代码块"><a href="#3-2-静态代码块" class="headerlink" title="3.2 静态代码块"></a>3.2 静态代码块</h2><p><strong>静态代码块</strong><br>​         必须有static修饰，必须放在类下。与类一起加载执行。</p><p><strong>格式</strong></p><pre><code class="java">static&#123;     // 执行代码&#125;</code></pre><p><strong>特点</strong>：</p><ul><li>每次执行类，加载类的时候都会先执行静态代码块一次。</li><li>静态代码块是自动触发执行的，只要程序启动静态代码块就会先执行一次。</li><li>作用：在启动程序之前可以做资源的初始化，一般用于初始化静态资源。</li></ul><p><strong>案例演示</strong></p><pre><code class="java">public class DaimaKuaiDemo01 &#123;    public static String sc_name ;    // 1.静态代码块    static &#123;        // 初始化静态资源        sc_name = &quot;黑马程序员！&quot;;        System.out.println(&quot;静态代码块执行！&quot;);    &#125;    public static void main(String[] args) &#123;        System.out.println(&quot;main方法执行&quot;);        System.out.println(sc_name);    &#125;&#125;</code></pre><h2 id="3-3-实例代码块"><a href="#3-3-实例代码块" class="headerlink" title="3.3 实例代码块"></a>3.3 实例代码块</h2><p><strong>实例代码块</strong><br>​         没有static修饰，必须放在类下。与对象初始化一起加载。</p><p><strong>格式</strong></p><pre><code class="java">&#123;     // 执行代码&#125;</code></pre><p><strong>特点</strong>：</p><ul><li>无static修饰。属于对象，与对象的创建一起执行的。</li><li>每次调用构造器初始化对象，实例代码块都要自动触发执行一次。</li><li>实例代码块实际上是提取到每一个构造器中去执行的。</li><li>作用：实例代码块用于初始化对象的资源。</li></ul><p><strong>案例演示</strong></p><pre><code class="java">public class DaimaKuaiDemo02 &#123;       private String name ;    // 实例代码块。 无static修饰。    &#123;        System.out.println(&quot;实例代码块执行&quot;);        name = &quot;dl&quot;;    &#125;    // 构造器    public DaimaKuaiDemo02()&#123;        //System.out.println(&quot;实例代码块执行&quot;);    &#125;    // 有参数构造器    public DaimaKuaiDemo02(String name)&#123;        //System.out.println(&quot;实例代码块执行&quot;);    &#125;    public static void main(String[] args) &#123;        // 匿名对象，创建出来没有给变量。        new DaimaKuaiDemo02();        new DaimaKuaiDemo02();        new DaimaKuaiDemo02(&quot;xulei&quot;);    &#125;&#125;// 输出三次：实例代码块执行</code></pre><p>常用API</p><h1 id="第四章-final关键字"><a href="#第四章-final关键字" class="headerlink" title="第四章 final关键字"></a>第四章 final关键字</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了<code>final</code> 关键字，用于修饰<strong>不可改变</strong>内容。</p><ul><li><strong>final</strong>：  不可改变，最终的含义。可以用于修饰类、方法和变量。<ul><li>类：被修饰的类，不能被继承。</li><li>方法：被修饰的方法，不能被重写。</li><li>变量：被修饰的变量，有且仅能被赋值一次。</li></ul></li></ul><h2 id="4-2-使用方式"><a href="#4-2-使用方式" class="headerlink" title="4.2 使用方式"></a>4.2 使用方式</h2><h3 id="4-2-1-修饰类"><a href="#4-2-1-修饰类" class="headerlink" title="4.2.1 修饰类"></a>4.2.1 修饰类</h3><p>final修饰的类，不能被继承。</p><p>格式如下：</p><pre><code class="java">final class 类名 &#123;&#125;</code></pre><p>代码:</p><pre><code class="java">final class Fu &#123;&#125;// class Zi extends Fu &#123;&#125; // 报错,不能继承final的类</code></pre><p>查询API发现像 <code>public final class String</code> 、<code>public final class Math</code> 、<code>public final class Scanner</code> 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。</p><h3 id="4-2-2-修饰方法"><a href="#4-2-2-修饰方法" class="headerlink" title="4.2.2 修饰方法"></a>4.2.2 修饰方法</h3><p>final修饰的方法，不能被重写。<br>格式如下：</p><pre><code class="java">修饰符 final 返回值类型 方法名(参数列表)&#123;    //方法体&#125;</code></pre><p>代码: </p><pre><code class="java">class Fu2 &#123;    final public void show1() &#123;        System.out.println(&quot;Fu2 show1&quot;);    &#125;    public void show2() &#123;        System.out.println(&quot;Fu2 show2&quot;);    &#125;&#125;class Zi2 extends Fu2 &#123;//    @Override//    public void show1() &#123;//        System.out.println(&quot;Zi2 show1&quot;);//    &#125;    @Override    public void show2() &#123;        System.out.println(&quot;Zi2 show2&quot;);    &#125;&#125;</code></pre><h3 id="4-2-3-修饰变量-局部变量"><a href="#4-2-3-修饰变量-局部变量" class="headerlink" title="4.2.3 修饰变量-局部变量"></a>4.2.3 修饰变量-局部变量</h3><ol><li><strong>局部变量——基本类型</strong><br>基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下：</li></ol><pre><code class="java">public class FinalDemo1 &#123;    public static void main(String[] args) &#123;        // 声明变量，使用final修饰        final int a;        // 第一次赋值         a = 10;        // 第二次赋值        a = 20; // 报错,不可重新赋值        // 声明变量，直接赋值，使用final修饰        final int b = 10;        // 第二次赋值        b = 20; // 报错,不可重新赋值    &#125;&#125;</code></pre><p>思考，如下两种写法，哪种可以通过编译？</p><p>写法1：</p><pre><code class="java">final int c = 0;for (int i = 0; i &lt; 10; i++) &#123;    c = i;    System.out.println(c);&#125;</code></pre><p>写法2：</p><pre><code class="java">for (int i = 0; i &lt; 10; i++) &#123;    final int c = i;    System.out.println(c);&#125;</code></pre><p>根据 <code>final</code> 的定义，写法1报错！写法2，为什么通过编译呢？因为每次循环，都是一次新的变量c。这也是大家需要注意的地方。</p><h3 id="4-2-4-修饰变量-实例成员变量"><a href="#4-2-4-修饰变量-实例成员变量" class="headerlink" title="4.2.4 修饰变量-实例成员变量"></a>4.2.4 修饰变量-实例成员变量</h3><p>成员变量涉及到初始化的问题，初始化方式有显示初始化和构造器初始化，只能选择其中一个：</p><ul><li>显示初始化(在定义成员变量的时候立马赋值)；</li></ul><pre><code class="java">public class Student &#123;    final int num = 10;&#125;</code></pre><ul><li><p>构造器初始化(在构造器中赋值一次)。</p><p><strong>注意：每个构造器中都要赋值一次！</strong></p></li></ul><pre><code class="java">public class Student &#123;    final int num = 10;    final int num2;    public Student() &#123;        this.num2 = 20;//     this.num2 = 20;    &#125;         public Student(String name) &#123;        this.num2 = 20;//     this.num2 = 20;    &#125;&#125;</code></pre><blockquote><p>被final修饰的常量名称，一般都有书写规范，所有字母都<strong>大写</strong>。</p></blockquote><h1 id="第五章-单例设计模式"><a href="#第五章-单例设计模式" class="headerlink" title="第五章 单例设计模式"></a>第五章 单例设计模式</h1><p>正常情况下一个类可以创建多个对象</p><pre><code class="java">public static void main(String[] args) &#123;    // 正常情况下一个类可以创建多个对象    Person p1 = new Person();    Person p2 = new Person();    Person p3 = new Person();&#125;</code></pre><h2 id="5-1-单例设计模式的作用"><a href="#5-1-单例设计模式的作用" class="headerlink" title="5.1 单例设计模式的作用"></a>5.1 单例设计模式的作用</h2><p>单例模式，是一种常用的软件设计模式。通过单例模式可以保证系统中，应用该模式的这个类只有一个实例。即一个类只有一个对象实例。</p><h2 id="5-2-单例设计模式实现步骤"><a href="#5-2-单例设计模式实现步骤" class="headerlink" title="5.2 单例设计模式实现步骤"></a>5.2 单例设计模式实现步骤</h2><ol><li><p>将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。</p></li><li><p>在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。</p></li><li><p>定义一个静态方法返回这个唯一对象。</p></li></ol><h2 id="5-3-单例设计模式的类型"><a href="#5-3-单例设计模式的类型" class="headerlink" title="5.3 单例设计模式的类型"></a>5.3 单例设计模式的类型</h2><p>根据实例化对象的时机单例设计模式又分为以下两种:</p><ol><li><p>饿汉单例设计模式</p></li><li><p>懒汉单例设计模式</p></li></ol><h2 id="5-4-饿汉单例设计模式"><a href="#5-4-饿汉单例设计模式" class="headerlink" title="5.4 饿汉单例设计模式"></a>5.4 饿汉单例设计模式</h2><p>饿汉单例设计模式就是使用类的时候已经将对象创建完毕，不管以后会不会使用到该实例化对象，先创建了再说。很着急的样子，故被称为“饿汉模式”。</p><p>代码如下：</p><pre><code class="java">public class Singleton &#123;    // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。    private Singleton() &#123;&#125;    // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。    private static final Singleton instance = new Singleton();        // 3.定义一个静态方法返回这个唯一对象。    public static Singleton getInstance() &#123;        return instance;    &#125;&#125;</code></pre><h2 id="5-5-懒汉单例设计模式"><a href="#5-5-懒汉单例设计模式" class="headerlink" title="5.5 懒汉单例设计模式"></a>5.5 懒汉单例设计模式</h2><p>懒汉单例设计模式就是调用getInstance()方法时实例才被创建，先不急着实例化出对象，等要用的时候才例化出对象。不着急，故称为“懒汉模式”。</p><p>代码如下：</p><pre><code class="java">public class Singleton &#123;    // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。    private static Singleton instance;        // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。    private Singleton() &#123;&#125;        // 3.定义一个静态方法返回这个唯一对象。要用的时候才例化出对象    public static Singleton getInstance() &#123;        if(instance == null) &#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;</code></pre><blockquote><p>注意：懒汉单例设计模式在多线程环境下可能会实例化出多个对象，不能保证单例的状态。我们在学习完多线程的时候还会再讲解如何解决这个问题。</p></blockquote><h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h2><p>单例模式可以保证系统中一个类只有一个对象实例。</p><p>实现单例模式的步骤：</p><ol><li>将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。</li><li>在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。</li><li>定义一个静态方法返回这个唯一对象。</li></ol><h1 id="第六章-枚举"><a href="#第六章-枚举" class="headerlink" title="第六章 枚举"></a>第六章 枚举</h1><h2 id="6-1-不使用枚举存在的问题"><a href="#6-1-不使用枚举存在的问题" class="headerlink" title="6.1 不使用枚举存在的问题"></a>6.1 不使用枚举存在的问题</h2><p>假设我们要定义一个人类，人类中包含姓名和性别。通常会将性别定义成字符串类型，效果如下：</p><pre><code class="java">public class Person &#123;    private String name;    private String sex;    public Person() &#123;    &#125;    public Person(String name, String sex) &#123;        this.name = name;        this.sex = sex;    &#125;        // 省略get/set/toString方法&#125;</code></pre><pre><code class="java">public class Demo01 &#123;    public static void main(String[] args) &#123;        Person p1 = new Person(&quot;张三&quot;, &quot;男&quot;);        Person p2 = new Person(&quot;张三&quot;, &quot;abc&quot;); // 因为性别是字符串,所以我们可以传入任意字符串    &#125;&#125;</code></pre><p>不使用枚举存在的问题：可以给性别传入任意的字符串，导致性别是非法的数据，不安全。</p><h2 id="6-2-枚举的作用与应用场景"><a href="#6-2-枚举的作用与应用场景" class="headerlink" title="6.2 枚举的作用与应用场景"></a>6.2 枚举的作用与应用场景</h2><p>枚举的作用：一个方法接收的参数是固定范围之内的时候，那么即可使用枚举。</p><h2 id="6-3-枚举的基本语法"><a href="#6-3-枚举的基本语法" class="headerlink" title="6.3 枚举的基本语法"></a>6.3 枚举的基本语法</h2><h3 id="6-3-1-枚举的概念"><a href="#6-3-1-枚举的概念" class="headerlink" title="6.3.1 枚举的概念"></a>6.3.1 枚举的概念</h3><p>枚举是一种特殊类。枚举是有固定实例个数的类型，我们可以把枚举理解成有固定个数实例的多例模式。</p><h3 id="6-3-2-定义枚举的格式"><a href="#6-3-2-定义枚举的格式" class="headerlink" title="6.3.2 定义枚举的格式"></a>6.3.2 定义枚举的格式</h3><pre><code class="java">enum 枚举名 &#123;    第一行都是罗列枚举实例,这些枚举实例直接写大写名字即可。&#125;</code></pre><h3 id="6-3-3-入门案例"><a href="#6-3-3-入门案例" class="headerlink" title="6.3.3 入门案例"></a>6.3.3 入门案例</h3><ol><li>定义枚举：BOY表示男，GIRL表示女</li></ol><pre><code class="java">enum Sex &#123;    BOY, GIRL; // 男，女&#125;</code></pre><ol start="2"><li>Perosn中的性别有String类型改为Sex枚举类型</li></ol><pre><code class="java">public class Person &#123;    private String name;    private Sex sex;    public Person() &#123;    &#125;    public Person(String name, Sex sex) &#123;        this.name = name;        this.sex = sex;    &#125;    // 省略get/set/toString方法&#125;</code></pre><ol start="3"><li>使用是只能传入枚举中的固定值</li></ol><pre><code class="java">public class Demo02 &#123;    public static void main(String[] args) &#123;        Person p1 = new Person(&quot;张三&quot;, Sex.BOY);        Person p2 = new Person(&quot;张三&quot;, Sex.GIRL);        Person p3 = new Person(&quot;张三&quot;, &quot;abc&quot;);    &#125;&#125;</code></pre><h3 id="5-3-4-枚举的其他内容"><a href="#5-3-4-枚举的其他内容" class="headerlink" title="5.3.4 枚举的其他内容"></a>5.3.4 枚举的其他内容</h3><p>枚举的本质是一个类，我们刚才定义的Sex枚举最终效果如下：</p><pre><code class="java">enum Sex &#123;    BOY, GIRL; // 男，女&#125;// 枚举的本质是一个类，我们刚才定义的Sex枚举相当于下面的类final class SEX extends java.lang.Enum&lt;SEX&gt; &#123;    public static final SEX BOY = new SEX();    public static final SEX GIRL = new SEX();    public static SEX[] values();    public static SEX valueOf(java.lang.String);    static &#123;&#125;;&#125;</code></pre><p>枚举的本质是一个类，所以枚举中还可以有成员变量，成员方法等。</p><pre><code class="java">public enum Sex &#123;    BOY(18), GIRL(16);    public int age;    Sex(int age) &#123;        this.age = age;    &#125;    public void showAge() &#123;        System.out.println(&quot;年龄是: &quot; + age);    &#125;&#125;</code></pre><pre><code class="java">public class Demo03 &#123;    public static void main(String[] args) &#123;        Person p1 = new Person(&quot;张三&quot;, Sex.BOY);        Person p2 = new Person(&quot;张三&quot;, Sex.GIRL);        Sex.BOY.showAge();        Sex.GIRL.showAge();    &#125;&#125;</code></pre><p>运行效果：</p><p><img src="C:\Users\13666\AppData\Roaming\Typora\typora-user-images\1560502240126.png" alt="1560502240126"></p><h2 id="6-4-应用场景"><a href="#6-4-应用场景" class="headerlink" title="6.4 应用场景"></a>6.4 应用场景</h2><h2 id="6-5-枚举的应用"><a href="#6-5-枚举的应用" class="headerlink" title="6.5 枚举的应用"></a>6.5 枚举的应用</h2><p><strong>枚举的作用：枚举通常可以用于做信息的分类，如性别，方向，季度等。</strong></p><p>枚举表示性别：</p><pre><code class="java">public enum Sex &#123;    MAIL, FEMAIL;&#125;</code></pre><p>枚举表示方向：</p><pre><code class="java">public enum Orientation &#123;    UP, RIGHT, DOWN, LEFT;&#125;</code></pre><p>枚举表示季度</p><pre><code class="java">public enum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER;&#125;</code></pre><h2 id="6-6-小结"><a href="#6-6-小结" class="headerlink" title="6.6 小结"></a>6.6 小结</h2><ul><li>枚举类在第一行罗列若干个枚举对象。（多例）</li><li>第一行都是常量，存储的是枚举类的对象。</li><li>枚举是不能在外部创建对象的，枚举的构造器默认是私有的。</li><li>枚举通常用于做信息的标志和分类。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day02【抽象类，接口、代码块、final、单例、枚举】&quot;&gt;&lt;a href=&quot;#day02【抽象类，接口、代码块、final、单例、枚举】&quot; class=&quot;headerlink&quot; title=&quot;day02【抽象类，接口、代码块、final、单例、枚举】&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java进阶13天资料" scheme="http://example.com/tags/java%E8%BF%9B%E9%98%B613%E5%A4%A9%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Day01</title>
    <link href="http://example.com/2021/09/05/JAVA/day01-%E5%A4%8D%E4%B9%A0%E5%9B%9E%E9%A1%BE%E3%80%81%E9%9D%99%E6%80%81%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/09/05/JAVA/day01-%E5%A4%8D%E4%B9%A0%E5%9B%9E%E9%A1%BE%E3%80%81%E9%9D%99%E6%80%81%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/</id>
    <published>2021-09-05T02:30:46.000Z</published>
    <updated>2021-09-05T03:00:14.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day01【复习回顾、静态、继承、引用类型使用】"><a href="#day01【复习回顾、静态、继承、引用类型使用】" class="headerlink" title="day01【复习回顾、静态、继承、引用类型使用】"></a>day01【复习回顾、静态、继承、引用类型使用】</h1><h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><ul><li>复习回顾<ul><li>定义类。一个Java文件可以定义多个类。但是只有一个类是用public修饰，public修饰的类名必须称为Java文件名。</li><li>类中有且仅有5大成分（五大金刚）<ul><li>成员变量Field：描述类或者对象的属性信息的。</li><li>成员方法Method：描述类或者对象的行为的。</li><li>构造器（构造方法,Constructor）: 初始化类的一个对象返回。</li><li>代码块：还没有学。</li><li>内部类：还没有学。 </li></ul></li><li>封装<ul><li>面向对象的三大<strong>特征</strong>之一：<strong>封装，继承，多态</strong>。 </li><li>形成了规范，即使毫无意义还是会这样写代码！</li><li>合理隐藏，合理暴露。</li><li>封装的规范：成员变量私有，方法一般公开，提供成套的getter和setter方法暴露成员变量的取值和赋值。</li><li>封装的作用：提高安全性，提高代码的组件化思想。</li><li>封装已经成为Java代码的规范，即使毫无意义，我们也要这样写代码（成员变量私有，方法公开）</li></ul></li><li>this关键字<ul><li>this代表了当前对象的引用。</li><li>this可以出现在构造器和方法中。</li><li>this出现在构造器中代表构造器正在初始化的对象。</li><li>this出现在方法中，哪个对象调用方法，this就代表哪个对象。</li><li>this可以访问对象的成员变量，区分成员变量是局部的还是对象中的成员变量。</li></ul></li></ul></li><li>static关键字. <ul><li>静态。 </li><li>修饰方法和变量都是属于类的。没有static修饰的方法和变量是属于每个对象的。</li></ul></li><li>继承<ul><li>是面向对象的三大特征：封装，<strong>继承</strong>，多态。</li></ul></li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled="" type="checkbox"> 能够写出类的继承格式<ul><li><input disabled="" type="checkbox"> 子类 extends 父类{</li><li><input disabled="" type="checkbox"> }</li></ul></li><li><input disabled="" type="checkbox"> 能够说出继承的特点<ul><li><input disabled="" type="checkbox"> 类是单继承的，可以多层继承，可以有多个子类。</li></ul></li><li><input disabled="" type="checkbox"> 能够区分this和super的作用<ul><li><input disabled="" type="checkbox"> this代表本类对象引用<ul><li><input disabled="" type="checkbox"> this.本类成员变量</li><li><input disabled="" type="checkbox"> this.本类方法</li><li><input disabled="" type="checkbox"> this(…):访问兄弟构造器</li></ul></li><li><input disabled="" type="checkbox"> super代表父类对象引用。<ul><li><input disabled="" type="checkbox"> super.父类变量</li><li><input disabled="" type="checkbox"> super.父类方法</li><li><input disabled="" type="checkbox"> super(…):访问父类构造器</li></ul></li></ul></li><li><input disabled="" type="checkbox"> 能够说出方法重写的概念<ul><li><input disabled="" type="checkbox"> 方法重写：子类写一个方法覆盖父类的方法，子类以后用自己重写的方法。</li></ul></li><li><input disabled="" type="checkbox"> 能够说出方法重写的注意事项<ul><li><input disabled="" type="checkbox"> 1.重写方法的名称和形参列表要与父类被重写方法一致。</li><li><input disabled="" type="checkbox"> 2.重写方法的权限要与父类一样或者更大。 public &gt; protected &gt; 缺省 &gt; private</li></ul></li><li><input disabled="" type="checkbox"> 能够掌握static关键字修饰的变量调用方式<ul><li><input disabled="" type="checkbox"> 类名.静态变量</li><li><input disabled="" type="checkbox"> 对象.静态变量 （不推荐使用）</li></ul></li><li><input disabled="" type="checkbox"> 能够掌握static关键字修饰的方法调用方式<ul><li><input disabled="" type="checkbox"> 类名.静态方法</li><li><input disabled="" type="checkbox"> 对象.静态方法（不推荐使用）</li></ul></li></ul><h1 id="第一章-复习回顾"><a href="#第一章-复习回顾" class="headerlink" title="第一章 复习回顾"></a>第一章 复习回顾</h1><h2 id="1-1-如何定义类"><a href="#1-1-如何定义类" class="headerlink" title="1.1 如何定义类"></a>1.1 如何定义类</h2><p>类的定义格式如下:</p><pre><code class="java">修饰符 class 类名&#123;    // 类中的五大成分。    // 1.成员变量（属性）    // 2.成员方法 (行为)     // 3.构造器 （初始化类的对象数据的）    // 4.内部类    // 5.代码块&#125;</code></pre><p>例如:</p><pre><code class="java">public class Student &#123;    // 1.成员变量    public String name ;    public char sex ; // &#39;男&#39;  &#39;女&#39;    public int age;&#125;</code></pre><h2 id="1-2-如何通过类创建对象"><a href="#1-2-如何通过类创建对象" class="headerlink" title="1.2 如何通过类创建对象"></a>1.2 如何通过类创建对象</h2><pre><code class="java">类名 对象名称 = new 类名();</code></pre><p>例如:</p><pre><code class="java">Student stu = new Student();</code></pre><h2 id="1-3-封装"><a href="#1-3-封装" class="headerlink" title="1.3 封装"></a>1.3 封装</h2><h4 id="1-3-1-封装的步骤"><a href="#1-3-1-封装的步骤" class="headerlink" title="1.3.1 封装的步骤"></a>1.3.1 封装的步骤</h4><p>1.使用 <code>private</code> 关键字来修饰成员变量。</p><p>2.使用<code>public</code>修饰getter和setter方法。</p><h4 id="1-3-2-封装的步骤实现"><a href="#1-3-2-封装的步骤实现" class="headerlink" title="1.3.2 封装的步骤实现"></a>1.3.2 封装的步骤实现</h4><ol><li>private修饰成员变量</li></ol><pre><code class="java">public class Student &#123;    private String name;    private int age;&#125;</code></pre><ol start="2"><li>public修饰getter和setter方法</li></ol><pre><code class="java">public class Student &#123;    private String name;    private int age;    public void setName(String n) &#123;          name = n;    &#125;    public String getName() &#123;          return name;    &#125;    public void setAge(int a) &#123;        if (a &gt; 0 &amp;&amp; a &lt;200) &#123;            age = a;        &#125; else &#123;            System.out.println(&quot;年龄非法！&quot;);        &#125;    &#125;    public int getAge() &#123;          return age;    &#125;&#125;</code></pre><h2 id="1-4-构造器"><a href="#1-4-构造器" class="headerlink" title="1.4 构造器"></a>1.4 构造器</h2><h3 id="1-4-1-构造器的作用"><a href="#1-4-1-构造器的作用" class="headerlink" title="1.4.1 构造器的作用"></a>1.4.1 构造器的作用</h3><p>通过调用构造器可以返回一个类的对象，构造器同时负责帮我们把对象的数据（属性和行为等信息）初始化好。</p><h3 id="1-4-2-构造器的格式"><a href="#1-4-2-构造器的格式" class="headerlink" title="1.4.2 构造器的格式"></a>1.4.2 构造器的格式</h3><pre><code class="java">修饰符 类名(形参列表) &#123;    // 构造体代码，执行代码&#125;</code></pre><h3 id="1-4-3-构造器的应用"><a href="#1-4-3-构造器的应用" class="headerlink" title="1.4.3 构造器的应用"></a>1.4.3 构造器的应用</h3><p>首先定义一个学生类，代码如下：</p><pre><code class="java">public class Student &#123;    // 1.成员变量    public String name;    public int age;    // 2.构造器    public Student() &#123;        System.out.println(&quot;无参数构造器被调用&quot;)；    &#125;&#125;</code></pre><p>接下来通过调用构造器得到两个学生对象。</p><pre><code class="java">public class CreateStu02 &#123;    public static void main(String[] args) &#123;        // 创建一个学生对象        // 类名 变量名称 = new 类名();        Student s1 = new Student();        // 使用对象访问成员变量，赋值        s1.name = &quot;张三&quot;;        s1.age = 20 ;        // 使用对象访问成员变量 输出值        System.out.println(s1.name);        System.out.println(s1.age);         Student s2 = new Student();        // 使用对象访问成员变量 赋值        s2.name = &quot;李四&quot;;        s2.age = 18 ;        System.out.println(s2.name);        System.out.println(s2.age);    &#125;&#125;</code></pre><h2 id="1-5-this关键字的作用"><a href="#1-5-this关键字的作用" class="headerlink" title="1.5 this关键字的作用"></a>1.5 this关键字的作用</h2><h3 id="1-5-1-this关键字的作用"><a href="#1-5-1-this关键字的作用" class="headerlink" title="1.5.1 this关键字的作用"></a>1.5.1 this关键字的作用</h3><p>this代表所在类的当前对象的引用（地址值），即代表当前对象。</p><h3 id="1-5-2-this关键字的应用"><a href="#1-5-2-this关键字的应用" class="headerlink" title="1.5.2 this关键字的应用"></a>1.5.2 this关键字的应用</h3><h4 id="1-5-2-1-用于普通的gettter与setter方法"><a href="#1-5-2-1-用于普通的gettter与setter方法" class="headerlink" title="1.5.2.1 用于普通的gettter与setter方法"></a>1.5.2.1 用于普通的gettter与setter方法</h4><p>this出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。</p><pre><code class="java">public class Student &#123;    private String name;    private int age;    public void setName(String name) &#123;          this.name = name;    &#125;    public String getName() &#123;          return name;    &#125;    public void setAge(int age) &#123;        if (age &gt; 0 &amp;&amp; age &lt; 200) &#123;            this.age = age;        &#125; else &#123;            System.out.println(&quot;年龄非法！&quot;);        &#125;    &#125;    public int getAge() &#123;          return age;    &#125;&#125;</code></pre><h4 id="1-5-2-2-用于构造器中"><a href="#1-5-2-2-用于构造器中" class="headerlink" title="1.5.2.2 用于构造器中"></a>1.5.2.2 用于构造器中</h4><p>this出现在构造器中，代表构造器正在初始化的那个对象。</p><pre><code class="java">public class Student &#123;    private String name;    private int age;        // 无参数构造方法    public Student() &#123;&#125;         // 有参数构造方法    public Student(String name,int age) &#123;        this.name = name;        this.age = age;     &#125;&#125;</code></pre><h1 id="第二章-static关键字"><a href="#第二章-static关键字" class="headerlink" title="第二章 static关键字"></a>第二章 static关键字</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>以前我们定义过如下类：</p><pre><code class="java">public class Student &#123;    // 成员变量    public String name;    public char sex; // &#39;男&#39;  &#39;女&#39;    public int age;    // 无参数构造器    public Student() &#123;    &#125;        // 有参数构造器    public Student(String  a) &#123;    &#125;&#125;</code></pre><p>我们已经知道面向对象中，存在类和对象的概念，我们在类中定义了一些成员变量，例如name,age,sex ,结果发现这些成员变量，每个对象都存在（因为每个对象都可以访问）。</p><p>而像name ,age , sex确实是每个学生对象都应该有的属性，应该属于每个对象。</p><p>所以Java中成员（<strong>变量和方法</strong>）等是存在所属性的，Java是通过static关键字来区分的。<strong>static关键字在Java开发非常的重要，对于理解面向对象非常关键。</strong></p><p>关于 <code>static</code> 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是<strong>属于类</strong>的是放在静态区中，没有static修饰的成员变量和方法则是<strong>属于对象</strong>的。我们上面案例中的成员变量都是没有static修饰的，所以属于每个对象。</p><h2 id="2-2-定义格式和使用"><a href="#2-2-定义格式和使用" class="headerlink" title="2.2 定义格式和使用"></a>2.2 定义格式和使用</h2><p>static是静态的意思。 static可以修饰成员变量或者修饰方法。</p><h3 id="2-2-1-静态变量及其访问"><a href="#2-2-1-静态变量及其访问" class="headerlink" title="2.2.1 静态变量及其访问"></a>2.2.1 静态变量及其访问</h3><p>有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为<strong>类变量</strong>或者<strong>静态成员变量</strong>。 直接用  类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。</p><p><strong>如何使用呢</strong></p><p>例如现在我们需要定义传智全部的学生类，那么这些学生类的对象的学校属性应该都是“传智”，这个时候我们可以把这个属性定义成static修饰的静态成员变量。</p><p><strong>定义格式</strong></p><pre><code class="java">修饰符 static 数据类型 变量名 = 初始值；    </code></pre><p><strong>举例</strong></p><pre><code class="java">public class Student &#123;    public static String schoolName = &quot;传智播客&quot;； // 属于类，只有一份。    // .....&#125;</code></pre><p><strong>静态成员变量的访问:</strong></p><p><strong>格式：类名.静态变量</strong></p><pre><code class="java">public static void  main(String[] args)&#123;    System.out.println(Student.schoolName); // 传智播客    Student.schoolName = &quot;黑马程序员&quot;;    System.out.println(Student.schoolName); // 黑马程序员&#125;</code></pre><h3 id="2-2-2-实例变量及其访问"><a href="#2-2-2-实例变量及其访问" class="headerlink" title="2.2.2 实例变量及其访问"></a>2.2.2 实例变量及其访问</h3><p>无static修饰的成员变量属于每个对象的，  这个成员变量叫<strong>实例变量</strong>，之前我们写成员变量就是实例成员变量。</p><p><strong>需要注意的是</strong>：实例成员变量属于每个对象，必须创建类的对象才可以访问。   </p><p><strong>格式：对象.实例成员变量</strong></p><h3 id="2-2-3-静态方法及其访问"><a href="#2-2-3-静态方法及其访问" class="headerlink" title="2.2.3 静态方法及其访问"></a>2.2.3 静态方法及其访问</h3><p>有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为<strong>类方法或者</strong>静态方法**。 直接用  类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。</p><p>与静态成员变量一样，静态方法也是直接通过<strong>类名.方法名称</strong>即可访问。</p><p><strong>举例</strong></p><pre><code class="java">public class Student&#123;    public static String schoolName = &quot;传智播客&quot;； // 属于类，只有一份。    // .....    public static void study()&#123;        System.out.println(&quot;我们都在黑马程序员学习&quot;);       &#125;&#125;</code></pre><p><strong>静态成员变量的访问:</strong></p><p><strong>格式：类名.静态方法</strong></p><pre><code class="java">public static void  main(String[] args)&#123;    Student.study();&#125;</code></pre><h3 id="2-2-4-实例方法及其访问"><a href="#2-2-4-实例方法及其访问" class="headerlink" title="2.2.4 实例方法及其访问"></a>2.2.4 实例方法及其访问</h3><p>无static修饰的成员方法属于每个对象的，  这个成员方法叫<strong>实例方法</strong>。</p><p><strong>需要注意的是</strong>：实例方法是属于每个对象，必须创建类的对象才可以访问。  </p><p><strong>格式：对象.实例方法</strong></p><p><strong>示例</strong>：</p><pre><code class="java">public class Student &#123;    // 实例变量    private String name ;    // 2.方法：行为    // 无 static修饰，实例方法。属于每个对象，必须创建对象调用    public void run()&#123;        System.out.println(&quot;学生可以跑步&quot;);    &#125;    // 无 static修饰，实例方法    public  void sleep()&#123;        System.out.println(&quot;学生睡觉&quot;);    &#125;    public static void study()&#123;            &#125;&#125;</code></pre><pre><code class="java">public static void main(String[] args)&#123;    // 创建对象     Student stu = new Student ;    stu.name = &quot;徐干&quot;;    // Student.sleep();// 报错，必须用对象访问。    stu.sleep();    stu.run();&#125;</code></pre><h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h2><p>1.当 <code>static</code> 修饰成员变量或者成员方法时，该变量称为<strong>静态变量</strong>，该方法称为<strong>静态方法</strong>。该类的每个对象都<strong>共享</strong>同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。</p><p>2.无static修饰的成员变量或者成员方法，称为<strong>实例变量，实例方法</strong>，实例变量和实例方法必须创建类的对象，然后通过对象来访问。</p><p>3.static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。</p><p>4.无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。</p><h1 id="第三章-继承"><a href="#第三章-继承" class="headerlink" title="第三章 继承"></a>第三章 继承</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><h3 id="3-1-1-引入"><a href="#3-1-1-引入" class="headerlink" title="3.1.1 引入"></a>3.1.1 引入</h3><p>假如我们要定义如下类:<br>学生类,老师类和工人类，分析如下。</p><ol><li><p>学生类<br>属性:姓名,年龄<br>行为:吃饭,睡觉</p></li><li><p>老师类<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，教书</p></li><li><p>班主任<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，管理</p></li></ol><p>如果我们定义了这三个类去开发一个系统，那么这三个类中就存在大量重复的信息（属性:姓名，年龄。行为：吃饭，睡觉）。这样就导致了相同代码大量重复，代码显得很臃肿和冗余，那么如何解决呢？</p><p>假如多个类中存在相同属性和行为时，我们可以将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要<strong>继承</strong>那一个类即可。如图所示：<br><img src="/img/java/imgs1/1.jpg"></p><p>其中，多个类可以称为<strong>子类</strong>，单独被继承的那一个类称为<strong>父类</strong>、<strong>超类（superclass）</strong>或者<strong>基类</strong>。</p><h3 id="3-1-2-继承的含义"><a href="#3-1-2-继承的含义" class="headerlink" title="3.1.2 继承的含义"></a>3.1.2 继承的含义</h3><p>继承描述的是事物之间的所属关系，这种关系是：<code>is-a</code> 的关系。例如，兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。</p><p><strong>继承</strong>：就是子类继承父类的<strong>属性</strong>和<strong>行为</strong>，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的<strong>非私有</strong>的属性和行为。</p><h3 id="3-1-3-继承的好处"><a href="#3-1-3-继承的好处" class="headerlink" title="3.1.3 继承的好处"></a>3.1.3 继承的好处</h3><ol><li>提高<strong>代码的复用性</strong>（减少代码冗余，相同代码重复利用）。</li><li>使类与类之间产生了关系。</li></ol><h2 id="3-2-继承的格式"><a href="#3-2-继承的格式" class="headerlink" title="3.2 继承的格式"></a>3.2 继承的格式</h2><p>通过 <code>extends</code> 关键字，可以声明一个子类继承另外一个父类，定义格式如下：</p><pre><code class="java">class 父类 &#123;    ...&#125;class 子类 extends 父类 &#123;    ...&#125;</code></pre><p><strong>需要注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。</strong></p><h2 id="3-3-继承案例"><a href="#3-3-继承案例" class="headerlink" title="3.3 继承案例"></a>3.3 继承案例</h2><h3 id="3-3-1-案例"><a href="#3-3-1-案例" class="headerlink" title="3.3.1 案例"></a>3.3.1 案例</h3><p>请使用继承定义以下类:</p><ol><li>学生类<br>属性:姓名,年龄<br>行为:吃饭,睡觉</li><li>老师类<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，教书</li><li>班主任<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，管理</li></ol><h3 id="3-3-2-案例图解分析"><a href="#3-3-2-案例图解分析" class="headerlink" title="3.3.2 案例图解分析"></a>3.3.2 案例图解分析</h3><p>老师类，学生类，还有班主任类，实际上都是属于人类的，我们可以定义一个人类，把他们相同的属性和行为都定义在人类中，然后继承人类即可，子类特有的属性和行为就定义在子类中了。</p><p>如下图所示。</p><p><img src="/img/java/imgs1/360%E6%88%AA%E5%9B%BE20181202211331250.jpg"></p><h3 id="3-3-3-案例代码实现"><a href="#3-3-3-案例代码实现" class="headerlink" title="3.3.3 案例代码实现"></a>3.3.3 案例代码实现</h3><p><strong>1.父类Human类</strong></p><pre><code class="java"> public class Human &#123;  // 合理隐藏  private String name ;  private int age ;    // 合理暴露  public String getName() &#123;      return name;  &#125;  public void setName(String name) &#123;      this.name = name;  &#125;  public int getAge() &#123;      return age;  &#125;  public void setAge(int age) &#123;      this.age = age;  &#125; &#125;</code></pre><p><strong>2.子类Teacher类</strong></p><pre><code class="java">public class Teacher extends Human &#123;  // 工资  private double salary ;    // 特有方法  public void teach()&#123;      System.out.println(&quot;老师在认真教技术！&quot;)；  &#125;  public double getSalary() &#123;      return salary;  &#125;  public void setSalary(double salary) &#123;      this.salary = salary;  &#125;&#125;</code></pre><p><strong>3.子类Student类</strong></p><pre><code class="java">public class Student extends Human&#123; &#125;</code></pre><p><strong>4.子类BanZhuren类</strong></p><pre><code class="java">public class Teacher extends Human &#123;    // 工资    private double salary ;           // 特有方法    public void admin()&#123;        System.out.println(&quot;班主任强调纪律问题！&quot;)；    &#125;        public double getSalary() &#123;        return salary;    &#125;    public void setSalary(double salary) &#123;        this.salary = salary;    &#125;&#125;</code></pre><p><strong>5.测试类</strong></p><pre><code class="java">public class Test &#123;    public static void main(String[] args) &#123;        Teacher dlei = new Teacher();        dlei.setName(&quot;播仔&quot;);        dlei.setAge(&quot;31&quot;);        dlei.setSalary(1000.99);        System.out.println(dlei.getName());        System.out.println(dlei.getAge());        System.out.println(dlei.getSalary());        dlei.teach();                BanZhuRen linTao = new BanZhuRen();        linTao.setName(&quot;灵涛&quot;);        linTao.setAge(&quot;28&quot;);        linTao.setSalary(1000.99);        System.out.println(linTao.getName());        System.out.println(linTao.getAge());        System.out.println(linTao.getSalary());        linTao.admin();        Student xugan = new Student();        xugan.setName(&quot;播仔&quot;);        xugan.setAge(&quot;31&quot;);        //xugan.setSalary(1000.99); // xugan没有薪水属性，报错！        System.out.println(xugan.getName());        System.out.println(xugan.getAge());    &#125;&#125;</code></pre><h3 id="3-3-4-小结"><a href="#3-3-4-小结" class="headerlink" title="3.3.4 小结"></a>3.3.4 小结</h3><p>1.继承实际上是子类相同的属性和行为可以定义在父类中，子类特有的属性和行为由自己定义，这样就实现了相同属性和行为的重复利用，从而提高了代码复用。</p><p>2.子类继承父类，就可以直接得到父类的成员变量和方法。是否可以继承所有成分呢？请看下节！</p><h2 id="3-4-子类不能继承的内容"><a href="#3-4-子类不能继承的内容" class="headerlink" title="3.4 子类不能继承的内容"></a>3.4 子类不能继承的内容</h2><h3 id="3-4-1-引入"><a href="#3-4-1-引入" class="headerlink" title="3.4.1 引入"></a>3.4.1 引入</h3><p>并不是父类的所有内容都可以给子类继承的：</p><p><strong>子类不能继承父类的构造器，因为子类有自己的构造器。</strong></p><p><strong>值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。</strong></p><h3 id="3-4-1-演示代码"><a href="#3-4-1-演示代码" class="headerlink" title="3.4.1 演示代码"></a>3.4.1 演示代码</h3><pre><code class="java">public class Demo03 &#123;    public static void main(String[] args) &#123;        Zi z = new Zi();        System.out.println(z.num1);//        System.out.println(z.num2); // 私有的子类无法使用        // 通过getter/setter方法访问父类的private成员变量        System.out.println(z.getNum2());        z.show1();        // z.show2(); // 私有的子类无法使用    &#125;&#125;class Fu &#123;    public int num1 = 10;    private int num2 = 20;    public void show1() &#123;        System.out.println(&quot;show1&quot;);    &#125;    private void show2() &#123;        System.out.println(&quot;show2&quot;);    &#125;    public int getNum2() &#123;        return num2;    &#125;    public void setNum2(int num2) &#123;        this.num2 = num2;    &#125;&#125;class Zi extends Fu &#123;&#125;</code></pre><h2 id="3-5-继承后的特点—成员变量"><a href="#3-5-继承后的特点—成员变量" class="headerlink" title="3.5 继承后的特点—成员变量"></a>3.5 继承后的特点—成员变量</h2><p>当类之间产生了继承关系后，其中各类中的成员变量，又产生了哪些影响呢？</p><h3 id="3-5-1-成员变量不重名"><a href="#3-5-1-成员变量不重名" class="headerlink" title="3.5.1 成员变量不重名"></a>3.5.1 成员变量不重名</h3><p>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<strong>没有影响的</strong>。代码如下：</p><pre><code class="java">class Fu &#123;    // Fu中的成员变量    int num = 5;&#125;class Zi extends Fu &#123;    // Zi中的成员变量    int num2 = 6;      // Zi中的成员方法    public void show() &#123;        // 访问父类中的num        System.out.println(&quot;Fu num=&quot;+num); // 继承而来，所以直接访问。        // 访问子类中的num2        System.out.println(&quot;Zi num2=&quot;+num2);    &#125;&#125;class Demo04 &#123;    public static void main(String[] args) &#123;        // 创建子类对象        Zi z = new Zi();           // 调用子类中的show方法        z.show();      &#125;&#125;演示结果：Fu num = 5Zi num2 = 6</code></pre><h3 id="3-5-2-成员变量重名"><a href="#3-5-2-成员变量重名" class="headerlink" title="3.5.2 成员变量重名"></a>3.5.2 成员变量重名</h3><p>如果子类父类中出现<strong>重名</strong>的成员变量，这时的访问是<strong>有影响的</strong>。代码如下：</p><pre><code class="java">class Fu1 &#123;    // Fu中的成员变量。    int num = 5;&#125;class Zi1 extends Fu1 &#123;    // Zi中的成员变量    int num = 6;      public void show() &#123;        // 访问父类中的num        System.out.println(&quot;Fu num=&quot; + num);        // 访问子类中的num        System.out.println(&quot;Zi num=&quot; + num);    &#125;&#125;class Demo04 &#123;    public static void main(String[] args) &#123;          // 创建子类对象        Zi1 z = new Zi1();           // 调用子类中的show方法        z1.show();     &#125;&#125;演示结果：Fu num = 6Zi num = 6</code></pre><p>子父类中出现了同名的成员变量时，子类会优先访问自己对象中的成员变量。如果此时想访问父类成员变量如何解决呢？我们可以使用super关键字。</p><h3 id="3-5-3-super访问父类成员变量"><a href="#3-5-3-super访问父类成员变量" class="headerlink" title="3.5.3  super访问父类成员变量"></a>3.5.3  super访问父类成员变量</h3><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用<code>super</code> 关键字，修饰父类成员变量，类似于之前学过的 <code>this</code> 。</p><p>需要注意的是：<strong>super代表的是父类对象的引用，this代表的是当前对象的引用。</strong></p><p><strong>使用格式：</strong></p><pre><code class="java">super.父类成员变量名</code></pre><p>子类方法需要修改，代码如下：</p><pre><code class="java">class Fu &#123;    // Fu中的成员变量。    int num = 5;&#125;class Zi extends Fu &#123;    // Zi中的成员变量    int num = 6;      public void show() &#123;        int num = 1;              // 访问方法中的num        System.out.println(&quot;method num=&quot; + num);        // 访问子类中的num        System.out.println(&quot;Zi num=&quot; + this.num);        // 访问父类中的num        System.out.println(&quot;Fu num=&quot; + super.num);    &#125;&#125;class Demo04 &#123;    public static void main(String[] args) &#123;          // 创建子类对象        Zi1 z = new Zi1();           // 调用子类中的show方法        z1.show();     &#125;&#125;演示结果：method num=1Zi num=6Fu num=5</code></pre><blockquote><p>小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。</p></blockquote><h2 id="3-6-继承后的特点—成员方法"><a href="#3-6-继承后的特点—成员方法" class="headerlink" title="3.6 继承后的特点—成员方法"></a>3.6 继承后的特点—成员方法</h2><p>当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？</p><h3 id="3-6-1-成员方法不重名"><a href="#3-6-1-成员方法不重名" class="headerlink" title="3.6.1 成员方法不重名"></a>3.6.1 成员方法不重名</h3><p>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响的</strong>。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下：</p><pre><code class="java">class Fu &#123;    public void show() &#123;        System.out.println(&quot;Fu类中的show方法执行&quot;);    &#125;&#125;class Zi extends Fu &#123;    public void show2() &#123;        System.out.println(&quot;Zi类中的show2方法执行&quot;);    &#125;&#125;public  class Demo05 &#123;    public static void main(String[] args) &#123;        Zi z = new Zi();         //子类中没有show方法，但是可以找到父类方法去执行        z.show();         z.show2();    &#125;&#125;</code></pre><h3 id="3-6-2-成员方法重名"><a href="#3-6-2-成员方法重名" class="headerlink" title="3.6.2 成员方法重名"></a>3.6.2 成员方法重名</h3><p>如果子类父类中出现<strong>重名</strong>的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法。</p><p>代码如下：</p><pre><code class="java">class Fu &#123;    public void show() &#123;        System.out.println(&quot;Fu show&quot;);    &#125;&#125;class Zi extends Fu &#123;    //子类重写了父类的show方法    public void show() &#123;        System.out.println(&quot;Zi show&quot;);    &#125;&#125;public class ExtendsDemo05&#123;    public static void main(String[] args) &#123;        Zi z = new Zi();         // 子类中有show方法，只执行重写后的show方法        z.show();  // Zi show    &#125;&#125;</code></pre><h2 id="3-7-方法重写"><a href="#3-7-方法重写" class="headerlink" title="3.7 方法重写"></a>3.7 方法重写</h2><h3 id="3-7-1-概念"><a href="#3-7-1-概念" class="headerlink" title="3.7.1 概念"></a>3.7.1 概念</h3><p><strong>方法重写</strong> ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现</strong>。</p><h3 id="3-7-2-使用场景与案例"><a href="#3-7-2-使用场景与案例" class="headerlink" title="3.7.2 使用场景与案例"></a>3.7.2 使用场景与案例</h3><p>发生在子父类之间的关系。<br>子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方 法。</p><p>例如：我们定义了一个动物类代码如下：</p><pre><code class="java">public class Animal  &#123;    public void run()&#123;        System.out.println(&quot;动物跑的很快！&quot;);    &#125;    public void cry()&#123;        System.out.println(&quot;动物都可以叫~~~&quot;);    &#125;&#125;</code></pre><p>然后定义一个猫类，猫可能认为父类cry()方法不能满足自己的需求</p><p>代码如下：</p><pre><code class="java">public class Cat extends Animal &#123;    public void cry()&#123;        System.out.println(&quot;我们一起学猫叫，喵喵喵！喵的非常好听！&quot;);    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;          // 创建子类对象          Cat ddm = new Cat()；        // 调用父类继承而来的方法        ddm.run();          // 调用子类重写的方法          ddm.cry();    &#125;&#125;</code></pre><h3 id="3-7-2-Override重写注解"><a href="#3-7-2-Override重写注解" class="headerlink" title="3.7.2 @Override重写注解"></a>3.7.2 @Override重写注解</h3><ul><li><p>@Override:注解，重写注解校验！</p></li><li><p>这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。</p></li><li><p>建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！</p><p>加上后的子类代码形式如下：</p><pre><code class="java">public class Cat extends Animal &#123;     // 声明不变，重新实现    // 方法名称与父类全部一样，只是方法体中的功能重写写了！    @Override    public void cry()&#123;        System.out.println(&quot;我们一起学猫叫，喵喵喵！喵的非常好听！&quot;);    &#125;&#125;</code></pre></li></ul><h3 id="3-7-3-注意事项"><a href="#3-7-3-注意事项" class="headerlink" title="3.7.3 注意事项"></a>3.7.3 注意事项</h3><ol><li>方法重写是发生在子父类之间的关系。</li><li>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li><li>子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</li></ol><h2 id="3-8-继承后的特点—构造器"><a href="#3-8-继承后的特点—构造器" class="headerlink" title="3.8 继承后的特点—构造器"></a>3.8 继承后的特点—构造器</h2><h3 id="3-8-1-引入"><a href="#3-8-1-引入" class="headerlink" title="3.8.1 引入"></a>3.8.1 引入</h3><p>当类之间产生了关系，其中各类中的构造器，又产生了哪些影响呢？<br>首先我们要回忆两个事情，构造器的定义格式和作用。</p><ol><li>构造器的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li><li>构造器的作用是初始化对象成员变量数据的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个<code>super()</code> ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。（<strong>先有爸爸，才能有儿子</strong>）</li></ol><p><strong>继承后子类构造器特点:子类所有构造器的第一行都会先调用父类的无参构造器，再执行自己</strong></p><h3 id="3-8-2-案例演示"><a href="#3-8-2-案例演示" class="headerlink" title="3.8.2 案例演示"></a>3.8.2 案例演示</h3><p>按如下需求定义类:</p><ol><li>人类<br>成员变量: 姓名,年龄<br>成员方法: 吃饭</li><li>学生类<br>成员变量: 姓名,年龄,成绩<br>成员方法: 吃饭</li></ol><p>代码如下：</p><pre><code class="java">class Person &#123;    private String name;    private int age;    public Person() &#123;        System.out.println(&quot;父类无参&quot;);    &#125;    // getter/setter省略&#125;class Student extends Person &#123;    private double score;    public Student() &#123;        //super(); // 调用父类无参,默认就存在，可以不写，必须再第一行        System.out.println(&quot;子类无参&quot;);    &#125;         public Student(double score) &#123;        //super();  // 调用父类无参,默认就存在，可以不写，必须再第一行        this.score = score;            System.out.println(&quot;子类有参&quot;);     &#125;&#125;public class Demo07 &#123;    public static void main(String[] args) &#123;        Student s1 = new Student();        System.out.println(&quot;----------&quot;);        Student s2 = new Student(99.9);    &#125;&#125;输出结果：父类无参子类无参----------父类无参子类有参</code></pre><h3 id="3-8-3-小结"><a href="#3-8-3-小结" class="headerlink" title="3.8.3 小结"></a>3.8.3 小结</h3><ul><li>子类构造器执行的时候，都会在第一行默认先调用父类无参数构造器一次。</li><li>子类构造器的第一行都隐含了一个**super()<strong>去调用父类无参数构造器，</strong>super()**可以省略不写。</li></ul><h2 id="3-9-super-…-和this-…"><a href="#3-9-super-…-和this-…" class="headerlink" title="3.9 super(…)和this(…)"></a>3.9 super(…)和this(…)</h2><h3 id="3-9-1-引入"><a href="#3-9-1-引入" class="headerlink" title="3.9.1  引入"></a>3.9.1  引入</h3><p>请看上节中的如下案例：</p><pre><code class="java">class Person &#123;    private String name;    private int age;    public Person() &#123;        System.out.println(&quot;父类无参&quot;);    &#125;    // getter/setter省略&#125;class Student extends Person &#123;    private double score;    public Student() &#123;        //super(); // 调用父类无参构造器,默认就存在，可以不写，必须再第一行        System.out.println(&quot;子类无参&quot;);    &#125;         public Student(double score) &#123;        //super();  // 调用父类无参构造器,默认就存在，可以不写，必须再第一行        this.score = score;            System.out.println(&quot;子类有参&quot;);     &#125;      // getter/setter省略&#125;public class Demo07 &#123;    public static void main(String[] args) &#123;        // 调用子类有参数构造器        Student s2 = new Student(99.9);        System.out.println(s2.getScore()); // 99.9        System.out.println(s2.getName()); // 输出 null        System.out.println(s2.getAge()); // 输出 0    &#125;&#125;</code></pre><p>我们发现，子类有参数构造器只是初始化了自己对象中的成员变量score，而父类中的成员变量name和age依然是没有数据的，怎么解决这个问题呢，我们可以借助与super(…)去调用父类构造器，以便初始化继承自父类对象的name和age.</p><h3 id="3-9-2-super和this的用法格式"><a href="#3-9-2-super和this的用法格式" class="headerlink" title="3.9.2 super和this的用法格式"></a>3.9.2 super和this的用法格式</h3><p>super和this完整的用法如下，其中this，super访问成员我们已经接触过了。</p><pre><code class="java">this.成员变量        --    本类的super.成员变量        --    父类的this.成员方法名()      --    本类的    super.成员方法名()   --    父类的</code></pre><p>接下来我们使用调用构造器格式：</p><pre><code class="java">super(...) -- 调用父类的构造器，根据参数匹配确认this(...) -- 调用本类的其他构造器，根据参数匹配确认</code></pre><h3 id="3-9-3-super-…-用法演示"><a href="#3-9-3-super-…-用法演示" class="headerlink" title="3.9.3 super(….)用法演示"></a>3.9.3 super(….)用法演示</h3><p>代码如下：</p><pre><code class="java">class Person &#123;    private String name =&quot;凤姐&quot;;    private int age = 20;    public Person() &#123;        System.out.println(&quot;父类无参&quot;);    &#125;        public Person(String name , int age)&#123;        this.name = name ;        this.age = age ;    &#125;    // getter/setter省略&#125;class Student extends Person &#123;    private double score = 100;    public Student() &#123;        //super(); // 调用父类无参构造器,默认就存在，可以不写，必须再第一行        System.out.println(&quot;子类无参&quot;);    &#125;         public Student(String name ， int age，double score) &#123;        super(name ,age);// 调用父类有参构造器Person(String name , int age)初始化name和age        this.score = score;            System.out.println(&quot;子类有参&quot;);     &#125;      // getter/setter省略&#125;public class Demo07 &#123;    public static void main(String[] args) &#123;        // 调用子类有参数构造器        Student s2 = new Student(&quot;张三&quot;，20，99);        System.out.println(s2.getScore()); // 99        System.out.println(s2.getName()); // 输出 张三        System.out.println(s2.getAge()); // 输出 20    &#125;&#125;</code></pre><p><strong>注意：</strong></p><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p><p>super(..)是根据参数去确定调用父类哪个构造器的。</p><h3 id="3-9-4-super-…-案例图解"><a href="#3-9-4-super-…-案例图解" class="headerlink" title="3.9.4 super(…)案例图解"></a>3.9.4 super(…)案例图解</h3><p><strong>父类空间优先于子类对象产生</strong></p><p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造七调用时，一定先调用父类的构造器。理解图解如下：</p><p><img src="/img/java/imgs1/2.jpg"></p><h3 id="3-9-5-this-…-用法演示"><a href="#3-9-5-this-…-用法演示" class="headerlink" title="3.9.5 this(…)用法演示"></a>3.9.5 this(…)用法演示</h3><p>this(…)</p><ul><li>   默认是去找本类中的其他构造器，根据参数来确定具体调用哪一个构造器。</li><li>   为了借用其他构造器的功能。</li></ul><pre><code class="java">package com.itheima._08this和super调用构造器;/** * this(...): *    默认是去找本类中的其他构造器，根据参数来确定具体调用哪一个构造器。 *    为了借用其他构造器的功能。 * */public class ThisDemo01 &#123;    public static void main(String[] args) &#123;        Student xuGan = new Student();        System.out.println(xuGan.getName()); // 输出:徐干        System.out.println(xuGan.getAge());// 输出:21        System.out.println(xuGan.getSex());// 输出： 男    &#125;&#125;class Student&#123;    private String name ;    private int age ;    private char sex ;    public Student() &#123;  // 很弱，我的兄弟很牛逼啊，我可以调用其他构造器：Student(String name, int age, char sex)        this(&quot;徐干&quot;,21,&#39;男&#39;);    &#125;    public Student(String name, int age, char sex) &#123;        this.name = name ;        this.age = age   ;        this.sex = sex   ;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public char getSex() &#123;        return sex;    &#125;    public void setSex(char sex) &#123;        this.sex = sex;    &#125;&#125;</code></pre><h3 id="3-9-6-小结"><a href="#3-9-6-小结" class="headerlink" title="3.9.6 小结"></a>3.9.6 小结</h3><ul><li><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p></li><li><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p></li><li><p><strong>super(..)和this(…)是根据参数去确定调用父类哪个构造器的。</strong></p></li><li><p>super(..)可以调用父类构造器初始化继承自父类的成员变量的数据。</p></li><li><p>this(..)可以调用本类中的其他构造器。</p></li></ul><h2 id="3-10-继承的特点"><a href="#3-10-继承的特点" class="headerlink" title="3.10 继承的特点"></a>3.10 继承的特点</h2><ol><li><p>Java只支持单继承，不支持多继承。</p><pre><code class="java">// 一个类只能有一个父类，不可以有多个父类。class A &#123;&#125;class B &#123;&#125;class C1 extends A &#123;&#125; // ok// class C2 extends A, B &#123;&#125; // error</code></pre></li><li><p>一个类可以有多个子类。</p><pre><code class="java">// A可以有多个子类class A &#123;&#125;class C1 extends A &#123;&#125;class C2 extends  A &#123;&#125;</code></pre></li><li><p>可以多层继承。</p><pre><code class="java">class A &#123;&#125;class C1 extends A &#123;&#125;class D extends C1 &#123;&#125;</code></pre><blockquote><p>顶层父类是Object类。所有的类默认继承Object，作为父类。</p></blockquote></li></ol><h1 id="第四章-引用类型使用小结-重点"><a href="#第四章-引用类型使用小结-重点" class="headerlink" title="第四章 引用类型使用小结(重点)"></a>第四章 引用类型使用小结(重点)</h1><p>​        实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类型也是可以的。在这我们使用两个例子 , 来学习一下。</p><h2 id="4-1-引用类型作为方法参数和返回值"><a href="#4-1-引用类型作为方法参数和返回值" class="headerlink" title="4.1 引用类型作为方法参数和返回值"></a>4.1 引用类型作为方法参数和返回值</h2><pre><code class="java">public class Person&#123;  public void eat()&#123;    System.out.println(&quot;吃饭&quot;);  &#125;&#125;public class Test&#123;  public static void main(String[] args)&#123;        method(new Person());           Person p = createPerson();  &#125;      //引用类型作为方法参数,在前面笔记本案例中我们也使用了接口类型作为方法参数  pubic static void method(Person p)&#123;       p.eat();  &#125;      //引用类型作为返回值  public static Person createPerson()&#123;        return new Person();  &#125;&#125;</code></pre><h2 id="4-2-引用类型作为成员变量"><a href="#4-2-引用类型作为成员变量" class="headerlink" title="4.2 引用类型作为成员变量"></a>4.2 引用类型作为成员变量</h2><p>​    我们每个人(Person)都有一个身份证(IDCard) , 为了表示这种关系 , 就需要在Person中定义一个IDCard的成员变量。定义Person类时，代码如下：</p><pre><code class="java">class Person &#123;    String name;//姓名    int age;//年龄&#125;</code></pre><p>​    使用使用<code>String</code> 类型表示姓名 , <code>int</code> 类型表示年龄。其实，<code>String</code>本身就是引用类型，我们往往忽略了它是引用类型。如果我们继续丰富这个类的定义，给<code>Person</code> 增加身份证号 , 身份证签发机关等属性，我们将如何编写呢？这时候就需要编写一个IDCard类了</p><p>定义IDCard(身份证)类，添加身份证号 , 签发地等属性：</p><pre><code class="java">class IDCard &#123;    String idNum;//身份证号    String authority;//签发地        //getter和setter方法      //...            //toString方法      //...&#125;</code></pre><p>修改Person类：</p><pre><code class="java">public class Person &#123;    String name;//姓名    int age;//年龄    IDCard idCard;//表示自己的身份证信息    //name和age的getter、setter方法    //...    public IDCard getIdCard() &#123;        return idCard;    &#125;    public void setIdCard(IDCard idCard) &#123;        this.idCard = idCard;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &quot;, idCard=&quot; + idCard +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="java">public class TestDemo &#123;    public static void main(String[] args) &#123;        //创建IDCard对象        IDCard idCard = new IDCard();        //设置身份证号        idCard.setIdNum(&quot;110113201606066666&quot;);        //设置签发地        idCard.setAuthority(&quot;北京市顺义区公安局&quot;);        //创建Person对象        Person p = new Person();        //设置姓名        p.setName(&quot;小顺子&quot;);        //设置年龄        p.setAge(2);        //设置身份证信息        p.setIdCard(idCard);        //打印小顺子的信息        System.out.println(p);    &#125;&#125;输出结果:Person&#123;name=&#39;小顺子&#39;, age=2, idCard=IDCard&#123;idNum=&#39;110113201606066666&#39;, authority=&#39;北京市顺义区公安局&#39;&#125;&#125;</code></pre><blockquote><p>类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。同理 , 接口也是如此 , 例如我们笔记本案例中使用usb设备。在此我们只是通过小例子 , 让大家熟识下引用类型的用法 , 后续在咱们的就业班学习中 , 这种方式会使用的很多。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day01【复习回顾、静态、继承、引用类型使用】&quot;&gt;&lt;a href=&quot;#day01【复习回顾、静态、继承、引用类型使用】&quot; class=&quot;headerlink&quot; title=&quot;day01【复习回顾、静态、继承、引用类型使用】&quot;&gt;&lt;/a&gt;day01【复习回顾、静态、</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java进阶13天资料" scheme="http://example.com/tags/java%E8%BF%9B%E9%98%B613%E5%A4%A9%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>软件项目管理笔记</title>
    <link href="http://example.com/2021/09/03/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2021/09/03/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</id>
    <published>2021-09-03T09:30:46.000Z</published>
    <updated>2021-09-04T15:54:55.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件项目管理"><a href="#软件项目管理" class="headerlink" title="软件项目管理"></a>软件项目管理</h1><blockquote><p><a href=""><strong>持续更新~</strong></a></p></blockquote><h2 id="第-1-章-软件项目管理概述"><a href="#第-1-章-软件项目管理概述" class="headerlink" title="第 1 章 软件项目管理概述"></a><strong>第 1 章 软件项目管理概述</strong></h2><h3 id="1-1-项目与软件项目"><a href="#1-1-项目与软件项目" class="headerlink" title="1.1  项目与软件项目"></a>1.1  项目与软件项目</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>项目(Project)是为了创造一个唯一的产品或提供一 个唯一的服务而进行的临时性的努力。</p><h4 id="项目的目标"><a href="#项目的目标" class="headerlink" title="项目的目标"></a>项目的目标</h4><ul><li>成果性目标</li><li>约束性目标</li></ul><h4 id="项目的目标的特性"><a href="#项目的目标的特性" class="headerlink" title="项目的目标的特性"></a>项目的目标的特性</h4><details green="" open="" style="box-sizing: border-box; display: block; padding: 16px; margin: 1em 0px; border-radius: 4px; background: rgb(255, 255, 255); font-size: 14px; transition: all 0.28s ease 0s; border: 1px solid rgba(61, 197, 80, 0.3);"><summary style="box-sizing: border-box; display: list-item; cursor: pointer; padding: 16px; margin: -16px -16px 0px; border-radius: 4px 4px 0px 0px; color: rgb(68, 68, 68); font-weight: bold; position: relative; line-height: normal; font-size: 0.875rem !important; background: rgb(235, 249, 237); border-bottom: 1px solid rgba(61, 197, 80, 0.3);">不同优先级</summary><div class="content" style="box-sizing: border-box; padding: 16px; margin: 0px -16px -16px;"><ul style="box-sizing: border-box; margin-top: 0.4rem; margin-bottom: 0px; padding: 0px 0px 0px 0.8rem; list-style: none; counter-reset: li 0;">            <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">项目约束性目标包括进度、成本、范围和质量，简称为项目目标三角形。除了这4个制约因素之外，还加上了风险和资源，并且最终要让客户满意。在实际项目中，他们之间的优先顺序通常由管理层决定。 </li></ul></div></details><details green="" open="" style="box-sizing: border-box; display: block; padding: 16px; margin: 1em 0px; border-radius: 4px; background: rgb(255, 255, 255); font-size: 14px; transition: all 0.28s ease 0s; border: 1px solid rgba(61, 197, 80, 0.3);"><summary style="box-sizing: border-box; display: list-item; cursor: pointer; padding: 16px; margin: -16px -16px 0px; border-radius: 4px 4px 0px 0px; color: rgb(68, 68, 68); font-weight: bold; position: relative; line-height: normal; font-size: 0.875rem !important; background: rgb(235, 249, 237); border-bottom: 1px solid rgba(61, 197, 80, 0.3);">层次性</summary><div class="content" style="box-sizing: border-box; padding: 16px; margin: 0px -16px -16px;"><ul style="box-sizing: border-box; margin-top: 0.4rem; margin-bottom: 0px; padding: 0px 0px 0px 0.8rem; list-style: none; counter-reset: li 0;">            <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">明确定义的项目目标按其意义和内容表示为一个层次结构，而且越较低层次的目标应该描述越清晰具体。清晰界定的某一层次目标通常直接作为初步的项目范围基准。 </li></ul></div></details><h4 id="项目的特征"><a href="#项目的特征" class="headerlink" title="项目的特征"></a>项目的特征</h4><details green="" open="" style="box-sizing: border-box; display: block; padding: 16px; margin: 1em 0px; border-radius: 4px; background: rgb(255, 255, 255); font-size: 14px; transition: all 0.28s ease 0s; border: 1px solid rgba(61, 197, 80, 0.3);"><summary style="box-sizing: border-box; display: list-item; cursor: pointer; padding: 16px; margin: -16px -16px 0px; border-radius: 4px 4px 0px 0px; color: rgb(68, 68, 68); font-weight: bold; position: relative; line-height: normal; font-size: 0.875rem !important; background: rgb(235, 249, 237); border-bottom: 1px solid rgba(61, 197, 80, 0.3);">特征</summary><div class="content" style="box-sizing: border-box; padding: 16px; margin: 0px -16px -16px;"><ul style="box-sizing: border-box; margin-top: 0.4rem; margin-bottom: 0px; padding: 0px 0px 0px 0.8rem; list-style: none; counter-reset: li 0;">    <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">有明确的目标</li>    <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">项目之间的活动具有相关性 </li>    <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">限定的周期 </li>        <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">有独特性 </li>            <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">资源成本的约束性  </li>                <li style="box-sizing: border-box; position: relative; margin: 0.2rem 0px; padding: 0.2em 0.2em 0.2em 1.4em;">项目的不确定性 </li>    </ul></div></details>**项目的三大特点：临时性、独特性和渐进明细性。**<h4 id="软件项目"><a href="#软件项目" class="headerlink" title="软件项目"></a>软件项目</h4><p>软件是计算机系统中与硬件相互依存的部分,它是包括程序、数据及相关文档的完整集合.</p><h4 id="软件项目的特殊性"><a href="#软件项目的特殊性" class="headerlink" title="软件项目的特殊性"></a>软件项目的特殊性</h4><ul><li>逻辑实体,具有抽象性</li><li>相互作用系统</li><li>变更</li><li>渐进明细</li></ul><h4 id="软件项目和日常运作区别"><a href="#软件项目和日常运作区别" class="headerlink" title="软件项目和日常运作区别"></a>软件项目和日常运作区别</h4><ul><li>项目是一次性的，日常运作是重复进行的</li><li>项目是以目标为导向的，日常运作是通过效率和有效性体现的</li><li>项目是通过与项目经理及其团队工作完成的，而日常运作是职能式的线形管理</li><li>大量的变更管理，而日常运作则基本保持持续的连贯性的</li><li>软件是逻辑实体，不是具体的物理实体，具有抽象性</li><li>软件的开发受计算机系统的限制，对硬件系统有不同程度的依赖</li><li>软件具有复杂性特点，其开发成本昂贵，制约因素很多</li></ul><h4 id="实现项目目标的制约因素"><a href="#实现项目目标的制约因素" class="headerlink" title="实现项目目标的制约因素"></a>实现项目目标的制约因素</h4><ul><li>工作范围</li><li>成本</li><li>进度计划</li><li>客户满意度</li></ul><h4 id="项目组合管理-Portfolio-、项目集-Programs-与项目-Project"><a href="#项目组合管理-Portfolio-、项目集-Programs-与项目-Project" class="headerlink" title="项目组合管理(Portfolio)、项目集(Programs)与项目(Project)"></a>项目组合管理(Portfolio)、项目集(Programs)与项目(Project)</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/xiangmuguanxi.jpg" alt="xiangmuguanxi"></h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/xiangmuguanxi.jpg" alt="xiangmuguanxi"></p><h3 id="1-2项目管理与软件项目管理"><a href="#1-2项目管理与软件项目管理" class="headerlink" title="1.2项目管理与软件项目管理"></a>1.2项目管理与软件项目管理</h3><h4 id="项目管理的定义"><a href="#项目管理的定义" class="headerlink" title="项目管理的定义"></a>项目管理的定义</h4><p>项目管理是一系列的伴随着项目的进行而进 行的、目的是为了确保项目能够达到期望的 结果的一系列管理行为。</p><h4 id="项目管理的主要内容"><a href="#项目管理的主要内容" class="headerlink" title="项目管理的主要内容"></a>项目管理的主要内容</h4><p>管理职能角度：项目计划、组织、人事安排、控制顿号协调</p><h4 id="软件开发项目管理定义"><a href="#软件开发项目管理定义" class="headerlink" title="软件开发项目管理定义"></a>软件开发项目管理定义</h4><p>软件项目管理是为了使软件项目能够按照‘预定的成本、进度、质量顺利完成，而对成本、人员、进度、质量、风险等进行分析和管理的活动。</p><h4 id="软件开发项目管理"><a href="#软件开发项目管理" class="headerlink" title="软件开发项目管理"></a>软件开发项目管理</h4><h4 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h4><ul><li>软件生产能力和业务发展需求不相适应的现象</li><li>就是弱的软件生产能力和强的业务发展需求之间的矛盾</li></ul><h4 id="软件开发项目管理的必要性"><a href="#软件开发项目管理的必要性" class="headerlink" title="软件开发项目管理的必要性"></a>软件开发项目管理的必要性</h4><p>无规则、混乱的开发状态，进度滞后，费用超支等失败的例子很多<br>业务失败，合同纠纷，法律诉讼，客户投诉等困扰软件业。</p><h4 id="软件项目管理的核心约束"><a href="#软件项目管理的核心约束" class="headerlink" title="软件项目管理的核心约束"></a>软件项目管理的核心约束</h4><p>确保软件项目满足进度,成本等约束,提交高质量软件产品(范围)</p><h3 id="1-3PMBOK与软件项目管理体系"><a href="#1-3PMBOK与软件项目管理体系" class="headerlink" title="1.3PMBOK与软件项目管理体系"></a>1.3PMBOK与软件项目管理体系</h3><h4 id="五个标准化过程"><a href="#五个标准化过程" class="headerlink" title="五个标准化过程"></a>五个标准化过程</h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/guanliguocheng.png" alt="guanliguocheng"></p><h4 id="PMBOK-9个知识领域的关系"><a href="#PMBOK-9个知识领域的关系" class="headerlink" title="PMBOK 9个知识领域的关系"></a>PMBOK 9<strong>个知识领域的关系</strong></h4><h4 id="PMBOK-9个知识领域的关系-img-软件项目管理-PMBOK-9个知识领域的关系-png"><a href="#PMBOK-9个知识领域的关系-img-软件项目管理-PMBOK-9个知识领域的关系-png" class="headerlink" title="![PMBOK 9个知识领域的关系](/img/软件项目管理/PMBOK 9个知识领域的关系.png)"></a>![PMBOK 9个知识领域的关系](/img/软件项目管理/PMBOK 9个知识领域的关系.png)</h4><h4 id="PMBOK-9-大过程领域"><a href="#PMBOK-9-大过程领域" class="headerlink" title="PMBOK 9 大过程领域"></a>PMBOK 9 <strong>大过程领域</strong></h4><p>![PMBOK 9 大过程领域](/img/软件项目管理/PMBOK 9 大过程领域.png)</p><h4 id="PMBOK-5-大过程组"><a href="#PMBOK-5-大过程组" class="headerlink" title="PMBOK 5 大过程组"></a>PMBOK 5 <strong>大过程组</strong></h4><h4 id="PMBOK-5-大过程组-img-软件项目管理-PMBOK-5-大过程组-png"><a href="#PMBOK-5-大过程组-img-软件项目管理-PMBOK-5-大过程组-png" class="headerlink" title="![PMBOK 5 大过程组](/img/软件项目管理/PMBOK 5 大过程组.png)"></a><strong>![PMBOK 5 大过程组](/img/软件项目管理/PMBOK 5 大过程组.png)</strong></h4><h3 id="1-4-敏捷项目管理"><a href="#1-4-敏捷项目管理" class="headerlink" title="1.4 敏捷项目管理"></a>1.4 敏捷项目管理</h3><h4 id="敏捷模型"><a href="#敏捷模型" class="headerlink" title="敏捷模型"></a>敏捷模型</h4><h4 id="敏捷宣言-4-价值"><a href="#敏捷宣言-4-价值" class="headerlink" title="敏捷宣言 - 4 价值"></a>敏捷宣言 - 4 价值</h4><ul><li><p>个体和互动 高于 流程和工具</p></li><li><p>可工作的软件 高于详尽的文档</p></li><li><p>客户合作 高于 合同谈判 </p></li><li><p>响应变化 高于遵循计划</p></li></ul><h4 id="敏捷原则"><a href="#敏捷原则" class="headerlink" title="敏捷原则"></a>敏捷原则</h4><ol><li>我们最重要的目标，是通过持续不断地及早交付有价值的软件来使客户满意。</li><li>欣然面对需求变化，即使在开发后期也一样，为了客户的竞争优势，要通过敏捷过程来适应变化。</li><li>经常性地交付可以工作的饮件，比如间隔几个星期或一两个月就交付，交付的时间间隔越短越好。</li><li>业务人员和开发人员必须相互合作，项目中的每一天都不例外。</li><li>激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支持，辅以信任，从而达成目标。</li><li>不论团队内外，效果最好且效率最高的传递信息的方式，就是面对面的交流。</li><li>可以工作的软件是首要的进度度量标准。</li><li>敏捷过程提倡可持续的开发速度。责任人、开发者和用户要能够共同维持其不断稳定延续。</li><li>坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。</li><li>以简洁为本，它是极力减少不必要工作量的艺术。</li><li>最好的架构、需求和设计出自自组织团队。</li><li>团队定期地反思如何能提高成效，并依此调整自身的举止行为。</li></ol><h3 id="1-5-软件项目管理过程"><a href="#1-5-软件项目管理过程" class="headerlink" title="1.5 软件项目管理过程"></a>1.5 软件项目管理过程</h3><h4 id="项目初始"><a href="#项目初始" class="headerlink" title="项目初始"></a>项目初始</h4><ul><li>项目确立</li><li>生存期</li></ul><h4 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h4><ul><li>范圉计划</li><li>成本计划</li><li>进度计划</li><li>质量计划</li><li>配署管理计划</li><li>团队计划</li><li>风险计划</li><li>合同计划</li></ul><h4 id="项目执行控制"><a href="#项目执行控制" class="headerlink" title="项目执行控制"></a>项目执行控制</h4><ul><li>集成计划执行控制</li><li>核心计划执行控制</li><li>辅助计划执行控制</li></ul><h4 id="项目结束"><a href="#项目结束" class="headerlink" title="项目结束"></a>项目结束</h4><h3 id="1-6-软件项目生命期"><a href="#1-6-软件项目生命期" class="headerlink" title="1.6 软件项目生命期"></a>1.6 软件项目生命期</h3><h4 id="生命期"><a href="#生命期" class="headerlink" title="生命期"></a>生命期</h4><p>六个周期</p><ul><li>计划阶段   定义系统，确定用户的要求或总体研究目标，提出可行的方案，包括资源、成本、效益、进度等的实施计划。进行可行性分析并制定粗略计划。</li><li>需求分析阶段   确定软件的功能、性能、可靠性、接口标准等要求，根据功能要求进行数据流程分析，提出初步的系统逻辑模型，并据此修改项目实施计划。</li><li>软件设计阶段   它包括系统概要设计和详细设计。在概要设计中，要建立系统的整体结构，进行模块划分，根据要求确定接口。在详细设计中，要建立算法、数据结构和流程图。 </li><li>编码阶段   把流程图翻译成程序，并对程序进行调试。</li><li>测试阶段   通过单元测试，检验模块内部的结构和功能；通过集成测试，把模块连接成系统，重点寻找接口上可能存在的问题；确认测试，即按照需求的内容逐项进行测试；系统测试，就是到实际的使用环境中进行测试。单元测试和集成测试由开发者自己完成，确认测试和系统测试则由用户参与完成。</li><li>运行维护阶段   它一般包括三类工作，为了修改错误而做的改正性维护；为了适应环境变化而做的适应性维护；为了适应用户新的需求而做的完善性维护，有时会成为二次开发，进入一个新的生命期，再从计划阶段开始。 </li></ul><blockquote><p>简述:</p><p>概念（Concept）<br>开发（Development）<br>实施（Implementation）<br>结束（Termination）</p></blockquote><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>检查点(Check Point) 它指在规定的时间间隔内对项目进行检查，比较实际现状与计划之间的差异，并根据差异进行调整</li><li>里程碑(Mile Stone)  它是完成阶段性工作的标志，不同类型的项目里程碑不同 </li><li>基线(Base Line)  它指一个(或一组)配置项在项目生命期的不同时间点上，通过正式评审而进入正式受控的一种状态</li></ul><h2 id="第-2-章-软件项确立"><a href="#第-2-章-软件项确立" class="headerlink" title="第 2 章 软件项确立"></a><strong>第 2 章 软件项确立</strong></h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><blockquote><p>合同是使卖方负有提供具体产品和服务的责任，买方负有为该产品和产品服务付款的责任的一种双方相互负有义务的协议。</p></blockquote><ul><li>合同定义了合同签署方的权利与义务，以及违背协议会造成的相应法律后果；</li><li>合同监督项目执行的各方履行其权利和义务，它是具有法律效力的文件；围绕合同，存在合同签署之前和合同签署之后的一系列工作。 </li></ul><h4 id="2-技术合同"><a href="#2-技术合同" class="headerlink" title="2. 技术合同"></a>2. 技术合同</h4><p><strong>软件项目合同主要是技术合同</strong></p><blockquote><p>技术合同是法人之间、法人和公民之间、公民之间以技术开发、技术转让、技术咨询和技术服务为内容，明确相互权利义务关系所达成的协议；</p><p>技术合同有三种环境：需（甲）方环境、供（乙）方环境和内部环境；<br>技术合同一般包括主合同和合同附件。 </p></blockquote><h4 id="3-技术合同内容"><a href="#3-技术合同内容" class="headerlink" title="3. 技术合同内容"></a>3. 技术合同内容</h4><ul><li>项目名称；</li><li>项目的技术内容、范围、形式和要求；</li><li>项目实施计划、进度、期限、地点和方式；</li><li>项目合同价款、报酬及其支付方式；</li><li>项目验收标准和方法；</li><li>各方当事人义务或协作责任；</li><li>技术成果归属和分享及后续改进的提供与分享规定；</li><li>技术保密事项；</li><li>风险责任的承担；</li><li>违约金或者损失赔偿额的计算方法、仲裁及其它。 </li></ul><h4 id="4-技术合同附件"><a href="#4-技术合同附件" class="headerlink" title="4. 技术合同附件"></a>4. 技术合同附件</h4><ul><li>系统的商务报价表；</li><li>系统的需求规格说明书；</li><li>项目的工程进度计划书；</li><li>技术服务承诺；</li><li>培训计划；</li><li>移交的用户文档和技术文档；</li><li>场地和环境准备要求；</li><li>测试与验收标准；</li><li>初验与终验报告样式范本；</li><li>工程实施的分工界面定义。</li></ul><h4 id="5-合同生存周期"><a href="#5-合同生存周期" class="headerlink" title="5. 合同生存周期"></a>5. 合同生存周期</h4><ul><li>合同准备</li><li>合同签署</li><li>合同管理</li><li>合同终止</li></ul><h3 id="2-2-需方合同环境-甲方"><a href="#2-2-需方合同环境-甲方" class="headerlink" title="2.2 需方合同环境(甲方)"></a>2.2 需方合同环境(甲方)</h3><blockquote><p>企业在需方合同环境下，关键要素是提供准确、清晰和完整的需求，选择合格的供方并对采购对象（采购对象包括产品服务、人力资源等）进行必要的验收。<br>这个需求可能来自于企业内部的需要，也可能是在为客户开发的软件项目中的一部分，通过寻找合适的软件开发商，将部分软件外包给其他的开发商。</p></blockquote><h4 id="合同准备"><a href="#合同准备" class="headerlink" title="合同准备"></a>合同准备</h4><ul><li><p>招标书定义(采购需求定义)  启动一个项目主要是由于存在一种需求，招标书定义主要是需方的需求定义，也就是甲方(买方)定义采购的内容。 </p><p><strong>招标书主要内容可分为三大部分：程序条款、技术条款、商务条款。</strong></p><p>包含下列主要九项内容：1、招标邀请函;2、投标人须知;3、招标项目的技术要求及附件;4、投标书格式;5、投标保证文件;6、合同条件(合同的一般条款及特殊条款);7、技术标准、规范;8、投标企业资格文件;9、合同格式。</p><blockquote><p>流程如下：</p><p>需方申请</p><p>需求定义</p><p>商务条件确定</p><p>验收标准确定</p><p>资料汇集</p><p>采购需求认可</p><p>编写招标文件</p><p>招标文件</p></blockquote></li><li><p>供方选择  招标文件确定后，就可以通过招标的方式选择供方（乙方或者卖方）。 </p><blockquote><p>流程如下：</p><p>招标文件</p><p>招标</p><p>手机供方的建议书</p><p>评定供方</p><p>最终供方确定</p><p>供方名单</p><p>建议书</p></blockquote></li><li><p>合同文本准备   如果需方选择了合适的供方（软件开发商），需方应该与供方（软件开发商）签订一个具有法律效力的合同；签署合同之前需要起草一份合同文本。 </p><blockquote><p>采购资料</p><p>合同草案指定</p><p>合同草案评审</p><p>合同草案修订</p><p>合同草案确定</p><p>合同草案</p></blockquote></li></ul><h4 id="合同签署"><a href="#合同签署" class="headerlink" title="合同签署"></a>合同签署</h4><blockquote><p>合同签署过程就是正式签署合同，使之成为具有法律效力的文件；<br>同时，根据签署的合同，分解出合同中需方(甲方)的任务，并下达任务书，指派相应的项目经理负责相应的过程。 </p></blockquote><ul><li>合同草案</li><li>谈判日程确定</li><li>合同草案提交</li><li>合同条款协商</li><li>合同签署文本确定</li><li>合同签署文本审阅</li><li>合同签署</li><li>合同签署文本</li><li>任务书下达</li></ul><h4 id="合同管理"><a href="#合同管理" class="headerlink" title="合同管理"></a>合同管理</h4><blockquote><p> 对于企业处于需方(甲方)的环境，合同管理是需方对供方(乙方)执行合同的情况进行监督的过程，</p></blockquote><p>主要包括：<br>对需求对象（采购对象）的验收  验收过程是需方对供方交付的产品或服务进行验收检验，以保证它满足合同条款的要求。<br>对违约事件处理  在合同的执行过程中，如果供方发生与合同要求不一致的问题，导致违约事件，需要执行违约事件处理过程。</p><p><strong>验收过程</strong></p><p><strong>违约处理</strong></p><h4 id="合同终止"><a href="#合同终止" class="headerlink" title="合同终止"></a>合同终止</h4><blockquote><p>当项目满足结束的条件，项目经理或者合同管理者应该及时宣布项目结束，终止合同的执行，通过合同终止过程告知各方合同终止</p></blockquote><p><strong>过程</strong></p><ul><li>合同</li><li>合同相关文档归档</li><li>合同终止通知</li><li>项目执行总结</li><li>项目总结</li></ul><h3 id="2-3-供方合同环境-乙方"><a href="#2-3-供方合同环境-乙方" class="headerlink" title="2.3 供方合同环境(乙方)"></a>2.3 供方合同环境(乙方)</h3><blockquote><p>企业在供方(乙方)合同环境下，关键要素是了解清楚需方（甲方）的要求并判断企业是否有能力来满足这些需求。<br>作为软件开发商，更多担任的是供方的角色。 </p></blockquote><h4 id="合同准备-1"><a href="#合同准备-1" class="headerlink" title="合同准备"></a>合同准备</h4><ul><li>项目分析  项目分析是供方分析用户的项目需求，并据此开发出—初步的项目计划，作为下一步能力评估和可行性分析之用。 </li><li>项目竞标<br>能力评估；<br>可行性分析；<br>参加竞标。</li><li>合同文本准备  一般是需方(甲方)提供合同的框架结构，并起草主要内容，供方(乙方)提供意见。 </li></ul><h4 id="合同签署-1"><a href="#合同签署-1" class="headerlink" title="合同签署"></a>合同签署</h4><ul><li>供方的合同签署过程也类似于需方的合同签署过程，但是这个阶段对于供方的意义是重大的，它标志着一个软件项目的有效开始，这个时候，应该正式确定供方的项目经理。</li><li>这里需要说明的是项目任务书，项目任务书明确项目的目标、必要的约束，同时授权给项目经理。</li><li><strong>项目任务书是项目正式开始的标志</strong>，同时也是对项目经理有效授权的依据。<br>项目经理需要对这个任务书进行确认。</li><li>具体活动描述可以参见需方的合同签署过程。</li></ul><h4 id="合同管理-1"><a href="#合同管理-1" class="headerlink" title="合同管理"></a>合同管理</h4><ul><li>合同跟踪管理过程</li><li>合同修改控制过程</li><li>违约事件处理过程</li><li>产品交付过程</li><li>产品维护过程</li></ul><h4 id="合同终止-1"><a href="#合同终止-1" class="headerlink" title="合同终止"></a>合同终止</h4><blockquote><p>在合同终止过程中，供方应该配合需方的工作，包括：项目的验收、双方认可签字、总结项目的经验教训、获取合同的最后款项、开具相应的发票、获取需方的合同终止的通知、将合同相关文件归档。</p></blockquote><p><strong>过程</strong></p><ul><li>合同</li><li>合同相关文档归档</li><li>合同终止通知</li><li>项目执行总结</li><li>项目总结</li></ul><h3 id="2-4-企业内部的合同环境"><a href="#2-4-企业内部的合同环境" class="headerlink" title="2.4 企业内部的合同环境"></a>2.4 企业内部的合同环境</h3><blockquote><p>企业内部项目实施管理的核心是确定任务范围和确保相关各方进行有效的配合，这可以通过相关各方之间的“协议”来保证，此处“协议”可视为“合同”。</p></blockquote><p>企业内部项目“合同”无特别的商业约束。 </p><p><strong>总结</strong></p><ul><li><p>软件项目技术合同的执行过程可以划分为四个阶段，即：合同准备、合同签署、合同管理与合同终止。</p></li><li><p>针对企业在不同合同环境中承担的不同角色，又可将合同管理分为需方合同管理、供方合同管理及内部合同管理。</p></li><li><p>作为软件企业，一般是处于供方(乙方)的角色，因此，软件企业的项目经理应该重点掌握供方(乙方)的合同管理过程。</p></li><li><p>合同标志一个项目的真正开始，通过项目任务单明确项目经理，从此，项目经理可以真正行使相应的职责和权力。</p></li></ul><h2 id="第-3-章-软件生存期模型"><a href="#第-3-章-软件生存期模型" class="headerlink" title="第 3 章 软件生存期模型"></a><strong>第 3 章 软件生存期模型</strong></h2><h3 id="3-1-CMM-和-ISO9000"><a href="#3-1-CMM-和-ISO9000" class="headerlink" title="3.1 CMM 和 ISO9000"></a>3.1 CMM 和 ISO9000</h3><h4 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h4><blockquote><p>为了保证软件产品的质量，1991年美国卡内基·梅隆大学软件工程研究所（CMU/SEI）将软件过程成熟度框架进化为软件能力成熟度模型（Capability Maturity Model For Software，简称SW-CMM），并发布了最早的SW-CMM 1.0版。<br>SW-CMM为软件企业的过程能力提供了一个阶梯式的进化框架，阶梯共有五级。</p><p>(1)初始级(initial)。工作无序，项目进行过程中常放弃当初的计划。管理无章法，缺乏健全的管理制度。开发项目成效不稳定，项目成功主要依靠项目负责人的经验和能力，他一但离去，工作秩序面目全非。</p><p>(2)可重复级(Repeatable)。管理制度化，建立了基本的管理制度和规程，管理工作有章可循。初步实现标准化，开发工作比较好地按标准实施。变更依法进行，做到基线化，稳定可跟踪，新项目的计划和管理基于过去的实践经验，具有重复以前成功项目的环境和条件。</p><p>(3)已定义级(Defined)。开发过程，包括技术工作和管理工作，均已实现标准化、文档化。建立了完善的培训制度和专家评审制度，全部技术活动和管理活动均可控制，对项目进行中的过程、岗位和职责均有共同的理解。</p><p>(4)已管理级(Managed)。产品和过程已建立了定量的质量目标。开发活动中的生产率和质量是可量度的。已建立过程数据库。已实现项目产品和过程的控制。可预测过程和产品质量趋势，如预测偏差，实现及时纠正。</p><p>(5)优化级(Optimizing)。可集中精力改进过程，采用新技术、新方法。拥有防止出现缺陷、识别薄弱环节以及加以改进的手段。可取得过程有效性的统计数据，并可据进行分析，从而得出最佳方法</p></blockquote><p><strong>概念描述</strong></p><ul><li><p>软件过程</p><blockquote><p>是指人们用于开发和维护软件及其相关产品的一系列活动、方法、实践和革新。</p></blockquote></li><li><p>软件开发过程管理</p><blockquote><p>是指在软件开发过程中，除了先进技术和开发方法外，还有一整套的管理技术。</p></blockquote></li><li><p>软件过程改进</p><blockquote><p>是针对软件生产过程中会对产品质量产生影响的问题而进行的，它的直接结果是软件过程能力的提高。<br>现在常见的软件过程改进方法：ISO 9000，SW-CMM和由多种能力模型演变而来的CMMI。</p></blockquote></li></ul><h4 id="KP"><a href="#KP" class="headerlink" title="KP"></a>KP</h4><p>除第一级外，SW-CMM的每一级都是按完全相同的结构组成的。每一级包含了实现这一级目标的若干关键过程域（KPA），每个KPA进一步包含若干关键实施活动（KP），无论哪个KPA，它们的实施活动都统一按六个公共属性进行组织，即每一个KPA都包含六类KP：</p><ol><li>目标</li><li>实施保证</li><li>实施能力  </li><li>执行活动  </li><li>度量分析</li><li>实施验证</li></ol><h4 id="CMMI"><a href="#CMMI" class="headerlink" title="CMMI"></a>CMMI</h4><blockquote><p>由于不同领域能力成熟度模型存在不同的过程改进，重复的培训、评估和改进活动以及活动不协调等一些问题。于是由美国国防部出面，美国卡内基·梅隆大学软件工程研究所（CMU/SEI）于2001年12月发布的CMMI 1.1版本包括四个领域：软件工程（SW）、系统工程（SE）、集成的产品和过程开发（IPPD）、采购（SS）。</p></blockquote><ul><li>CMMI有两种不同的实施方法<ul><li>连续式－－主要是衡量一个企业的项目能力</li><li>阶段式－－主要是衡量一个企业的成熟度</li></ul></li><li>CMMI的五个台阶<ul><li>完成级</li><li>管理级 </li><li>定义级 </li><li>量化管理级 </li><li>优化级 </li></ul></li><li>每一个台阶都是上面一阶台阶的基石。要上高层台阶必须首先踏上较低一层台阶。 </li></ul><h4 id="ISO9000"><a href="#ISO9000" class="headerlink" title="ISO9000"></a>ISO9000</h4><blockquote><p> 所谓“ISO9000”不是指一般意义上的一个质量保证标准，而是一族系列标准的统称。 </p></blockquote><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>强化品质管理，提高企业效益；增强客户信心，扩大市场份额；</li><li>获得了国际贸易“通行证”，消除了国际贸易壁垒；</li><li>节省了第二方审核的精力和费用；</li><li>在产品品质竞争中永远立于不败之地；</li><li>有效地避免产品责任；</li><li>有利于国际间的经济合作和技术交流。</li></ul><h4 id="三者之间的比较"><a href="#三者之间的比较" class="headerlink" title="三者之间的比较"></a>三者之间的比较</h4><ul><li>选择SW-CMM还是CMMI的考虑<ul><li>实施企业的业务特点。</li><li>实施企业对过程改进的熟悉程度。</li><li>实施企业对过程改进项目的预算。</li><li>实施企业是否可以使用阶段式的演进路线。</li><li>实施CMM与CMMI可以平滑的转换。</li></ul></li><li>ISO9001与CMM的关系<ul><li>ISO9001和CMM既有区别又相互联系，两者不可简单地互相替代。</li><li>取得ISO9001认证并不意味着完全满足CMM某个等级的要求。</li><li>取得CMM第2级(或第3级)不能笼统地认为可以满足ISO9001的要求。</li></ul></li></ul><h3 id="3-2-生存期的项目特征"><a href="#3-2-生存期的项目特征" class="headerlink" title="3.2 生存期的项目特征"></a>3.2 生存期的项目特征</h3><table><thead><tr><th align="left">方法(Approach)</th><th>项目需求</th><th>开发活动</th><th>产品交付</th><th>目标</th></tr></thead><tbody><tr><td align="left">预测型(Predictive)</td><td>稳定（Fixed）</td><td>对整个项目执行一次</td><td>只提交一次</td><td>管理成本</td></tr><tr><td align="left">迭代型（Iterative）</td><td>不断变化的（Dynamic）</td><td>不断重复直到正确</td><td>只提交一次</td><td>获得正确的解决方案</td></tr><tr><td align="left">增量型（Incremental）</td><td>不断变化的</td><td>每次增量活动只执行一次</td><td>多次提交小版本</td><td>速度</td></tr><tr><td align="left">敏捷型（Agile）</td><td>不断变化的</td><td>不断重复一些活动直到正确</td><td>多次提交小版本</td><td>获得用户肯定</td></tr></tbody></table><h4 id="预测生存期模型"><a href="#预测生存期模型" class="headerlink" title="预测生存期模型"></a>预测生存期模型</h4><p><strong>预测模型：</strong> 项目具有高确定性，有很明确的绣球，项目活动通常以顺序方式执行(无反馈)。</p><p><strong>流程：</strong> Analyze(分析)–&gt;Design(设计)–&gt;Build–&gt;Test–&gt;Deliver</p><p>如瀑布模型，V模型。</p><h4 id="迭代生存期模型"><a href="#迭代生存期模型" class="headerlink" title="迭代生存期模型"></a>迭代生存期模型</h4><p><strong>迭代模型：</strong> 是通过连续的原型和概念验证来改进产品或结果，每一个新的原型都能带来新的相关反馈和团队的见解。</p><p>迭代模型有利于识别和减少项目的不确定性，也称为原型模型。(优点：可应对需求变化，缺点：时间长)</p><h4 id="增量生存期模型"><a href="#增量生存期模型" class="headerlink" title="增量生存期模型"></a>增量生存期模型</h4><p><strong>增量模型：</strong> 一个增量一个增量的开发过程，每个增量是一个交付成果。即增量模型向客户提交完成的可交付的成功，让用户可以立即使用。</p><h4 id="敏捷生存期模型"><a href="#敏捷生存期模型" class="headerlink" title="敏捷生存期模型"></a>敏捷生存期模型</h4><p>敏捷模型是符合《敏捷宣言》原则的模型，客户满意度将随着有价值产品的早期交付和持续交付不断提升。此外，功能性的、提供价值的增量可交付成果是衡量进展的主要尺度。为了适应更频繁的变更，更频繁底交付项目价值，敏捷模型结合了迭代和增量模型的方法。</p><p>在敏捷开发环境中，团队假设需求会发生变更。迭代和增量方法能够提供反馈，一遍改善项目下一部分的计划。在敏捷项目中，增量交付会发现隐藏或误解的需求。</p><p>敏捷方法是一个囊括了各种框架和方法的涵盖性术语。</p><p>Scrum模型是敏捷模型的代表。</p><p>敏捷是多种方法的统称，如Scrum、XP、Scrumban、OpenUp、看板方法、精益(lean)、持续交付、devOps等。</p><h3 id="3-2-传统软件开发生命周期模型"><a href="#3-2-传统软件开发生命周期模型" class="headerlink" title="3.2 传统软件开发生命周期模型"></a>3.2 传统软件开发生命周期模型</h3><blockquote><p>软件从需求确定、设计、开发、测试直至投入使用，并在使用中不断地修改、增补和完善，直至被新的系统所替代而停止该软件的使用的全过程。</p></blockquote><p>可划分为以下子阶段 </p><p> 1.可行性研究</p><p>2.需求分析和问题定义</p><p>3.总体设计</p><p>4.详细设计</p><p>5.编码（实现）</p><p>6.软件测试、运行维护　　</p><p><strong>据此相继产生了瀑布模型、螺旋模型、进化模型、原型模型、增量模型等。</strong>本节分别对这几种传统的软件开发生命周期模型予以介绍。 </p><h4 id="1-瀑布模型"><a href="#1-瀑布模型" class="headerlink" title="1) 瀑布模型"></a>1) 瀑布模型</h4><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><ul><li>系统需求</li><li>软件需求</li><li>分析</li><li>设计</li><li>编码</li><li>测试</li><li>运行</li></ul><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/pubu.png" alt="pubu"></p><h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>文档驱动的模型</li><li>阶段间具有顺序性和依赖性</li><li>项目开发周期较长</li><li>实际项目很少按照该模型给出的顺序进行</li><li>客户必须能够完整、正确和清晰地表达他们的需求</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>容易理解，管理成本低；强调开发的阶段性早起计划及需求调查和产品测试。软件项目较小</p><h4 id="2-快速原型模型"><a href="#2-快速原型模型" class="headerlink" title="2) 快速原型模型"></a>2) 快速原型模型</h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/yuanxing.png" alt="yuanxing"></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>在需求定义之前，需要快速构建一个系统</li><li>先看界面，然后实现功能，<strong>根据构建系统的优缺点，用户给开发人员提出反馈意见</strong></li><li>根据反馈意见修改软件需求规格，以便系统可以更正确地反映用户的需求</li><li>减少各种假设以及风险</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>为了尽快完成原型，开发者没有考虑整体软件的质量和changing的可维护性，系统结构通常较差</li><li>可能混淆原型系统和最终系统</li><li>额外的开发费用</li></ul><h4 id="3-增量模型"><a href="#3-增量模型" class="headerlink" title="3) 增量模型"></a>3) 增量模型</h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E5%A2%9E%E9%87%8F.png" alt="增量"></p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li><p><strong>为避免一次性投资太多带来的风险</strong></p></li><li><p>融合了瀑布模型和原型的迭代特征。</p></li><li><p>每一个增量均发布一个可操作产品。</p></li><li><p>较短的时间向用户提交有用的功能</p></li><li><p>逐步增加产品的功能</p></li><li><p>项目失败风险低</p></li><li><p><strong>优先级最高的服务首先交付</strong>，意味着软件马上就能使用</p></li></ul><h5 id="使用条件-1"><a href="#使用条件-1" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li><p>如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；</p></li><li><p>如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发；</p></li><li><p>管理发生的成本、进度和配置的复杂性，可能会超出组织的能力。</p></li></ul><h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><p>Word 字处理软件</p><p>教务系统</p><h4 id="4）进化模型"><a href="#4）进化模型" class="headerlink" title="4）进化模型"></a>4）进化模型</h4><p>这个模型可看作是重复执行的多个瀑布模型。</p><p> <img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BF%9B%E5%8C%96.png" alt="进化"></p><h4 id="5-螺旋模型"><a href="#5-螺旋模型" class="headerlink" title="5) 螺旋模型"></a>5) 螺旋模型</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/luoxuan.png" alt="luoxuan"></h4><blockquote><p> 螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析，弥补了这两种模型的不足。</p></blockquote><h5 id="使用条件-2"><a href="#使用条件-2" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>基于风险驱动的开发模型, 使用原型法或其它方法来尽量降低风险。</li><li>适用于需求不明确的大规模软件项目</li></ul><h4 id="6-V模型"><a href="#6-V模型" class="headerlink" title="6) V模型"></a>6) V模型</h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/vmoxing.png" alt="vmoxing"></p><h5 id="使用条件-3"><a href="#使用条件-3" class="headerlink" title="使用条件"></a>使用条件</h5><p>甲方提供了详细，准确的需求文档，我们的解决方案也是很明确，且安全性要求非常的严格.</p><h3 id="3-3-扩展的软件开发生命周期模型"><a href="#3-3-扩展的软件开发生命周期模型" class="headerlink" title="3.3 扩展的软件开发生命周期模型"></a>3.3 扩展的软件开发生命周期模型</h3><h4 id="极限模型"><a href="#极限模型" class="headerlink" title="极限模型"></a>极限模型</h4><blockquote><p>2001年，为了避免许多公司的软件团队陷入不断增长的过程泥潭，一批业界专家一起概括出了一些敏捷开发过程的方法：SCRUM，Crystal，特征驱动软件开发（Feature Driven Development，简称FDD），自适应软件开发（Adaptive Software Development，简称ASD），以及最重要的极限编程（eXtreme Programming,简称XP）。 </p></blockquote><p>极限编程将开发阶段的4个活动（<strong>分析、设计、编码和测试</strong>）混合在一起，在全过程中采用迭代增量开发、反馈修正和反复测试。 </p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E6%9E%81%E9%99%90%E6%A8%A1%E5%9E%8B.png" alt="极限模型"></p><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><ul><li>交流（Communication）</li><li>简单（Simplicity ）</li><li>反馈（Feedback）</li><li>进取（Aggressiveness）</li></ul><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li>优点<ul><li>采用简单计划策略，不需要长期计划和复杂模型，开发周期短；</li><li>在全过程采用迭代增量开发、反馈修正和反复测试的方法，能够适应用户经常变化的需求。</li></ul></li><li>缺点<ul><li>目前主要在小规模项目上应用并取得成功，但是否适用于中等规模或大规模软件产品，需慎重考虑；</li><li>由于这个模型较新产品交付后维护成本是否降低，不能确定；<br>对编码人员的经验要求高</li></ul></li></ul><h4 id="Rational统一过程-（RUP）"><a href="#Rational统一过程-（RUP）" class="headerlink" title="Rational统一过程 （RUP）"></a>Rational统一过程 （RUP）</h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/rmp.png" alt="rmp"></p><ul><li>用例驱动<br>Concise, simple, and understandable </li><li>以体系结构为中心<br>Effective basis for large-scale reuse</li><li>增量和迭代开发<br>基于风险前驱的原则，渐进地展开分析、设计及其相关活动，每个迭代都会提供一次验证和调整模型机会，推动软件质量的提升。</li></ul><h4 id="Scrum模型"><a href="#Scrum模型" class="headerlink" title="Scrum模型"></a>Scrum模型</h4><p>2层的项目规划，迭代式的软件开发过程，4个管理会议。</p><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/scrum.png" alt="scrum"></p><h5 id="2层的项目规划"><a href="#2层的项目规划" class="headerlink" title="2层的项目规划"></a>2层的项目规划</h5><ul><li>体现为远期的项目计划和近期的计划，基于远粗近细的原则</li><li>远期计划和近期计划通过产品订单和冲刺订单体现</li><li>产品订单是所有需求的唯一来源，所有工作来自于它，开始阶段模糊，随着时间推移越来越明确。最高优先等级需求就是</li><li>当前冲刺订单，冲刺订单是当前迭代完成的任务清单。</li></ul><h5 id="迭代式的开发"><a href="#迭代式的开发" class="headerlink" title="迭代式的开发"></a>迭代式的开发</h5><ul><li>通过将整个软件交付过程分为多个迭代周期，一个迭代就是一个冲刺(Sprint)。</li><li>每个迭代周期2-4周，迭代内任务有详细的分解估算，可以分解到小时，迭代结束时提交一个运行版本。</li></ul><h5 id="4个管理会议"><a href="#4个管理会议" class="headerlink" title="4个管理会议"></a>4个管理会议</h5><p><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/sigeguanlihuiyi.png" alt="sigeguanlihuiyi"></p><h5 id="XP-eXtreme-Programming-极限编程模型"><a href="#XP-eXtreme-Programming-极限编程模型" class="headerlink" title="XP(eXtreme Programming) 极限编程模型"></a>XP(eXtreme Programming) 极限编程模型</h5><p>XP极限编程是由Kent Beck提出的一套针对业务需求和软件开发时间的规划。</p><h5 id="13个最佳实践"><a href="#13个最佳实践" class="headerlink" title="13个最佳实践"></a>13个最佳实践</h5><ul><li>整体实践：Whole Team，Customer Test，Small Releases(小版本)，Planing Game</li><li>开发团队实践：Collective Ownership，Coding Standard(编程标准)，Continuous Integration(持续集成)，Metaphor，</li><li>Sustainable Pace(恒定速度)</li><li>开发者实践：Test Driven，Development，Pair Programming，Simple Design，Refactoring(重构)</li></ul><h5 id="精益模型-lean-：-提倡持续不断的改进，减少流程中浪费。"><a href="#精益模型-lean-：-提倡持续不断的改进，减少流程中浪费。" class="headerlink" title="精益模型(lean)： 提倡持续不断的改进，减少流程中浪费。"></a>精益模型(lean)： 提倡持续不断的改进，减少流程中浪费。</h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/lean.png" alt="lean"></h5><h5 id="持续交付：-经典的敏捷软件开发延伸能够以较短周期完成需求的小粒度频繁交付。-持续集成，持续部署，持续交付"><a href="#持续交付：-经典的敏捷软件开发延伸能够以较短周期完成需求的小粒度频繁交付。-持续集成，持续部署，持续交付" class="headerlink" title="持续交付： 经典的敏捷软件开发延伸能够以较短周期完成需求的小粒度频繁交付。(持续集成，持续部署，持续交付)"></a>持续交付： 经典的敏捷软件开发延伸能够以较短周期完成需求的小粒度频繁交付。(持续集成，持续部署，持续交付)</h5><ul><li>持续集成：将个人代码像整体部分交付，以便尽早发现个人开发部分的问题</li><li>持续部署：集成的代码尽快向可运行的环境来交付，以便尽早测试</li><li>持续交付：尽快向客户交付以便尽早发现生产环境中存在的问题</li></ul><p>由持续交付演变成DevOps(Development和Operations的组合)融合一系列基本原则和实践的方法论。</p><h5 id="全程敏捷思维-开发段和运维端工作紧密合作"><a href="#全程敏捷思维-开发段和运维端工作紧密合作" class="headerlink" title="全程敏捷思维(开发段和运维端工作紧密合作)"></a>全程敏捷思维(开发段和运维端工作紧密合作)</h5><p>开发人员与运维人员的差异：开发人员希望尽快提交产品，运维端希望产品更加合理化，高性能，高可靠性，减少运维成本。</p><h5 id="DevOps：-是一组过程，方法与系统的统称，用于促进开发，技术运营和质量保障-QA-部门之间的沟通，协作与整合。"><a href="#DevOps：-是一组过程，方法与系统的统称，用于促进开发，技术运营和质量保障-QA-部门之间的沟通，协作与整合。" class="headerlink" title="DevOps： 是一组过程，方法与系统的统称，用于促进开发，技术运营和质量保障(QA)部门之间的沟通，协作与整合。"></a>DevOps： 是一组过程，方法与系统的统称，用于促进开发，技术运营和质量保障(QA)部门之间的沟通，协作与整合。</h5><h3 id="3-4-质量计划"><a href="#3-4-质量计划" class="headerlink" title="3.4 质量计划"></a>3.4 质量计划</h3><p>软件质量</p><blockquote><p>是“所有描述计算机软件优秀程度的特性的组合”</p></blockquote><p>软件质量度量模型有三层组成</p><ul><li>质量特性</li><li>质量子特性</li><li>度量</li></ul><h4 id="质量特性"><a href="#质量特性" class="headerlink" title="质量特性"></a>质量特性</h4><ul><li>功能性</li><li>可靠性</li><li>易使用性</li><li>高效性</li><li>可维护性</li><li>可移植性</li></ul><h4 id="质量规划"><a href="#质量规划" class="headerlink" title="质量规划"></a>质量规划</h4><blockquote><p>识别哪些质量标准适用于软件项目，并确定如何满足这些标准的需求</p></blockquote><h5 id="质量体系"><a href="#质量体系" class="headerlink" title="质量体系"></a>质量体系</h5><blockquote><p>指为保证产品，过程或服务质量，满足规定(或潜在)的要求，有组织机构，职责，程序，活动，能力和资源等构成的有机整体</p></blockquote><h5 id="质量手册"><a href="#质量手册" class="headerlink" title="质量手册"></a>质量手册</h5><blockquote><p>描述企业质量体系的文件</p></blockquote><h5 id="质量计划"><a href="#质量计划" class="headerlink" title="质量计划"></a>质量计划</h5><blockquote><p>质量管理的第一过程域</p></blockquote><h6 id="质量计划内容"><a href="#质量计划内容" class="headerlink" title="质量计划内容"></a>质量计划内容</h6><ul><li>项目实施总体目标<ul><li>质量</li><li>时间</li><li>成本</li></ul></li><li>项目分类<ul><li>质量倾斜型体系</li><li>工期倾斜型体系</li><li>成本倾斜型体系</li></ul></li><li>软件生命周期三大阶段<ul><li>软件定义</li><li>软件开发</li><li>软件使用和维护</li></ul></li></ul><h6 id="质量计划的编写"><a href="#质量计划的编写" class="headerlink" title="质量计划的编写"></a>质量计划的编写</h6><h4 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h4><ul><li>检测</li><li>控制</li></ul><h2 id="第-4-章-软件需求管理"><a href="#第-4-章-软件需求管理" class="headerlink" title="第 4 章 软件需求管理"></a><strong>第 4 章 软件需求管理</strong></h2><h2 id="第-5-章-软件项目任务分解"><a href="#第-5-章-软件项目任务分解" class="headerlink" title="第 5 章 软件项目任务分解"></a><strong>第 5 章 软件项目任务分解</strong></h2><h2 id="第-6-章-软件项目成本计划"><a href="#第-6-章-软件项目成本计划" class="headerlink" title="第 6 章 软件项目成本计划"></a><strong>第 6 章 软件项目成本计划</strong></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软件项目管理&quot;&gt;&lt;a href=&quot;#软件项目管理&quot; class=&quot;headerlink&quot; title=&quot;软件项目管理&quot;&gt;&lt;/a&gt;软件项目管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;&quot;&gt;&lt;strong&gt;持续更新~&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="软件项目管理" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="软件项目管理" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发之Scrum</title>
    <link href="http://example.com/2021/09/03/Scrum%E8%AE%B2%E8%A7%A3/"/>
    <id>http://example.com/2021/09/03/Scrum%E8%AE%B2%E8%A7%A3/</id>
    <published>2021-09-03T09:30:46.000Z</published>
    <updated>2021-09-05T10:22:46.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="敏捷开发之-Scrum"><a href="#敏捷开发之-Scrum" class="headerlink" title="敏捷开发之 Scrum"></a>敏捷开发之 Scrum</h1><h3 id="1-什么是敏捷开发？"><a href="#1-什么是敏捷开发？" class="headerlink" title="1.什么是敏捷开发？"></a>1.<strong>什么是敏捷开发？</strong></h3><p>敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方法。</p><p>怎么理解呢？首先，我们要理解它不是一门技术，它是一种开发方法，也就是一种软件开发的流程，它会指导我们用规定的环节去一步一步完成项目的开发；而这种开发方式的主要驱动核心是人；它采用的是迭代式开发；</p><h3 id="2-为什么说是以人为核心？"><a href="#2-为什么说是以人为核心？" class="headerlink" title="2.为什么说是以人为核心？"></a>2.<strong>为什么说是以人为核心？</strong></h3><p>我们大部分人都学过瀑布开发模型，它是以文档为驱动的，为什么呢？因为在瀑布的整个开发过程中，要写大量的文档，把需求文档写出来后，开发人员都是根据文档进行开发的，一切以文档为依据；而敏捷开发它只写有必要的文档，或尽量少写文档，敏捷开发注重的是人与人之间，面对面的交流，所以它强调以人为核心。</p><h3 id="3-什么是迭代？"><a href="#3-什么是迭代？" class="headerlink" title="3.什么是迭代？"></a>3.<strong>什么是迭代？</strong></h3><p>迭代是指把一个复杂且开发周期很长的开发任务，分解为很多小周期可完成的任务，这样的一个周期就是一次迭代的过程；同时每一次迭代都可以生产或开发出一个可以交付的软件产品。</p><h3 id="4-什么是Scrum？"><a href="#4-什么是Scrum？" class="headerlink" title="4.什么是Scrum？"></a>4.<strong>什么是Scrum？</strong></h3><p>Scrum的英文意思是橄榄球运动的一个专业术语，表示“争球”的动作；把一个开发流程的名字取名为Scrum，我想你一定能想象出你的开发团队在开发一个项目时，大家像打橄榄球一样迅速、富有战斗激情、人人你争我抢地完成它，你一定会感到非常兴奋的。</p><p>而Scrum就是这样的一个开发流程，运用该流程，你就能看到你团队高效的工作。</p><p>Scrum流程如下图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5zY3J1bWNuLmNvbS9hZ2lsZS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8wNC9TY3J1bUNOX1NjcnVtX1Byb2Nlc3NfNzEwLnBuZw?x-oss-process=image/format,png" alt="img"></p><h1 id="SCRUM框架"><a href="#SCRUM框架" class="headerlink" title="SCRUM框架"></a>SCRUM框架</h1><blockquote><p>Scrum框架包括3个角色、3个工件、5个事件、5个价值：</p></blockquote><h3 id="3个角色"><a href="#3个角色" class="headerlink" title="3个角色"></a>3个角色</h3><ol><li>产品负责人（Product Owner）主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。</li><li>流程管理员（Scrum Master）主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。</li><li>开发团队（Scrum Team）主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。</li></ol><h3 id="3个工件"><a href="#3个工件" class="headerlink" title="3个工件"></a>3个工件</h3><ol><li>产品Backlog（Product Backlog）</li><li>SprintBacklog</li><li>产品增量（Increment）</li></ol><h3 id="5个事件"><a href="#5个事件" class="headerlink" title="5个事件"></a>5个事件</h3><ol><li>Sprint（Sprint本身是一个事件，包括了如下4个事件）</li><li>Sprint计划会议（Sprint Planning Meeting）</li><li>每日站会（Daily Scrum Meeting）</li><li>Sprint评审会议（Sprint Review Meeting）</li><li>Sprint回顾会议（Sprint Retrospective Meeting）</li></ol><h3 id="5个价值"><a href="#5个价值" class="headerlink" title="5个价值"></a>5个价值</h3><ol><li>承诺 – 愿意对目标做出承诺</li><li>专注– 把你的心思和能力都用到你承诺的工作上去</li><li>开放– Scrum 把项目中的一切开放给每个人看</li><li>尊重– 每个人都有他独特的背景和经验</li><li>勇气– 有勇气做出承诺，履行承诺，接受别人的尊重</li></ol><h1 id="具体实施流程"><a href="#具体实施流程" class="headerlink" title="具体实施流程"></a>具体实施流程</h1><p><strong>什么是Sprint？</strong></p><p>Sprint是短距离赛跑的意思，这里面指的是一次迭代，而一次迭代的周期是1个月时间（即4个星期）或更短的限时，也就是我们要把一次迭代的开发内容以最快的速度完成它，这个过程我们称它为Sprint。</p><p><strong>如何进行Scrum开发？</strong></p><p>Scrum流程如下图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5zY3J1bWNuLmNvbS9hZ2lsZS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8wNC9TY3J1bUNOX1NjcnVtX1Byb2Nlc3NfNzEwLnBuZw?x-oss-process=image/format,png" alt="img"></p><p>1、我们首先需要确定一个Product Backlog（按优先顺序排列的一个产品需求列表），这个是由Product Owner 负责的；</p><p><img src="https://images.cnblogs.com/cnblogs_com/taven/201010/2010-10-17_202447.png" alt="img"></p><p>上图是一个 Product Backlog 的示例。</p><p>2、Scrum Team根据Product Backlog列表，做工作量的预估和安排；</p><p>3、有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出一个Story作为本次迭代完成的目标，这个目标的时间周期是1~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog；</p><p>4、Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更小的任务（细到每个任务的工作量在2天内能完成）；</p><p>5、在Scrum Team完成计划会议上选出的Sprint Backlog过程中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须发言，并且要向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）；</p><p><img src="https://images.cnblogs.com/cnblogs_com/taven/201010/2010-10-17_202749.png" alt="img"></p><p>上图就是每日的站立会议了，参会人员可以随意姿势站立，任务看板要保证让每个人看到，当每个人发言完后，要走到任务版前更新自己的燃尽图。</p><p><img src="http://images.cnblogs.com/cnblogs_com/taven/201010/2010-10-17_202812.png" alt="img"></p><p>任务看版包含 未完成、正在做、已完成 的工作状态，假设你今天把一个未完成的工作已经完成，那么你要把小卡片从未完成区域贴到已完成区域。</p><p>6、做到每日集成，也就是每天都要有一个可以成功编译、并且可以演示的版本；很多人可能还没有用过自动化的每日集成，其实TFS就有这个功能，它可以支持每次有成员进行签入操作的时候，在服务器上自动获取最新版本，然后在服务器中编译，如果通过则马上再执行单元测试代码，如果也全部通过，则将该版本发布，这时一次正式的签入操作才保存到TFS中，中间有任何失败，都会用邮件通知项目管理人员；</p><p>7、当一个Story完成，也就是Sprint Backlog被完成，也就表示一次Sprint完成，这时，我们要进行 Srpint Review Meeting（演示会议），也称为评审会议，产品负责人和客户都要参加（最好本公司老板也参加），每一个Scrum Team的成员都要向他们演示自己完成的软件产品（这个会议非常重要，一定不能取消）；</p><p>8、最后就是 Sprint Retrospective Meeting（回顾会议），也称为总结会议，以轮流发言方式进行，每个人都要发言，总结并讨论改进的地方，放入下一轮Sprint的产品需求中；</p><p>本文参考：</p><p> <a href="https://www.scrumcn.com/agile/scrum_guide.html">SCRUM官方权威指南</a></p><p> <a href="https://blog.csdn.net/inny100_100/article/details/54633757?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">敏捷项目管理流程-Scrum框架最全总结！</a></p><p> <a href="https://blog.csdn.net/iteye_4462/article/details/81936667?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">敏捷开发之Scrum扫盲篇</a></p><p><a href="https://www.bilibili.com/video/BV1gE411j71p?share_source=copy_web">微软资深大咖给您讲敏捷开发：软件开发Scrum开发过程</a></p><iframe src="//player.bilibili.com/player.html?aid=95631565&bvid=BV1gE411j71p&cid=163266188&page=1" scrolling="no" width="100%" height="500" border="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;敏捷开发之-Scrum&quot;&gt;&lt;a href=&quot;#敏捷开发之-Scrum&quot; class=&quot;headerlink&quot; title=&quot;敏捷开发之 Scrum&quot;&gt;&lt;/a&gt;敏捷开发之 Scrum&lt;/h1&gt;&lt;h3 id=&quot;1-什么是敏捷开发？&quot;&gt;&lt;a href=&quot;#1-什么是敏捷</summary>
      
    
    
    
    <category term="软件项目管理" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="软件项目管理 Scrum" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-Scrum/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/09/01/hello-world/"/>
    <id>http://example.com/2021/09/01/hello-world/</id>
    <published>2021-09-01T11:40:45.300Z</published>
    <updated>2021-09-01T11:40:45.300Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
