<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Day01 | ehZyiL的博客</title><meta name="keywords" content="java进阶13天资料"><meta name="author" content="ehZyiL"><meta name="copyright" content="ehZyiL"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="day01【复习回顾、静态、继承、引用类型使用】今日内容 复习回顾 定义类。一个Java文件可以定义多个类。但是只有一个类是用public修饰，public修饰的类名必须称为Java文件名。 类中有且仅有5大成分（五大金刚） 成员变量Field：描述类或者对象的属性信息的。 成员方法Method：描述类或者对象的行为的。 构造器（构造方法,Constructor）: 初始化类的一个对象返回。 代码">
<meta property="og:type" content="article">
<meta property="og:title" content="Day01">
<meta property="og:url" content="http://example.com/2021/09/05/JAVA/day01-%E5%A4%8D%E4%B9%A0%E5%9B%9E%E9%A1%BE%E3%80%81%E9%9D%99%E6%80%81%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="ehZyiL的博客">
<meta property="og:description" content="day01【复习回顾、静态、继承、引用类型使用】今日内容 复习回顾 定义类。一个Java文件可以定义多个类。但是只有一个类是用public修饰，public修饰的类名必须称为Java文件名。 类中有且仅有5大成分（五大金刚） 成员变量Field：描述类或者对象的属性信息的。 成员方法Method：描述类或者对象的行为的。 构造器（构造方法,Constructor）: 初始化类的一个对象返回。 代码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/java/cover.png">
<meta property="article:published_time" content="2021-09-05T02:30:46.000Z">
<meta property="article:modified_time" content="2021-09-05T03:00:14.467Z">
<meta property="article:author" content="ehZyiL">
<meta property="article:tag" content="java进阶13天资料">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/java/cover.png"><link rel="shortcut icon" href="/img/1.jpg"><link rel="canonical" href="http://example.com/2021/09/05/JAVA/day01-%E5%A4%8D%E4%B9%A0%E5%9B%9E%E9%A1%BE%E3%80%81%E9%9D%99%E6%80%81%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Day01',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-05 11:00:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="ehZyiL的博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/java/cover.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ehZyiL的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Day01</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-05T02:30:46.000Z" title="发表于 2021-09-05 10:30:46">2021-09-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-05T03:00:14.467Z" title="更新于 2021-09-05 11:00:14">2021-09-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Day01"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="day01【复习回顾、静态、继承、引用类型使用】"><a href="#day01【复习回顾、静态、继承、引用类型使用】" class="headerlink" title="day01【复习回顾、静态、继承、引用类型使用】"></a>day01【复习回顾、静态、继承、引用类型使用】</h1><h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><ul>
<li>复习回顾<ul>
<li>定义类。一个Java文件可以定义多个类。但是只有一个类是用public修饰，public修饰的类名必须称为Java文件名。</li>
<li>类中有且仅有5大成分（五大金刚）<ul>
<li>成员变量Field：描述类或者对象的属性信息的。</li>
<li>成员方法Method：描述类或者对象的行为的。</li>
<li>构造器（构造方法,Constructor）: 初始化类的一个对象返回。</li>
<li>代码块：还没有学。</li>
<li>内部类：还没有学。 </li>
</ul>
</li>
<li>封装<ul>
<li>面向对象的三大<strong>特征</strong>之一：<strong>封装，继承，多态</strong>。 </li>
<li>形成了规范，即使毫无意义还是会这样写代码！</li>
<li>合理隐藏，合理暴露。</li>
<li>封装的规范：成员变量私有，方法一般公开，提供成套的getter和setter方法暴露成员变量的取值和赋值。</li>
<li>封装的作用：提高安全性，提高代码的组件化思想。</li>
<li>封装已经成为Java代码的规范，即使毫无意义，我们也要这样写代码（成员变量私有，方法公开）</li>
</ul>
</li>
<li>this关键字<ul>
<li>this代表了当前对象的引用。</li>
<li>this可以出现在构造器和方法中。</li>
<li>this出现在构造器中代表构造器正在初始化的对象。</li>
<li>this出现在方法中，哪个对象调用方法，this就代表哪个对象。</li>
<li>this可以访问对象的成员变量，区分成员变量是局部的还是对象中的成员变量。</li>
</ul>
</li>
</ul>
</li>
<li>static关键字. <ul>
<li>静态。 </li>
<li>修饰方法和变量都是属于类的。没有static修饰的方法和变量是属于每个对象的。</li>
</ul>
</li>
<li>继承<ul>
<li>是面向对象的三大特征：封装，<strong>继承</strong>，多态。</li>
</ul>
</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够写出类的继承格式<ul>
<li><input disabled="" type="checkbox"> 子类 extends 父类{</li>
<li><input disabled="" type="checkbox"> }</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 能够说出继承的特点<ul>
<li><input disabled="" type="checkbox"> 类是单继承的，可以多层继承，可以有多个子类。</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 能够区分this和super的作用<ul>
<li><input disabled="" type="checkbox"> this代表本类对象引用<ul>
<li><input disabled="" type="checkbox"> this.本类成员变量</li>
<li><input disabled="" type="checkbox"> this.本类方法</li>
<li><input disabled="" type="checkbox"> this(…):访问兄弟构造器</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> super代表父类对象引用。<ul>
<li><input disabled="" type="checkbox"> super.父类变量</li>
<li><input disabled="" type="checkbox"> super.父类方法</li>
<li><input disabled="" type="checkbox"> super(…):访问父类构造器</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 能够说出方法重写的概念<ul>
<li><input disabled="" type="checkbox"> 方法重写：子类写一个方法覆盖父类的方法，子类以后用自己重写的方法。</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 能够说出方法重写的注意事项<ul>
<li><input disabled="" type="checkbox"> 1.重写方法的名称和形参列表要与父类被重写方法一致。</li>
<li><input disabled="" type="checkbox"> 2.重写方法的权限要与父类一样或者更大。 public &gt; protected &gt; 缺省 &gt; private</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 能够掌握static关键字修饰的变量调用方式<ul>
<li><input disabled="" type="checkbox"> 类名.静态变量</li>
<li><input disabled="" type="checkbox"> 对象.静态变量 （不推荐使用）</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 能够掌握static关键字修饰的方法调用方式<ul>
<li><input disabled="" type="checkbox"> 类名.静态方法</li>
<li><input disabled="" type="checkbox"> 对象.静态方法（不推荐使用）</li>
</ul>
</li>
</ul>
<h1 id="第一章-复习回顾"><a href="#第一章-复习回顾" class="headerlink" title="第一章 复习回顾"></a>第一章 复习回顾</h1><h2 id="1-1-如何定义类"><a href="#1-1-如何定义类" class="headerlink" title="1.1 如何定义类"></a>1.1 如何定义类</h2><p>类的定义格式如下:</p>
<pre><code class="java">修饰符 class 类名&#123;
    // 类中的五大成分。
    // 1.成员变量（属性）
    // 2.成员方法 (行为) 
    // 3.构造器 （初始化类的对象数据的）
    // 4.内部类
    // 5.代码块
&#125;
</code></pre>
<p>例如:</p>
<pre><code class="java">public class Student &#123;
    // 1.成员变量
    public String name ;
    public char sex ; // &#39;男&#39;  &#39;女&#39;
    public int age;
&#125;
</code></pre>
<h2 id="1-2-如何通过类创建对象"><a href="#1-2-如何通过类创建对象" class="headerlink" title="1.2 如何通过类创建对象"></a>1.2 如何通过类创建对象</h2><pre><code class="java">类名 对象名称 = new 类名();
</code></pre>
<p>例如:</p>
<pre><code class="java">Student stu = new Student();
</code></pre>
<h2 id="1-3-封装"><a href="#1-3-封装" class="headerlink" title="1.3 封装"></a>1.3 封装</h2><h4 id="1-3-1-封装的步骤"><a href="#1-3-1-封装的步骤" class="headerlink" title="1.3.1 封装的步骤"></a>1.3.1 封装的步骤</h4><p>1.使用 <code>private</code> 关键字来修饰成员变量。</p>
<p>2.使用<code>public</code>修饰getter和setter方法。</p>
<h4 id="1-3-2-封装的步骤实现"><a href="#1-3-2-封装的步骤实现" class="headerlink" title="1.3.2 封装的步骤实现"></a>1.3.2 封装的步骤实现</h4><ol>
<li>private修饰成员变量</li>
</ol>
<pre><code class="java">public class Student &#123;
    private String name;
    private int age;
&#125;
</code></pre>
<ol start="2">
<li>public修饰getter和setter方法</li>
</ol>
<pre><code class="java">public class Student &#123;
    private String name;
    private int age;

    public void setName(String n) &#123;
          name = n;
    &#125;

    public String getName() &#123;
          return name;
    &#125;

    public void setAge(int a) &#123;
        if (a &gt; 0 &amp;&amp; a &lt;200) &#123;
            age = a;
        &#125; else &#123;
            System.out.println(&quot;年龄非法！&quot;);
        &#125;
    &#125;

    public int getAge() &#123;
          return age;
    &#125;
&#125;
</code></pre>
<h2 id="1-4-构造器"><a href="#1-4-构造器" class="headerlink" title="1.4 构造器"></a>1.4 构造器</h2><h3 id="1-4-1-构造器的作用"><a href="#1-4-1-构造器的作用" class="headerlink" title="1.4.1 构造器的作用"></a>1.4.1 构造器的作用</h3><p>通过调用构造器可以返回一个类的对象，构造器同时负责帮我们把对象的数据（属性和行为等信息）初始化好。</p>
<h3 id="1-4-2-构造器的格式"><a href="#1-4-2-构造器的格式" class="headerlink" title="1.4.2 构造器的格式"></a>1.4.2 构造器的格式</h3><pre><code class="java">修饰符 类名(形参列表) &#123;
    // 构造体代码，执行代码
&#125;
</code></pre>
<h3 id="1-4-3-构造器的应用"><a href="#1-4-3-构造器的应用" class="headerlink" title="1.4.3 构造器的应用"></a>1.4.3 构造器的应用</h3><p>首先定义一个学生类，代码如下：</p>
<pre><code class="java">public class Student &#123;
    // 1.成员变量
    public String name;
    public int age;

    // 2.构造器
    public Student() &#123;
        System.out.println(&quot;无参数构造器被调用&quot;)；
    &#125;
&#125;
</code></pre>
<p>接下来通过调用构造器得到两个学生对象。</p>
<pre><code class="java">public class CreateStu02 &#123;
    public static void main(String[] args) &#123;
        // 创建一个学生对象
        // 类名 变量名称 = new 类名();
        Student s1 = new Student();
        // 使用对象访问成员变量，赋值
        s1.name = &quot;张三&quot;;
        s1.age = 20 ;

        // 使用对象访问成员变量 输出值
        System.out.println(s1.name);
        System.out.println(s1.age); 

        Student s2 = new Student();
        // 使用对象访问成员变量 赋值
        s2.name = &quot;李四&quot;;
        s2.age = 18 ;
        System.out.println(s2.name);
        System.out.println(s2.age);
    &#125;
&#125;
</code></pre>
<h2 id="1-5-this关键字的作用"><a href="#1-5-this关键字的作用" class="headerlink" title="1.5 this关键字的作用"></a>1.5 this关键字的作用</h2><h3 id="1-5-1-this关键字的作用"><a href="#1-5-1-this关键字的作用" class="headerlink" title="1.5.1 this关键字的作用"></a>1.5.1 this关键字的作用</h3><p>this代表所在类的当前对象的引用（地址值），即代表当前对象。</p>
<h3 id="1-5-2-this关键字的应用"><a href="#1-5-2-this关键字的应用" class="headerlink" title="1.5.2 this关键字的应用"></a>1.5.2 this关键字的应用</h3><h4 id="1-5-2-1-用于普通的gettter与setter方法"><a href="#1-5-2-1-用于普通的gettter与setter方法" class="headerlink" title="1.5.2.1 用于普通的gettter与setter方法"></a>1.5.2.1 用于普通的gettter与setter方法</h4><p>this出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。</p>
<pre><code class="java">public class Student &#123;
    private String name;
    private int age;

    public void setName(String name) &#123;
          this.name = name;
    &#125;

    public String getName() &#123;
          return name;
    &#125;

    public void setAge(int age) &#123;
        if (age &gt; 0 &amp;&amp; age &lt; 200) &#123;
            this.age = age;
        &#125; else &#123;
            System.out.println(&quot;年龄非法！&quot;);
        &#125;
    &#125;

    public int getAge() &#123;
          return age;
    &#125;
&#125;
</code></pre>
<h4 id="1-5-2-2-用于构造器中"><a href="#1-5-2-2-用于构造器中" class="headerlink" title="1.5.2.2 用于构造器中"></a>1.5.2.2 用于构造器中</h4><p>this出现在构造器中，代表构造器正在初始化的那个对象。</p>
<pre><code class="java">public class Student &#123;
    private String name;
    private int age;
    
    // 无参数构造方法
    public Student() &#123;&#125; 
    
    // 有参数构造方法
    public Student(String name,int age) &#123;
        this.name = name;
        this.age = age; 
    &#125;
&#125;
</code></pre>
<h1 id="第二章-static关键字"><a href="#第二章-static关键字" class="headerlink" title="第二章 static关键字"></a>第二章 static关键字</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>以前我们定义过如下类：</p>
<pre><code class="java">public class Student &#123;
    // 成员变量
    public String name;
    public char sex; // &#39;男&#39;  &#39;女&#39;
    public int age;

    // 无参数构造器
    public Student() &#123;

    &#125;
    
    // 有参数构造器
    public Student(String  a) &#123;

    &#125;
&#125;
</code></pre>
<p>我们已经知道面向对象中，存在类和对象的概念，我们在类中定义了一些成员变量，例如name,age,sex ,结果发现这些成员变量，每个对象都存在（因为每个对象都可以访问）。</p>
<p>而像name ,age , sex确实是每个学生对象都应该有的属性，应该属于每个对象。</p>
<p>所以Java中成员（<strong>变量和方法</strong>）等是存在所属性的，Java是通过static关键字来区分的。<strong>static关键字在Java开发非常的重要，对于理解面向对象非常关键。</strong></p>
<p>关于 <code>static</code> 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是<strong>属于类</strong>的是放在静态区中，没有static修饰的成员变量和方法则是<strong>属于对象</strong>的。我们上面案例中的成员变量都是没有static修饰的，所以属于每个对象。</p>
<h2 id="2-2-定义格式和使用"><a href="#2-2-定义格式和使用" class="headerlink" title="2.2 定义格式和使用"></a>2.2 定义格式和使用</h2><p>static是静态的意思。 static可以修饰成员变量或者修饰方法。</p>
<h3 id="2-2-1-静态变量及其访问"><a href="#2-2-1-静态变量及其访问" class="headerlink" title="2.2.1 静态变量及其访问"></a>2.2.1 静态变量及其访问</h3><p>有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为<strong>类变量</strong>或者<strong>静态成员变量</strong>。 直接用  类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。</p>
<p><strong>如何使用呢</strong></p>
<p>例如现在我们需要定义传智全部的学生类，那么这些学生类的对象的学校属性应该都是“传智”，这个时候我们可以把这个属性定义成static修饰的静态成员变量。</p>
<p><strong>定义格式</strong></p>
<pre><code class="java">修饰符 static 数据类型 变量名 = 初始值；    
</code></pre>
<p><strong>举例</strong></p>
<pre><code class="java">public class Student &#123;
    public static String schoolName = &quot;传智播客&quot;； // 属于类，只有一份。
    // .....
&#125;
</code></pre>
<p><strong>静态成员变量的访问:</strong></p>
<p><strong>格式：类名.静态变量</strong></p>
<pre><code class="java">public static void  main(String[] args)&#123;
    System.out.println(Student.schoolName); // 传智播客
    Student.schoolName = &quot;黑马程序员&quot;;
    System.out.println(Student.schoolName); // 黑马程序员
&#125;
</code></pre>
<h3 id="2-2-2-实例变量及其访问"><a href="#2-2-2-实例变量及其访问" class="headerlink" title="2.2.2 实例变量及其访问"></a>2.2.2 实例变量及其访问</h3><p>无static修饰的成员变量属于每个对象的，  这个成员变量叫<strong>实例变量</strong>，之前我们写成员变量就是实例成员变量。</p>
<p><strong>需要注意的是</strong>：实例成员变量属于每个对象，必须创建类的对象才可以访问。   </p>
<p><strong>格式：对象.实例成员变量</strong></p>
<h3 id="2-2-3-静态方法及其访问"><a href="#2-2-3-静态方法及其访问" class="headerlink" title="2.2.3 静态方法及其访问"></a>2.2.3 静态方法及其访问</h3><p>有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为<strong>类方法或者</strong>静态方法**。 直接用  类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。</p>
<p>与静态成员变量一样，静态方法也是直接通过<strong>类名.方法名称</strong>即可访问。</p>
<p><strong>举例</strong></p>
<pre><code class="java">public class Student&#123;
    public static String schoolName = &quot;传智播客&quot;； // 属于类，只有一份。
    // .....
    public static void study()&#123;
        System.out.println(&quot;我们都在黑马程序员学习&quot;);   
    &#125;
&#125;
</code></pre>
<p><strong>静态成员变量的访问:</strong></p>
<p><strong>格式：类名.静态方法</strong></p>
<pre><code class="java">public static void  main(String[] args)&#123;
    Student.study();
&#125;
</code></pre>
<h3 id="2-2-4-实例方法及其访问"><a href="#2-2-4-实例方法及其访问" class="headerlink" title="2.2.4 实例方法及其访问"></a>2.2.4 实例方法及其访问</h3><p>无static修饰的成员方法属于每个对象的，  这个成员方法叫<strong>实例方法</strong>。</p>
<p><strong>需要注意的是</strong>：实例方法是属于每个对象，必须创建类的对象才可以访问。  </p>
<p><strong>格式：对象.实例方法</strong></p>
<p><strong>示例</strong>：</p>
<pre><code class="java">public class Student &#123;
    // 实例变量
    private String name ;
    // 2.方法：行为
    // 无 static修饰，实例方法。属于每个对象，必须创建对象调用
    public void run()&#123;
        System.out.println(&quot;学生可以跑步&quot;);
    &#125;
    // 无 static修饰，实例方法
    public  void sleep()&#123;
        System.out.println(&quot;学生睡觉&quot;);
    &#125;
    public static void study()&#123;
        
    &#125;
&#125;
</code></pre>
<pre><code class="java">public static void main(String[] args)&#123;
    // 创建对象 
    Student stu = new Student ;
    stu.name = &quot;徐干&quot;;
    // Student.sleep();// 报错，必须用对象访问。
    stu.sleep();
    stu.run();
&#125;
</code></pre>
<h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h2><p>1.当 <code>static</code> 修饰成员变量或者成员方法时，该变量称为<strong>静态变量</strong>，该方法称为<strong>静态方法</strong>。该类的每个对象都<strong>共享</strong>同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。</p>
<p>2.无static修饰的成员变量或者成员方法，称为<strong>实例变量，实例方法</strong>，实例变量和实例方法必须创建类的对象，然后通过对象来访问。</p>
<p>3.static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。</p>
<p>4.无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。</p>
<h1 id="第三章-继承"><a href="#第三章-继承" class="headerlink" title="第三章 继承"></a>第三章 继承</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><h3 id="3-1-1-引入"><a href="#3-1-1-引入" class="headerlink" title="3.1.1 引入"></a>3.1.1 引入</h3><p>假如我们要定义如下类:<br>学生类,老师类和工人类，分析如下。</p>
<ol>
<li><p>学生类<br>属性:姓名,年龄<br>行为:吃饭,睡觉</p>
</li>
<li><p>老师类<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，教书</p>
</li>
<li><p>班主任<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，管理</p>
</li>
</ol>
<p>如果我们定义了这三个类去开发一个系统，那么这三个类中就存在大量重复的信息（属性:姓名，年龄。行为：吃饭，睡觉）。这样就导致了相同代码大量重复，代码显得很臃肿和冗余，那么如何解决呢？</p>
<p>假如多个类中存在相同属性和行为时，我们可以将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要<strong>继承</strong>那一个类即可。如图所示：<br><img src="/img/java/imgs1/1.jpg"></p>
<p>其中，多个类可以称为<strong>子类</strong>，单独被继承的那一个类称为<strong>父类</strong>、<strong>超类（superclass）</strong>或者<strong>基类</strong>。</p>
<h3 id="3-1-2-继承的含义"><a href="#3-1-2-继承的含义" class="headerlink" title="3.1.2 继承的含义"></a>3.1.2 继承的含义</h3><p>继承描述的是事物之间的所属关系，这种关系是：<code>is-a</code> 的关系。例如，兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。</p>
<p><strong>继承</strong>：就是子类继承父类的<strong>属性</strong>和<strong>行为</strong>，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的<strong>非私有</strong>的属性和行为。</p>
<h3 id="3-1-3-继承的好处"><a href="#3-1-3-继承的好处" class="headerlink" title="3.1.3 继承的好处"></a>3.1.3 继承的好处</h3><ol>
<li>提高<strong>代码的复用性</strong>（减少代码冗余，相同代码重复利用）。</li>
<li>使类与类之间产生了关系。</li>
</ol>
<h2 id="3-2-继承的格式"><a href="#3-2-继承的格式" class="headerlink" title="3.2 继承的格式"></a>3.2 继承的格式</h2><p>通过 <code>extends</code> 关键字，可以声明一个子类继承另外一个父类，定义格式如下：</p>
<pre><code class="java">class 父类 &#123;
    ...
&#125;

class 子类 extends 父类 &#123;
    ...
&#125;
</code></pre>
<p><strong>需要注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。</strong></p>
<h2 id="3-3-继承案例"><a href="#3-3-继承案例" class="headerlink" title="3.3 继承案例"></a>3.3 继承案例</h2><h3 id="3-3-1-案例"><a href="#3-3-1-案例" class="headerlink" title="3.3.1 案例"></a>3.3.1 案例</h3><p>请使用继承定义以下类:</p>
<ol>
<li>学生类<br>属性:姓名,年龄<br>行为:吃饭,睡觉</li>
<li>老师类<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，教书</li>
<li>班主任<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，管理</li>
</ol>
<h3 id="3-3-2-案例图解分析"><a href="#3-3-2-案例图解分析" class="headerlink" title="3.3.2 案例图解分析"></a>3.3.2 案例图解分析</h3><p>老师类，学生类，还有班主任类，实际上都是属于人类的，我们可以定义一个人类，把他们相同的属性和行为都定义在人类中，然后继承人类即可，子类特有的属性和行为就定义在子类中了。</p>
<p>如下图所示。</p>
<p><img src="/img/java/imgs1/360%E6%88%AA%E5%9B%BE20181202211331250.jpg"></p>
<h3 id="3-3-3-案例代码实现"><a href="#3-3-3-案例代码实现" class="headerlink" title="3.3.3 案例代码实现"></a>3.3.3 案例代码实现</h3><p><strong>1.父类Human类</strong></p>
<pre><code class="java"> public class Human &#123;
  // 合理隐藏
  private String name ;
  private int age ;
  
  // 合理暴露
  public String getName() &#123;
      return name;
  &#125;

  public void setName(String name) &#123;
      this.name = name;
  &#125;

  public int getAge() &#123;
      return age;
  &#125;

  public void setAge(int age) &#123;
      this.age = age;
  &#125;
 &#125;
</code></pre>
<p><strong>2.子类Teacher类</strong></p>
<pre><code class="java">public class Teacher extends Human &#123;
  // 工资
  private double salary ;
  
  // 特有方法
  public void teach()&#123;
      System.out.println(&quot;老师在认真教技术！&quot;)；
  &#125;

  public double getSalary() &#123;
      return salary;
  &#125;

  public void setSalary(double salary) &#123;
      this.salary = salary;
  &#125;
&#125;
</code></pre>
<p><strong>3.子类Student类</strong></p>
<pre><code class="java">public class Student extends Human&#123;
 
&#125;
</code></pre>
<p><strong>4.子类BanZhuren类</strong></p>
<pre><code class="java">public class Teacher extends Human &#123;
    // 工资
    private double salary ;
    
       // 特有方法
    public void admin()&#123;
        System.out.println(&quot;班主任强调纪律问题！&quot;)；
    &#125;
    
    public double getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(double salary) &#123;
        this.salary = salary;
    &#125;
&#125;
</code></pre>
<p><strong>5.测试类</strong></p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        Teacher dlei = new Teacher();
        dlei.setName(&quot;播仔&quot;);
        dlei.setAge(&quot;31&quot;);
        dlei.setSalary(1000.99);
        System.out.println(dlei.getName());
        System.out.println(dlei.getAge());
        System.out.println(dlei.getSalary());
        dlei.teach();
        
        BanZhuRen linTao = new BanZhuRen();
        linTao.setName(&quot;灵涛&quot;);
        linTao.setAge(&quot;28&quot;);
        linTao.setSalary(1000.99);
        System.out.println(linTao.getName());
        System.out.println(linTao.getAge());
        System.out.println(linTao.getSalary());
        linTao.admin();

        Student xugan = new Student();
        xugan.setName(&quot;播仔&quot;);
        xugan.setAge(&quot;31&quot;);
        //xugan.setSalary(1000.99); // xugan没有薪水属性，报错！
        System.out.println(xugan.getName());
        System.out.println(xugan.getAge());



    &#125;
&#125;
</code></pre>
<h3 id="3-3-4-小结"><a href="#3-3-4-小结" class="headerlink" title="3.3.4 小结"></a>3.3.4 小结</h3><p>1.继承实际上是子类相同的属性和行为可以定义在父类中，子类特有的属性和行为由自己定义，这样就实现了相同属性和行为的重复利用，从而提高了代码复用。</p>
<p>2.子类继承父类，就可以直接得到父类的成员变量和方法。是否可以继承所有成分呢？请看下节！</p>
<h2 id="3-4-子类不能继承的内容"><a href="#3-4-子类不能继承的内容" class="headerlink" title="3.4 子类不能继承的内容"></a>3.4 子类不能继承的内容</h2><h3 id="3-4-1-引入"><a href="#3-4-1-引入" class="headerlink" title="3.4.1 引入"></a>3.4.1 引入</h3><p>并不是父类的所有内容都可以给子类继承的：</p>
<p><strong>子类不能继承父类的构造器，因为子类有自己的构造器。</strong></p>
<p><strong>值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。</strong></p>
<h3 id="3-4-1-演示代码"><a href="#3-4-1-演示代码" class="headerlink" title="3.4.1 演示代码"></a>3.4.1 演示代码</h3><pre><code class="java">public class Demo03 &#123;
    public static void main(String[] args) &#123;
        Zi z = new Zi();
        System.out.println(z.num1);
//        System.out.println(z.num2); // 私有的子类无法使用
        // 通过getter/setter方法访问父类的private成员变量
        System.out.println(z.getNum2());

        z.show1();
        // z.show2(); // 私有的子类无法使用
    &#125;
&#125;

class Fu &#123;
    public int num1 = 10;
    private int num2 = 20;

    public void show1() &#123;
        System.out.println(&quot;show1&quot;);
    &#125;

    private void show2() &#123;
        System.out.println(&quot;show2&quot;);
    &#125;

    public int getNum2() &#123;
        return num2;
    &#125;

    public void setNum2(int num2) &#123;
        this.num2 = num2;
    &#125;
&#125;

class Zi extends Fu &#123;
&#125;
</code></pre>
<h2 id="3-5-继承后的特点—成员变量"><a href="#3-5-继承后的特点—成员变量" class="headerlink" title="3.5 继承后的特点—成员变量"></a>3.5 继承后的特点—成员变量</h2><p>当类之间产生了继承关系后，其中各类中的成员变量，又产生了哪些影响呢？</p>
<h3 id="3-5-1-成员变量不重名"><a href="#3-5-1-成员变量不重名" class="headerlink" title="3.5.1 成员变量不重名"></a>3.5.1 成员变量不重名</h3><p>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<strong>没有影响的</strong>。代码如下：</p>
<pre><code class="java">class Fu &#123;
    // Fu中的成员变量
    int num = 5;
&#125;
class Zi extends Fu &#123;
    // Zi中的成员变量
    int num2 = 6;
  
    // Zi中的成员方法
    public void show() &#123;
        // 访问父类中的num
        System.out.println(&quot;Fu num=&quot;+num); // 继承而来，所以直接访问。
        // 访问子类中的num2
        System.out.println(&quot;Zi num2=&quot;+num2);
    &#125;
&#125;
class Demo04 &#123;
    public static void main(String[] args) &#123;
        // 创建子类对象
        Zi z = new Zi(); 
          // 调用子类中的show方法
        z.show();  
    &#125;
&#125;

演示结果：
Fu num = 5
Zi num2 = 6
</code></pre>
<h3 id="3-5-2-成员变量重名"><a href="#3-5-2-成员变量重名" class="headerlink" title="3.5.2 成员变量重名"></a>3.5.2 成员变量重名</h3><p>如果子类父类中出现<strong>重名</strong>的成员变量，这时的访问是<strong>有影响的</strong>。代码如下：</p>
<pre><code class="java">class Fu1 &#123;
    // Fu中的成员变量。
    int num = 5;
&#125;
class Zi1 extends Fu1 &#123;
    // Zi中的成员变量
    int num = 6;
  
    public void show() &#123;
        // 访问父类中的num
        System.out.println(&quot;Fu num=&quot; + num);
        // 访问子类中的num
        System.out.println(&quot;Zi num=&quot; + num);
    &#125;
&#125;
class Demo04 &#123;
    public static void main(String[] args) &#123;
          // 创建子类对象
        Zi1 z = new Zi1(); 
          // 调用子类中的show方法
        z1.show(); 
    &#125;
&#125;
演示结果：
Fu num = 6
Zi num = 6
</code></pre>
<p>子父类中出现了同名的成员变量时，子类会优先访问自己对象中的成员变量。如果此时想访问父类成员变量如何解决呢？我们可以使用super关键字。</p>
<h3 id="3-5-3-super访问父类成员变量"><a href="#3-5-3-super访问父类成员变量" class="headerlink" title="3.5.3  super访问父类成员变量"></a>3.5.3  super访问父类成员变量</h3><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用<code>super</code> 关键字，修饰父类成员变量，类似于之前学过的 <code>this</code> 。</p>
<p>需要注意的是：<strong>super代表的是父类对象的引用，this代表的是当前对象的引用。</strong></p>
<p><strong>使用格式：</strong></p>
<pre><code class="java">super.父类成员变量名
</code></pre>
<p>子类方法需要修改，代码如下：</p>
<pre><code class="java">class Fu &#123;
    // Fu中的成员变量。
    int num = 5;
&#125;

class Zi extends Fu &#123;
    // Zi中的成员变量
    int num = 6;
  
    public void show() &#123;
        int num = 1;
      
        // 访问方法中的num
        System.out.println(&quot;method num=&quot; + num);
        // 访问子类中的num
        System.out.println(&quot;Zi num=&quot; + this.num);
        // 访问父类中的num
        System.out.println(&quot;Fu num=&quot; + super.num);
    &#125;
&#125;

class Demo04 &#123;
    public static void main(String[] args) &#123;
          // 创建子类对象
        Zi1 z = new Zi1(); 
          // 调用子类中的show方法
        z1.show(); 
    &#125;
&#125;

演示结果：
method num=1
Zi num=6
Fu num=5
</code></pre>
<blockquote>
<p>小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。</p>
</blockquote>
<h2 id="3-6-继承后的特点—成员方法"><a href="#3-6-继承后的特点—成员方法" class="headerlink" title="3.6 继承后的特点—成员方法"></a>3.6 继承后的特点—成员方法</h2><p>当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？</p>
<h3 id="3-6-1-成员方法不重名"><a href="#3-6-1-成员方法不重名" class="headerlink" title="3.6.1 成员方法不重名"></a>3.6.1 成员方法不重名</h3><p>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响的</strong>。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下：</p>
<pre><code class="java">class Fu &#123;
    public void show() &#123;
        System.out.println(&quot;Fu类中的show方法执行&quot;);
    &#125;
&#125;
class Zi extends Fu &#123;
    public void show2() &#123;
        System.out.println(&quot;Zi类中的show2方法执行&quot;);
    &#125;
&#125;
public  class Demo05 &#123;
    public static void main(String[] args) &#123;
        Zi z = new Zi();
         //子类中没有show方法，但是可以找到父类方法去执行
        z.show(); 
        z.show2();
    &#125;
&#125;
</code></pre>
<h3 id="3-6-2-成员方法重名"><a href="#3-6-2-成员方法重名" class="headerlink" title="3.6.2 成员方法重名"></a>3.6.2 成员方法重名</h3><p>如果子类父类中出现<strong>重名</strong>的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法。</p>
<p>代码如下：</p>
<pre><code class="java">class Fu &#123;
    public void show() &#123;
        System.out.println(&quot;Fu show&quot;);
    &#125;
&#125;
class Zi extends Fu &#123;
    //子类重写了父类的show方法
    public void show() &#123;
        System.out.println(&quot;Zi show&quot;);
    &#125;
&#125;
public class ExtendsDemo05&#123;
    public static void main(String[] args) &#123;
        Zi z = new Zi();
         // 子类中有show方法，只执行重写后的show方法
        z.show();  // Zi show
    &#125;
&#125;
</code></pre>
<h2 id="3-7-方法重写"><a href="#3-7-方法重写" class="headerlink" title="3.7 方法重写"></a>3.7 方法重写</h2><h3 id="3-7-1-概念"><a href="#3-7-1-概念" class="headerlink" title="3.7.1 概念"></a>3.7.1 概念</h3><p><strong>方法重写</strong> ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现</strong>。</p>
<h3 id="3-7-2-使用场景与案例"><a href="#3-7-2-使用场景与案例" class="headerlink" title="3.7.2 使用场景与案例"></a>3.7.2 使用场景与案例</h3><p>发生在子父类之间的关系。<br>子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方 法。</p>
<p>例如：我们定义了一个动物类代码如下：</p>
<pre><code class="java">public class Animal  &#123;
    public void run()&#123;
        System.out.println(&quot;动物跑的很快！&quot;);
    &#125;
    public void cry()&#123;
        System.out.println(&quot;动物都可以叫~~~&quot;);
    &#125;
&#125;
</code></pre>
<p>然后定义一个猫类，猫可能认为父类cry()方法不能满足自己的需求</p>
<p>代码如下：</p>
<pre><code class="java">public class Cat extends Animal &#123;
    public void cry()&#123;
        System.out.println(&quot;我们一起学猫叫，喵喵喵！喵的非常好听！&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
          // 创建子类对象
          Cat ddm = new Cat()；
        // 调用父类继承而来的方法
        ddm.run();
          // 调用子类重写的方法
          ddm.cry();
    &#125;
&#125;
</code></pre>
<h3 id="3-7-2-Override重写注解"><a href="#3-7-2-Override重写注解" class="headerlink" title="3.7.2 @Override重写注解"></a>3.7.2 @Override重写注解</h3><ul>
<li><p>@Override:注解，重写注解校验！</p>
</li>
<li><p>这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。</p>
</li>
<li><p>建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！</p>
<p>加上后的子类代码形式如下：</p>
<pre><code class="java">public class Cat extends Animal &#123;
     // 声明不变，重新实现
    // 方法名称与父类全部一样，只是方法体中的功能重写写了！
    @Override
    public void cry()&#123;
        System.out.println(&quot;我们一起学猫叫，喵喵喵！喵的非常好听！&quot;);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h3 id="3-7-3-注意事项"><a href="#3-7-3-注意事项" class="headerlink" title="3.7.3 注意事项"></a>3.7.3 注意事项</h3><ol>
<li>方法重写是发生在子父类之间的关系。</li>
<li>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li>
<li>子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</li>
</ol>
<h2 id="3-8-继承后的特点—构造器"><a href="#3-8-继承后的特点—构造器" class="headerlink" title="3.8 继承后的特点—构造器"></a>3.8 继承后的特点—构造器</h2><h3 id="3-8-1-引入"><a href="#3-8-1-引入" class="headerlink" title="3.8.1 引入"></a>3.8.1 引入</h3><p>当类之间产生了关系，其中各类中的构造器，又产生了哪些影响呢？<br>首先我们要回忆两个事情，构造器的定义格式和作用。</p>
<ol>
<li>构造器的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li>
<li>构造器的作用是初始化对象成员变量数据的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个<code>super()</code> ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。（<strong>先有爸爸，才能有儿子</strong>）</li>
</ol>
<p><strong>继承后子类构造器特点:子类所有构造器的第一行都会先调用父类的无参构造器，再执行自己</strong></p>
<h3 id="3-8-2-案例演示"><a href="#3-8-2-案例演示" class="headerlink" title="3.8.2 案例演示"></a>3.8.2 案例演示</h3><p>按如下需求定义类:</p>
<ol>
<li>人类<br>成员变量: 姓名,年龄<br>成员方法: 吃饭</li>
<li>学生类<br>成员变量: 姓名,年龄,成绩<br>成员方法: 吃饭</li>
</ol>
<p>代码如下：</p>
<pre><code class="java">class Person &#123;
    private String name;
    private int age;

    public Person() &#123;
        System.out.println(&quot;父类无参&quot;);
    &#125;

    // getter/setter省略
&#125;

class Student extends Person &#123;
    private double score;

    public Student() &#123;
        //super(); // 调用父类无参,默认就存在，可以不写，必须再第一行
        System.out.println(&quot;子类无参&quot;);
    &#125;
    
     public Student(double score) &#123;
        //super();  // 调用父类无参,默认就存在，可以不写，必须再第一行
        this.score = score;    
        System.out.println(&quot;子类有参&quot;);
     &#125;

&#125;

public class Demo07 &#123;
    public static void main(String[] args) &#123;
        Student s1 = new Student();
        System.out.println(&quot;----------&quot;);
        Student s2 = new Student(99.9);
    &#125;
&#125;

输出结果：
父类无参
子类无参
----------
父类无参
子类有参
</code></pre>
<h3 id="3-8-3-小结"><a href="#3-8-3-小结" class="headerlink" title="3.8.3 小结"></a>3.8.3 小结</h3><ul>
<li>子类构造器执行的时候，都会在第一行默认先调用父类无参数构造器一次。</li>
<li>子类构造器的第一行都隐含了一个**super()<strong>去调用父类无参数构造器，</strong>super()**可以省略不写。</li>
</ul>
<h2 id="3-9-super-…-和this-…"><a href="#3-9-super-…-和this-…" class="headerlink" title="3.9 super(…)和this(…)"></a>3.9 super(…)和this(…)</h2><h3 id="3-9-1-引入"><a href="#3-9-1-引入" class="headerlink" title="3.9.1  引入"></a>3.9.1  引入</h3><p>请看上节中的如下案例：</p>
<pre><code class="java">class Person &#123;
    private String name;
    private int age;

    public Person() &#123;
        System.out.println(&quot;父类无参&quot;);
    &#125;

    // getter/setter省略
&#125;

class Student extends Person &#123;
    private double score;

    public Student() &#123;
        //super(); // 调用父类无参构造器,默认就存在，可以不写，必须再第一行
        System.out.println(&quot;子类无参&quot;);
    &#125;
    
     public Student(double score) &#123;
        //super();  // 调用父类无参构造器,默认就存在，可以不写，必须再第一行
        this.score = score;    
        System.out.println(&quot;子类有参&quot;);
     &#125;
      // getter/setter省略
&#125;

public class Demo07 &#123;
    public static void main(String[] args) &#123;
        // 调用子类有参数构造器
        Student s2 = new Student(99.9);
        System.out.println(s2.getScore()); // 99.9
        System.out.println(s2.getName()); // 输出 null
        System.out.println(s2.getAge()); // 输出 0
    &#125;
&#125;
</code></pre>
<p>我们发现，子类有参数构造器只是初始化了自己对象中的成员变量score，而父类中的成员变量name和age依然是没有数据的，怎么解决这个问题呢，我们可以借助与super(…)去调用父类构造器，以便初始化继承自父类对象的name和age.</p>
<h3 id="3-9-2-super和this的用法格式"><a href="#3-9-2-super和this的用法格式" class="headerlink" title="3.9.2 super和this的用法格式"></a>3.9.2 super和this的用法格式</h3><p>super和this完整的用法如下，其中this，super访问成员我们已经接触过了。</p>
<pre><code class="java">this.成员变量        --    本类的
super.成员变量        --    父类的

this.成员方法名()      --    本类的    
super.成员方法名()   --    父类的
</code></pre>
<p>接下来我们使用调用构造器格式：</p>
<pre><code class="java">super(...) -- 调用父类的构造器，根据参数匹配确认
this(...) -- 调用本类的其他构造器，根据参数匹配确认
</code></pre>
<h3 id="3-9-3-super-…-用法演示"><a href="#3-9-3-super-…-用法演示" class="headerlink" title="3.9.3 super(….)用法演示"></a>3.9.3 super(….)用法演示</h3><p>代码如下：</p>
<pre><code class="java">class Person &#123;
    private String name =&quot;凤姐&quot;;
    private int age = 20;

    public Person() &#123;
        System.out.println(&quot;父类无参&quot;);
    &#125;
    
    public Person(String name , int age)&#123;
        this.name = name ;
        this.age = age ;
    &#125;

    // getter/setter省略
&#125;

class Student extends Person &#123;
    private double score = 100;

    public Student() &#123;
        //super(); // 调用父类无参构造器,默认就存在，可以不写，必须再第一行
        System.out.println(&quot;子类无参&quot;);
    &#125;
    
     public Student(String name ， int age，double score) &#123;
        super(name ,age);// 调用父类有参构造器Person(String name , int age)初始化name和age
        this.score = score;    
        System.out.println(&quot;子类有参&quot;);
     &#125;
      // getter/setter省略
&#125;

public class Demo07 &#123;
    public static void main(String[] args) &#123;
        // 调用子类有参数构造器
        Student s2 = new Student(&quot;张三&quot;，20，99);
        System.out.println(s2.getScore()); // 99
        System.out.println(s2.getName()); // 输出 张三
        System.out.println(s2.getAge()); // 输出 20
    &#125;
&#125;
</code></pre>
<p><strong>注意：</strong></p>
<p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p>
<p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p>
<p>super(..)是根据参数去确定调用父类哪个构造器的。</p>
<h3 id="3-9-4-super-…-案例图解"><a href="#3-9-4-super-…-案例图解" class="headerlink" title="3.9.4 super(…)案例图解"></a>3.9.4 super(…)案例图解</h3><p><strong>父类空间优先于子类对象产生</strong></p>
<p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造七调用时，一定先调用父类的构造器。理解图解如下：</p>
<p><img src="/img/java/imgs1/2.jpg"></p>
<h3 id="3-9-5-this-…-用法演示"><a href="#3-9-5-this-…-用法演示" class="headerlink" title="3.9.5 this(…)用法演示"></a>3.9.5 this(…)用法演示</h3><p>this(…)</p>
<ul>
<li>   默认是去找本类中的其他构造器，根据参数来确定具体调用哪一个构造器。</li>
<li>   为了借用其他构造器的功能。</li>
</ul>
<pre><code class="java">package com.itheima._08this和super调用构造器;
/**
 * this(...):
 *    默认是去找本类中的其他构造器，根据参数来确定具体调用哪一个构造器。
 *    为了借用其他构造器的功能。
 *
 */
public class ThisDemo01 &#123;
    public static void main(String[] args) &#123;
        Student xuGan = new Student();
        System.out.println(xuGan.getName()); // 输出:徐干
        System.out.println(xuGan.getAge());// 输出:21
        System.out.println(xuGan.getSex());// 输出： 男
    &#125;
&#125;

class Student&#123;
    private String name ;
    private int age ;
    private char sex ;

    public Student() &#123;
  // 很弱，我的兄弟很牛逼啊，我可以调用其他构造器：Student(String name, int age, char sex)
        this(&quot;徐干&quot;,21,&#39;男&#39;);
    &#125;

    public Student(String name, int age, char sex) &#123;
        this.name = name ;
        this.age = age   ;
        this.sex = sex   ;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public char getSex() &#123;
        return sex;
    &#125;

    public void setSex(char sex) &#123;
        this.sex = sex;
    &#125;
&#125;
</code></pre>
<h3 id="3-9-6-小结"><a href="#3-9-6-小结" class="headerlink" title="3.9.6 小结"></a>3.9.6 小结</h3><ul>
<li><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p>
</li>
<li><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p>
</li>
<li><p><strong>super(..)和this(…)是根据参数去确定调用父类哪个构造器的。</strong></p>
</li>
<li><p>super(..)可以调用父类构造器初始化继承自父类的成员变量的数据。</p>
</li>
<li><p>this(..)可以调用本类中的其他构造器。</p>
</li>
</ul>
<h2 id="3-10-继承的特点"><a href="#3-10-继承的特点" class="headerlink" title="3.10 继承的特点"></a>3.10 继承的特点</h2><ol>
<li><p>Java只支持单继承，不支持多继承。</p>
<pre><code class="java">// 一个类只能有一个父类，不可以有多个父类。
class A &#123;&#125;
class B &#123;&#125;
class C1 extends A &#123;&#125; // ok
// class C2 extends A, B &#123;&#125; // error
</code></pre>
</li>
<li><p>一个类可以有多个子类。</p>
<pre><code class="java">// A可以有多个子类
class A &#123;&#125;
class C1 extends A &#123;&#125;
class C2 extends  A &#123;&#125;
</code></pre>
</li>
<li><p>可以多层继承。</p>
<pre><code class="java">class A &#123;&#125;
class C1 extends A &#123;&#125;
class D extends C1 &#123;&#125;
</code></pre>
<blockquote>
<p>顶层父类是Object类。所有的类默认继承Object，作为父类。</p>
</blockquote>
</li>
</ol>
<h1 id="第四章-引用类型使用小结-重点"><a href="#第四章-引用类型使用小结-重点" class="headerlink" title="第四章 引用类型使用小结(重点)"></a>第四章 引用类型使用小结(重点)</h1><p>​        实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类型也是可以的。在这我们使用两个例子 , 来学习一下。</p>
<h2 id="4-1-引用类型作为方法参数和返回值"><a href="#4-1-引用类型作为方法参数和返回值" class="headerlink" title="4.1 引用类型作为方法参数和返回值"></a>4.1 引用类型作为方法参数和返回值</h2><pre><code class="java">public class Person&#123;
  public void eat()&#123;
    System.out.println(&quot;吃饭&quot;);
  &#125;
&#125;
public class Test&#123;
  public static void main(String[] args)&#123;
        method(new Person());
           Person p = createPerson();
  &#125;
    
  //引用类型作为方法参数,在前面笔记本案例中我们也使用了接口类型作为方法参数
  pubic static void method(Person p)&#123;
       p.eat();
  &#125;
    
  //引用类型作为返回值
  public static Person createPerson()&#123;
        return new Person();
  &#125;
&#125;
</code></pre>
<h2 id="4-2-引用类型作为成员变量"><a href="#4-2-引用类型作为成员变量" class="headerlink" title="4.2 引用类型作为成员变量"></a>4.2 引用类型作为成员变量</h2><p>​    我们每个人(Person)都有一个身份证(IDCard) , 为了表示这种关系 , 就需要在Person中定义一个IDCard的成员变量。定义Person类时，代码如下：</p>
<pre><code class="java">class Person &#123;
    String name;//姓名
    int age;//年龄
&#125;
</code></pre>
<p>​    使用使用<code>String</code> 类型表示姓名 , <code>int</code> 类型表示年龄。其实，<code>String</code>本身就是引用类型，我们往往忽略了它是引用类型。如果我们继续丰富这个类的定义，给<code>Person</code> 增加身份证号 , 身份证签发机关等属性，我们将如何编写呢？这时候就需要编写一个IDCard类了</p>
<p>定义IDCard(身份证)类，添加身份证号 , 签发地等属性：</p>
<pre><code class="java">class IDCard &#123;
    String idNum;//身份证号
    String authority;//签发地
  
      //getter和setter方法
      //...
      
      //toString方法
      //...
&#125;
</code></pre>
<p>修改Person类：</p>
<pre><code class="java">public class Person &#123;
    String name;//姓名
    int age;//年龄

    IDCard idCard;//表示自己的身份证信息

    //name和age的getter、setter方法
    //...

    public IDCard getIdCard() &#123;
        return idCard;
    &#125;

    public void setIdCard(IDCard idCard) &#123;
        this.idCard = idCard;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, idCard=&quot; + idCard +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>测试类：</p>
<pre><code class="java">public class TestDemo &#123;
    public static void main(String[] args) &#123;
        //创建IDCard对象
        IDCard idCard = new IDCard();
        //设置身份证号
        idCard.setIdNum(&quot;110113201606066666&quot;);
        //设置签发地
        idCard.setAuthority(&quot;北京市顺义区公安局&quot;);

        //创建Person对象
        Person p = new Person();
        //设置姓名
        p.setName(&quot;小顺子&quot;);
        //设置年龄
        p.setAge(2);
        //设置身份证信息
        p.setIdCard(idCard);

        //打印小顺子的信息
        System.out.println(p);
    &#125;
&#125;
输出结果:
Person&#123;name=&#39;小顺子&#39;, age=2, idCard=IDCard&#123;idNum=&#39;110113201606066666&#39;, authority=&#39;北京市顺义区公安局&#39;&#125;&#125;
</code></pre>
<blockquote>
<p>类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。同理 , 接口也是如此 , 例如我们笔记本案例中使用usb设备。在此我们只是通过小例子 , 让大家熟识下引用类型的用法 , 后续在咱们的就业班学习中 , 这种方式会使用的很多。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ehZyiL</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/09/05/JAVA/day01-%E5%A4%8D%E4%B9%A0%E5%9B%9E%E9%A1%BE%E3%80%81%E9%9D%99%E6%80%81%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/">http://example.com/2021/09/05/JAVA/day01-%E5%A4%8D%E4%B9%A0%E5%9B%9E%E9%A1%BE%E3%80%81%E9%9D%99%E6%80%81%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ehZyiL的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E8%BF%9B%E9%98%B613%E5%A4%A9%E8%B5%84%E6%96%99/">java进阶13天资料</a></div><div class="post_share"><div class="social-share" data-image="/img/java/cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/05/JAVA/day02-%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81final%E3%80%81%E5%8D%95%E4%BE%8B%E3%80%81%E6%9E%9A%E4%B8%BE/"><img class="prev-cover" src="/img/java/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Day02</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/03/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"><img class="next-cover" src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">软件项目管理笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/09/05/JAVA/day02-抽象类，接口、代码块、final、单例、枚举/" title="Day02"><img class="cover" src="/img/java/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-05</div><div class="title">Day02</div></div></a></div><div><a href="/2021/09/05/JAVA/day03【多态、代码块、包、权限修饰符、内部类，Object类】/" title="Day03"><img class="cover" src="/img/java/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-05</div><div class="title">Day03</div></div></a></div><div><a href="/2021/09/05/JAVA/day04【常用API，自定义泛型、collection接口】/" title="Day04"><img class="cover" src="/img/java/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-05</div><div class="title">Day04</div></div></a></div><div><a href="/2021/09/05/JAVA/day05-迭代器，数据结构,List,Set ,TreeSet集合,Collections工具类/" title="Day05"><img class="cover" src="/img/java/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-05</div><div class="title">Day05</div></div></a></div><div><a href="/2021/09/05/JAVA/day06【Map】/" title="Day06"><img class="cover" src="/img/java/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-05</div><div class="title">Day06</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ehZyiL</div><div class="author-info__description">ehZyiL的博客</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ehZyiL"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ehZyiL" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/495028518@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">分享与记录,持续更新ing</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#day01%E3%80%90%E5%A4%8D%E4%B9%A0%E5%9B%9E%E9%A1%BE%E3%80%81%E9%9D%99%E6%80%81%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">day01【复习回顾、静态、继承、引用类型使用】</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8A%E6%97%A5%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.</span> <span class="toc-text">今日内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%99%E5%AD%A6%E7%9B%AE%E6%A0%87"><span class="toc-number">1.2.</span> <span class="toc-text">教学目标</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%A4%8D%E4%B9%A0%E5%9B%9E%E9%A1%BE"><span class="toc-number">2.</span> <span class="toc-text">第一章 复习回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 如何定义类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 如何通过类创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%B0%81%E8%A3%85"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E5%B0%81%E8%A3%85%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.3.0.1.</span> <span class="toc-text">1.3.1 封装的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E5%B0%81%E8%A3%85%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.0.2.</span> <span class="toc-text">1.3.2 封装的步骤实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text">1.4 构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">1.4.1 构造器的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">1.4.2 构造器的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">1.4.3 构造器的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.5.</span> <span class="toc-text">1.5 this关键字的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">1.5.1 this关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">1.5.2 this关键字的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-1-%E7%94%A8%E4%BA%8E%E6%99%AE%E9%80%9A%E7%9A%84gettter%E4%B8%8Esetter%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">1.5.2.1 用于普通的gettter与setter方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-2-%E7%94%A8%E4%BA%8E%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">1.5.2.2 用于构造器中</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.</span> <span class="toc-text">第二章 static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 定义格式和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.2.1 静态变量及其访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2.2 实例变量及其访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.2.3 静态方法及其访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.2.4 实例方法及其访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%B0%8F%E7%BB%93"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BB%A7%E6%89%BF"><span class="toc-number">4.</span> <span class="toc-text">第三章 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E5%BC%95%E5%85%A5"><span class="toc-number">4.1.1.</span> <span class="toc-text">3.1.1 引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">4.1.2.</span> <span class="toc-text">3.1.2 继承的含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">4.1.3.</span> <span class="toc-text">3.1.3 继承的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 继承的格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%BB%A7%E6%89%BF%E6%A1%88%E4%BE%8B"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 继承案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%A1%88%E4%BE%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.3.1 案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%A1%88%E4%BE%8B%E5%9B%BE%E8%A7%A3%E5%88%86%E6%9E%90"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.3.2 案例图解分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.3.3 案例代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-%E5%B0%8F%E7%BB%93"><span class="toc-number">4.3.4.</span> <span class="toc-text">3.3.4 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%AD%90%E7%B1%BB%E4%B8%8D%E8%83%BD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 子类不能继承的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%BC%95%E5%85%A5"><span class="toc-number">4.4.1.</span> <span class="toc-text">3.4.1 引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E6%BC%94%E7%A4%BA%E4%BB%A3%E7%A0%81"><span class="toc-number">4.4.2.</span> <span class="toc-text">3.4.1 演示代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E7%89%B9%E7%82%B9%E2%80%94%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.5.</span> <span class="toc-text">3.5 继承后的特点—成员变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8D%E9%87%8D%E5%90%8D"><span class="toc-number">4.5.1.</span> <span class="toc-text">3.5.1 成员变量不重名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E9%87%8D%E5%90%8D"><span class="toc-number">4.5.2.</span> <span class="toc-text">3.5.2 成员变量重名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-super%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.5.3.</span> <span class="toc-text">3.5.3  super访问父类成员变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E7%89%B9%E7%82%B9%E2%80%94%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">3.6 继承后的特点—成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%B8%8D%E9%87%8D%E5%90%8D"><span class="toc-number">4.6.1.</span> <span class="toc-text">3.6.1 成员方法不重名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E9%87%8D%E5%90%8D"><span class="toc-number">4.6.2.</span> <span class="toc-text">3.6.2 成员方法重名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">4.7.</span> <span class="toc-text">3.7 方法重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">4.7.1.</span> <span class="toc-text">3.7.1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%A1%88%E4%BE%8B"><span class="toc-number">4.7.2.</span> <span class="toc-text">3.7.2 使用场景与案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-Override%E9%87%8D%E5%86%99%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.7.3.</span> <span class="toc-text">3.7.2 @Override重写注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.7.4.</span> <span class="toc-text">3.7.3 注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E7%89%B9%E7%82%B9%E2%80%94%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.8.</span> <span class="toc-text">3.8 继承后的特点—构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-1-%E5%BC%95%E5%85%A5"><span class="toc-number">4.8.1.</span> <span class="toc-text">3.8.1 引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-2-%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">4.8.2.</span> <span class="toc-text">3.8.2 案例演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-3-%E5%B0%8F%E7%BB%93"><span class="toc-number">4.8.3.</span> <span class="toc-text">3.8.3 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-super-%E2%80%A6-%E5%92%8Cthis-%E2%80%A6"><span class="toc-number">4.9.</span> <span class="toc-text">3.9 super(…)和this(…)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-1-%E5%BC%95%E5%85%A5"><span class="toc-number">4.9.1.</span> <span class="toc-text">3.9.1  引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-2-super%E5%92%8Cthis%E7%9A%84%E7%94%A8%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.9.2.</span> <span class="toc-text">3.9.2 super和this的用法格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-3-super-%E2%80%A6-%E7%94%A8%E6%B3%95%E6%BC%94%E7%A4%BA"><span class="toc-number">4.9.3.</span> <span class="toc-text">3.9.3 super(….)用法演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-4-super-%E2%80%A6-%E6%A1%88%E4%BE%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">4.9.4.</span> <span class="toc-text">3.9.4 super(…)案例图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-5-this-%E2%80%A6-%E7%94%A8%E6%B3%95%E6%BC%94%E7%A4%BA"><span class="toc-number">4.9.5.</span> <span class="toc-text">3.9.5 this(…)用法演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-6-%E5%B0%8F%E7%BB%93"><span class="toc-number">4.9.6.</span> <span class="toc-text">3.9.6 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.10.</span> <span class="toc-text">3.10 继承的特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93-%E9%87%8D%E7%82%B9"><span class="toc-number">5.</span> <span class="toc-text">第四章 引用类型使用小结(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 引用类型作为方法参数和返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 引用类型作为成员变量</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%80%BB%E7%BB%932.1-2.4/" title="操作系统原理 第二章总结2.1-2.4"><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统原理 第二章总结2.1-2.4"/></a><div class="content"><a class="title" href="/2021/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%80%BB%E7%BB%932.1-2.4/" title="操作系统原理 第二章总结2.1-2.4">操作系统原理 第二章总结2.1-2.4</a><time datetime="2021-09-26T14:04:17.462Z" title="发表于 2021-09-26 22:04:17">2021-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="操作系统原理 第一章总结"><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统原理 第一章总结"/></a><div class="content"><a class="title" href="/2021/09/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="操作系统原理 第一章总结">操作系统原理 第一章总结</a><time datetime="2021-09-07T09:56:04.000Z" title="发表于 2021-09-07 17:56:04">2021-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/06/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B(%E8%AE%B2%E8%A7%A3%E7%89%88)/" title="软件项目管理-生存期模型(讲解版)"><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B/%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8Bcover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件项目管理-生存期模型(讲解版)"/></a><div class="content"><a class="title" href="/2021/09/06/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B(%E8%AE%B2%E8%A7%A3%E7%89%88)/" title="软件项目管理-生存期模型(讲解版)">软件项目管理-生存期模型(讲解版)</a><time datetime="2021-09-06T04:36:08.000Z" title="发表于 2021-09-06 12:36:08">2021-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/05/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Scrum%E8%AE%B2%E8%A7%A3/" title="敏捷开发之Scrum"><img src="/img/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Scrum/Scrum%20cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="敏捷开发之Scrum"/></a><div class="content"><a class="title" href="/2021/09/05/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Scrum%E8%AE%B2%E8%A7%A3/" title="敏捷开发之Scrum">敏捷开发之Scrum</a><time datetime="2021-09-05T10:42:56.000Z" title="发表于 2021-09-05 18:42:56">2021-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/05/JAVA/day06%E3%80%90Map%E3%80%91/" title="Day06"><img src="/img/java/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Day06"/></a><div class="content"><a class="title" href="/2021/09/05/JAVA/day06%E3%80%90Map%E3%80%91/" title="Day06">Day06</a><time datetime="2021-09-05T02:35:46.000Z" title="发表于 2021-09-05 10:35:46">2021-09-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/java/cover.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By ehZyiL</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?ehZyiL";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="ehZyiL";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style> <script data-pjax>if(document.getElementById('recent-posts') && location.pathname =='/'){
    
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载swiper')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script>
<script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script>
<script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script>
<style></style><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script data-pjax>function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax  src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><!-- hexo injector body_end end --></body></html>